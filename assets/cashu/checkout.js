(function(){"use strict";function Be(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Bn(r,t){return Array.isArray(t)?t.length===0?!0:r?t.every(e=>typeof e=="string"):t.every(e=>Number.isSafeInteger(e)):!1}function gs(r){if(typeof r!="function")throw new Error("function expected");return!0}function Me(r,t){if(typeof t!="string")throw new Error(`${r}: string expected`);return!0}function Ce(r){if(!Number.isSafeInteger(r))throw new Error(`invalid integer: ${r}`)}function Te(r){if(!Array.isArray(r))throw new Error("array expected")}function Mn(r,t){if(!Bn(!0,t))throw new Error(`${r}: array of strings expected`)}function ms(r,t){if(!Bn(!1,t))throw new Error(`${r}: array of numbers expected`)}function Cn(...r){const t=o=>o,e=(o,i)=>a=>o(i(a)),n=r.map(o=>o.encode).reduceRight(e,t),s=r.map(o=>o.decode).reduce(e,t);return{encode:n,decode:s}}function ys(r){const t=typeof r=="string"?r.split(""):r,e=t.length;Mn("alphabet",t);const n=new Map(t.map((s,o)=>[s,o]));return{encode:s=>(Te(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=e)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${r}`);return t[o]})),decode:s=>(Te(s),s.map(o=>{Me("alphabet.decode",o);const i=n.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${r}`);return i}))}}function ws(r=""){return Me("join",r),{encode:t=>(Mn("join.decode",t),t.join(r)),decode:t=>(Me("join.decode",t),t.split(r))}}function Tn(r,t,e){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(e<2)throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);if(Te(r),!r.length)return[];let n=0;const s=[],o=Array.from(r,a=>{if(Ce(a),a<0||a>=t)throw new Error(`invalid integer: ${a}`);return a}),i=o.length;for(;;){let a=0,c=!0;for(let u=n;u<i;u++){const l=o[u],d=t*a,m=d+l;if(!Number.isSafeInteger(m)||d/t!==a||m-l!==d)throw new Error("convertRadix: carry overflow");const g=m/e;a=m%e;const w=Math.floor(g);if(o[u]=w,!Number.isSafeInteger(w)||w*e+a!==m)throw new Error("convertRadix: carry overflow");if(c)w?c=!1:n=u;else continue}if(s.push(a),c)break}for(let a=0;a<r.length-1&&r[a]===0;a++)s.push(0);return s.reverse()}function bs(r){Ce(r);const t=2**8;return{encode:e=>{if(!Be(e))throw new Error("radix.encode input should be Uint8Array");return Tn(Array.from(e),t,r)},decode:e=>(ms("radix.decode",e),Uint8Array.from(Tn(e,r,t)))}}function vs(r,t){return Ce(r),gs(t),{encode(e){if(!Be(e))throw new Error("checksum.encode: input should be Uint8Array");const n=t(e).slice(0,r),s=new Uint8Array(e.length+r);return s.set(e),s.set(n,e.length),s},decode(e){if(!Be(e))throw new Error("checksum.decode: input should be Uint8Array");const n=e.slice(0,-r),s=e.slice(-r),o=t(n).slice(0,r);for(let i=0;i<r;i++)if(o[i]!==s[i])throw new Error("Invalid checksum");return n}}}const ks=(r=>Cn(bs(58),ys(r),ws("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Es=r=>Cn(vs(4,t=>r(r(t))),ks);function Pe(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ot(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function Q(r,t,e=""){const n=Pe(r),s=r?.length,o=t!==void 0;if(!n||o&&s!==t){const i=e&&`"${e}" `,a=o?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(i+"expected Uint8Array"+a+", got "+c)}return r}function Pn(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Ot(r.outputLen),Ot(r.blockLen)}function ae(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function xs(r,t){Q(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function xt(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function $t(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function gt(r,t){return r<<32-t|r>>>t}function ce(r,t){return r<<t|r>>>32-t>>>0}const On=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",_s=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function tt(r){if(Q(r),On)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=_s[r[e]];return t}const bt={_0:48,_9:57,A:65,F:70,a:97,f:102};function qn(r){if(r>=bt._0&&r<=bt._9)return r-bt._0;if(r>=bt.A&&r<=bt.F)return r-(bt.A-10);if(r>=bt.a&&r<=bt.f)return r-(bt.a-10)}function G(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(On)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const i=qn(r.charCodeAt(o)),a=qn(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function Nn(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function ot(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];Q(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const o=r[n];e.set(o,s),s+=o.length}return e}function Oe(r,t={}){const e=(s,o)=>r(o).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function qt(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const Un=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Is(r,t,e){return r&t^~r&e}function As(r,t,e){return r&t^r&e^t&e}class qe{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,e,n,s){this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=$t(this.buffer)}update(t){ae(this),Q(t);const{view:e,buffer:n,blockLen:s}=this,o=t.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=$t(t);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ae(this),xs(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;e[i++]=128,xt(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(n,0),i=0);for(let d=i;d<s;d++)e[d]=0;n.setBigUint64(s-8,BigInt(this.length*8),o),this.process(n,0);const a=$t(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return t.destroyed=i,t.finished=o,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const _t=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),rt=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),ue=BigInt(2**32-1),Rn=BigInt(32);function Ss(r,t=!1){return t?{h:Number(r&ue),l:Number(r>>Rn&ue)}:{h:Number(r>>Rn&ue)|0,l:Number(r&ue)|0}}function Bs(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let o=0;o<e;o++){const{h:i,l:a}=Ss(r[o],t);[n[o],s[o]]=[i,a]}return[n,s]}const Dn=(r,t,e)=>r>>>e,Ln=(r,t,e)=>r<<32-e|t>>>e,Ht=(r,t,e)=>r>>>e|t<<32-e,jt=(r,t,e)=>r<<32-e|t>>>e,le=(r,t,e)=>r<<64-e|t>>>e-32,he=(r,t,e)=>r>>>e-32|t<<64-e;function vt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Ms=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Cs=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Ts=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Ps=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Os=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),qs=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0,Ns=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),It=new Uint32Array(64);class Us extends qe{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[t,e,n,s,o,i,a,c]}set(t,e,n,s,o,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let d=0;d<16;d++,e+=4)It[d]=t.getUint32(e,!1);for(let d=16;d<64;d++){const m=It[d-15],g=It[d-2],w=gt(m,7)^gt(m,18)^m>>>3,_=gt(g,17)^gt(g,19)^g>>>10;It[d]=_+It[d-7]+w+It[d-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const m=gt(a,6)^gt(a,11)^gt(a,25),g=l+m+Is(a,c,u)+Ns[d]+It[d]|0,_=(gt(n,2)^gt(n,13)^gt(n,22))+As(n,s,o)|0;l=u,u=c,c=a,a=i+g|0,i=o,o=s,s=n,n=g+_|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){xt(It)}destroy(){this.set(0,0,0,0,0,0,0,0),xt(this.buffer)}}class Rs extends Us{A=_t[0]|0;B=_t[1]|0;C=_t[2]|0;D=_t[3]|0;E=_t[4]|0;F=_t[5]|0;G=_t[6]|0;H=_t[7]|0;constructor(){super(32)}}const Fn=Bs(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Ds=Fn[0],Ls=Fn[1],At=new Uint32Array(80),St=new Uint32Array(80);class Fs extends qe{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:d,Fl:m,Gh:g,Gl:w,Hh:_,Hl:b}=this;return[t,e,n,s,o,i,a,c,u,l,d,m,g,w,_,b]}set(t,e,n,s,o,i,a,c,u,l,d,m,g,w,_,b){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=d|0,this.Fl=m|0,this.Gh=g|0,this.Gl=w|0,this.Hh=_|0,this.Hl=b|0}process(t,e){for(let U=0;U<16;U++,e+=4)At[U]=t.getUint32(e),St[U]=t.getUint32(e+=4);for(let U=16;U<80;U++){const R=At[U-15]|0,j=St[U-15]|0,Y=Ht(R,j,1)^Ht(R,j,8)^Dn(R,j,7),N=jt(R,j,1)^jt(R,j,8)^Ln(R,j,7),M=At[U-2]|0,B=St[U-2]|0,K=Ht(M,B,19)^le(M,B,61)^Dn(M,B,6),J=jt(M,B,19)^he(M,B,61)^Ln(M,B,6),D=Ts(N,J,St[U-7],St[U-16]),E=Ps(D,Y,K,At[U-7],At[U-16]);At[U]=E|0,St[U]=D|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:d,El:m,Fh:g,Fl:w,Gh:_,Gl:b,Hh:O,Hl:$}=this;for(let U=0;U<80;U++){const R=Ht(d,m,14)^Ht(d,m,18)^le(d,m,41),j=jt(d,m,14)^jt(d,m,18)^he(d,m,41),Y=d&g^~d&_,N=m&w^~m&b,M=Os($,j,N,Ls[U],St[U]),B=qs(M,O,R,Y,Ds[U],At[U]),K=M|0,J=Ht(n,s,28)^le(n,s,34)^le(n,s,39),D=jt(n,s,28)^he(n,s,34)^he(n,s,39),E=n&o^n&a^o&a,x=s&i^s&c^i&c;O=_|0,$=b|0,_=g|0,b=w|0,g=d|0,w=m|0,{h:d,l:m}=vt(u|0,l|0,B|0,K|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const p=Ms(K,D,x);n=Cs(p,B,J,E),s=p|0}({h:n,l:s}=vt(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=vt(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=vt(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=vt(this.Dh|0,this.Dl|0,u|0,l|0),{h:d,l:m}=vt(this.Eh|0,this.El|0,d|0,m|0),{h:g,l:w}=vt(this.Fh|0,this.Fl|0,g|0,w|0),{h:_,l:b}=vt(this.Gh|0,this.Gl|0,_|0,b|0),{h:O,l:$}=vt(this.Hh|0,this.Hl|0,O|0,$|0),this.set(n,s,o,i,a,c,u,l,d,m,g,w,_,b,O,$)}roundClean(){xt(At,St)}destroy(){xt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Ks extends Fs{Ah=rt[0]|0;Al=rt[1]|0;Bh=rt[2]|0;Bl=rt[3]|0;Ch=rt[4]|0;Cl=rt[5]|0;Dh=rt[6]|0;Dl=rt[7]|0;Eh=rt[8]|0;El=rt[9]|0;Fh=rt[10]|0;Fl=rt[11]|0;Gh=rt[12]|0;Gl=rt[13]|0;Hh=rt[14]|0;Hl=rt[15]|0;constructor(){super(64)}}const nt=Oe(()=>new Rs,Un(1)),Kn=Oe(()=>new Ks,Un(3));const Ne=BigInt(0),Ue=BigInt(1);function fe(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function $n(r){if(typeof r=="bigint"){if(!pe(r))throw new Error("positive bigint expected, got "+r)}else Ot(r);return r}function de(r){const t=$n(r).toString(16);return t.length&1?"0"+t:t}function Hn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ne:BigInt("0x"+r)}function Jt(r){return Hn(tt(r))}function jn(r){return Hn(tt($s(Q(r)).reverse()))}function Re(r,t){Ot(t),r=$n(r);const e=G(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function Wn(r,t){return Re(r,t).reverse()}function $s(r){return Uint8Array.from(r)}function Hs(r){return Uint8Array.from(r,(t,e)=>{const n=t.charCodeAt(0);if(t.length!==1||n>127)throw new Error(`string contains non-ASCII character "${r[e]}" with code ${n} at position ${e}`);return n})}const pe=r=>typeof r=="bigint"&&Ne<=r;function js(r,t,e){return pe(r)&&pe(t)&&pe(e)&&t<=r&&r<e}function Ws(r,t,e,n){if(!js(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function zs(r){let t;for(t=0;r>Ne;r>>=Ue,t+=1);return t}const De=r=>(Ue<<BigInt(r))-Ue;function Qs(r,t,e){if(Ot(r,"hashLen"),Ot(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=b=>new Uint8Array(b),s=Uint8Array.of(),o=Uint8Array.of(0),i=Uint8Array.of(1),a=1e3;let c=n(r),u=n(r),l=0;const d=()=>{c.fill(1),u.fill(0),l=0},m=(...b)=>e(u,ot(c,...b)),g=(b=s)=>{u=m(o,b),c=m(),b.length!==0&&(u=m(i,b),c=m())},w=()=>{if(l++>=a)throw new Error("drbg: tried max amount of iterations");let b=0;const O=[];for(;b<t;){c=m();const $=c.slice();O.push($),b+=c.length}return ot(...O)};return(b,O)=>{d(),g(b);let $;for(;!($=O(w()));)g();return d(),$}}function Le(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(o,i,a){const c=r[o];if(a&&c===void 0)return;const u=typeof c;if(u!==i||c===null)throw new Error(`param "${o}" is invalid: expected ${i}, got ${u}`)}const s=(o,i)=>Object.entries(o).forEach(([a,c])=>n(a,c,i));s(t,!1),s(e,!0)}function zn(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const o=r(e,...n);return t.set(e,o),o}}const it=BigInt(0),st=BigInt(1),Nt=BigInt(2),Qn=BigInt(3),Vn=BigInt(4),Zn=BigInt(5),Vs=BigInt(7),Gn=BigInt(8),Zs=BigInt(9),Yn=BigInt(16);function lt(r,t){const e=r%t;return e>=it?e:t+e}function ct(r,t,e){let n=r;for(;t-- >it;)n*=n,n%=e;return n}function Jn(r,t){if(r===it)throw new Error("invert: expected non-zero number");if(t<=it)throw new Error("invert: expected positive modulus, got "+t);let e=lt(r,t),n=t,s=it,o=st;for(;e!==it;){const a=n/e,c=n%e,u=s-o*a;n=e,e=c,s=o,o=u}if(n!==st)throw new Error("invert: does not exist");return lt(s,t)}function Fe(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function Xn(r,t){const e=(r.ORDER+st)/Vn,n=r.pow(t,e);return Fe(r,n,t),n}function Gs(r,t){const e=(r.ORDER-Zn)/Gn,n=r.mul(t,Nt),s=r.pow(n,e),o=r.mul(t,s),i=r.mul(r.mul(o,Nt),s),a=r.mul(o,r.sub(i,r.ONE));return Fe(r,a,t),a}function Ys(r){const t=ge(r),e=tr(r),n=e(t,t.neg(t.ONE)),s=e(t,n),o=e(t,t.neg(n)),i=(r+Vs)/Yn;return(a,c)=>{let u=a.pow(c,i),l=a.mul(u,n);const d=a.mul(u,s),m=a.mul(u,o),g=a.eql(a.sqr(l),c),w=a.eql(a.sqr(d),c);u=a.cmov(u,l,g),l=a.cmov(m,d,w);const _=a.eql(a.sqr(l),c),b=a.cmov(u,l,_);return Fe(a,b,c),b}}function tr(r){if(r<Qn)throw new Error("sqrt is not defined for small field");let t=r-st,e=0;for(;t%Nt===it;)t/=Nt,e++;let n=Nt;const s=ge(r);for(;nr(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Xn;let o=s.pow(n,t);const i=(t+st)/Nt;return function(c,u){if(c.is0(u))return u;if(nr(c,u)!==1)throw new Error("Cannot find square root");let l=e,d=c.mul(c.ONE,o),m=c.pow(u,t),g=c.pow(u,i);for(;!c.eql(m,c.ONE);){if(c.is0(m))return c.ZERO;let w=1,_=c.sqr(m);for(;!c.eql(_,c.ONE);)if(w++,_=c.sqr(_),w===l)throw new Error("Cannot find square root");const b=st<<BigInt(l-w-1),O=c.pow(d,b);l=w,d=c.sqr(O),m=c.mul(m,d),g=c.mul(g,O)}return g}}function Js(r){return r%Vn===Qn?Xn:r%Gn===Zn?Gs:r%Yn===Zs?Ys(r):tr(r)}const Xs=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function to(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=Xs.reduce((n,s)=>(n[s]="function",n),t);return Le(r,e),r}function eo(r,t,e){if(e<it)throw new Error("invalid exponent, negatives unsupported");if(e===it)return r.ONE;if(e===st)return t;let n=r.ONE,s=t;for(;e>it;)e&st&&(n=r.mul(n,s)),s=r.sqr(s),e>>=st;return n}function er(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((i,a,c)=>r.is0(a)?i:(n[c]=i,r.mul(i,a)),r.ONE),o=r.inv(s);return t.reduceRight((i,a,c)=>r.is0(a)?i:(n[c]=r.mul(i,n[c]),r.mul(i,a)),o),n}function nr(r,t){const e=(r.ORDER-st)/Nt,n=r.pow(t,e),s=r.eql(n,r.ONE),o=r.eql(n,r.ZERO),i=r.eql(n,r.neg(r.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function no(r,t){t!==void 0&&Ot(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class ro{ORDER;BITS;BYTES;isLE;ZERO=it;ONE=st;_lengths;_sqrt;_mod;constructor(t,e={}){if(t<=it)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=e.allowedLengths?.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:o}=no(t,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=o,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return lt(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return it<=t&&t<this.ORDER}is0(t){return t===it}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&st)===st}neg(t){return lt(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return lt(t*t,this.ORDER)}add(t,e){return lt(t+e,this.ORDER)}sub(t,e){return lt(t-e,this.ORDER)}mul(t,e){return lt(t*e,this.ORDER)}pow(t,e){return eo(this,t,e)}div(t,e){return lt(t*Jn(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return Jn(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Js(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Wn(t,this.BYTES):Re(t,this.BYTES)}fromBytes(t,e=!1){Q(t);const{_lengths:n,BYTES:s,isLE:o,ORDER:i,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,o?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=o?jn(t):Jt(t);if(a&&(c=lt(c,i)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return er(this,t)}cmov(t,e,n){return n?e:t}}function ge(r,t={}){return new ro(r,t)}function rr(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function sr(r){const t=rr(r);return t+Math.ceil(t/2)}function or(r,t,e=!1){Q(r);const n=r.length,s=rr(t),o=sr(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const i=e?jn(r):Jt(r),a=lt(i,t-st)+st;return e?Wn(a,s):Re(a,s)}const Wt=BigInt(0),Ut=BigInt(1);function me(r,t){const e=t.negate();return r?e:t}function ir(r,t){const e=er(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function ar(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Ke(r,t){ar(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,o=De(r),i=BigInt(r);return{windows:e,windowSize:n,mask:o,maxNumber:s,shiftBy:i}}function cr(r,t,e){const{windowSize:n,mask:s,maxNumber:o,shiftBy:i}=e;let a=Number(r&s),c=r>>i;a>n&&(a-=o,c+=Ut);const u=t*n,l=u+Math.abs(a)-1,d=a===0,m=a<0,g=t%2!==0;return{nextN:c,offset:l,isZero:d,isNeg:m,isNegF:g,offsetF:u}}const $e=new WeakMap,ur=new WeakMap;function He(r){return ur.get(r)||1}function lr(r){if(r!==Wt)throw new Error("invalid wNAF")}class so{BASE;ZERO;Fn;bits;constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>Wt;)e&Ut&&(n=n.add(s)),s=s.double(),e>>=Ut;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=Ke(e,this.bits),o=[];let i=t,a=i;for(let c=0;c<n;c++){a=i,o.push(a);for(let u=1;u<s;u++)a=a.add(i),o.push(a);i=a.double()}return o}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const i=Ke(t,this.bits);for(let a=0;a<i.windows;a++){const{nextN:c,offset:u,isZero:l,isNeg:d,isNegF:m,offsetF:g}=cr(n,a,i);n=c,l?o=o.add(me(m,e[g])):s=s.add(me(d,e[u]))}return lr(n),{p:s,f:o}}wNAFUnsafe(t,e,n,s=this.ZERO){const o=Ke(t,this.bits);for(let i=0;i<o.windows&&n!==Wt;i++){const{nextN:a,offset:c,isZero:u,isNeg:l}=cr(n,i,o);if(n=a,!u){const d=e[c];s=s.add(l?d.negate():d)}}return lr(n),s}getPrecomputes(t,e,n){let s=$e.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),$e.set(e,s))),s}cached(t,e,n){const s=He(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const o=He(t);return o===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,s)}createCache(t,e){ar(e,this.bits),ur.set(t,e),$e.delete(t)}hasCache(t){return He(t)!==1}}function oo(r,t,e,n){let s=t,o=r.ZERO,i=r.ZERO;for(;e>Wt||n>Wt;)e&Ut&&(o=o.add(s)),n&Ut&&(i=i.add(s)),s=s.double(),e>>=Ut,n>>=Ut;return{p1:o,p2:i}}function hr(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return to(t),t}else return ge(r,{isLE:e})}function io(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const u=t[c];if(!(typeof u=="bigint"&&u>Wt))throw new Error(`CURVE.${c} must be positive bigint`)}const s=hr(t.p,e.Fp,n),o=hr(t.n,e.Fn,n),a=["Gx","Gy","a","b"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:o}}function fr(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}class dr{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,e){if(Pn(t),Q(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),xt(s)}update(t){return ae(this),this.iHash.update(t),this}digestInto(t){ae(this),Q(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:e,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=o,t.blockLen=i,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Xt=(r,t,e)=>new dr(r,t).update(e).digest();Xt.create=(r,t)=>new dr(r,t);const pr=(r,t)=>(r+(r>=0?t:-t)/gr)/t;function ao(r,t,e){const[[n,s],[o,i]]=t,a=pr(i*r,e),c=pr(-s*r,e);let u=r-a*n-c*o,l=-a*s-c*i;const d=u<kt,m=l<kt;d&&(u=-u),m&&(l=-l);const g=De(Math.ceil(zs(e)/2))+zt;if(u<kt||u>=g||l<kt||l>=g)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:d,k1:u,k2neg:m,k2:l}}function je(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function We(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return fe(e.lowS,"lowS"),fe(e.prehash,"prehash"),e.format!==void 0&&je(e.format),e}class co extends Error{constructor(t=""){super(t)}}const Bt={Err:co,_tlv:{encode:(r,t)=>{const{Err:e}=Bt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=de(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=n>127?de(s.length/2|128):"";return de(r)+o+s+t},decode(r,t){const{Err:e}=Bt;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+c);if(u.length!==c)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const l of u)i=i<<8|l;if(n+=c,i<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+i);if(a.length!==i)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+i)}}},_int:{encode(r){const{Err:t}=Bt;if(r<kt)throw new t("integer: negative integers are not allowed");let e=de(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=Bt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Jt(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=Bt,s=Q(r,void 0,"signature"),{v:o,l:i}=n.decode(48,s);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:u,l}=n.decode(2,c);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(u)}},hexFromSig(r){const{_tlv:t,_int:e}=Bt,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),o=n+s;return t.encode(48,o)}},kt=BigInt(0),zt=BigInt(1),gr=BigInt(2),ye=BigInt(3),uo=BigInt(4);function lo(r,t={}){const e=io("weierstrass",r,t),{Fp:n,Fn:s}=e;let o=e.CURVE;const{h:i,n:a}=o;Le(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=yr(n,s);function l(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(D,E,x){const{x:p,y}=E.toAffine(),v=n.toBytes(p);if(fe(x,"isCompressed"),x){l();const I=!n.isOdd(y);return ot(mr(I),v)}else return ot(Uint8Array.of(4),v,n.toBytes(y))}function m(D){Q(D,void 0,"Point");const{publicKey:E,publicKeyUncompressed:x}=u,p=D.length,y=D[0],v=D.subarray(1);if(p===E&&(y===2||y===3)){const I=n.fromBytes(v);if(!n.isValid(I))throw new Error("bad point: is not on curve, wrong x");const C=_(I);let f;try{f=n.sqrt(C)}catch(S){const T=S instanceof Error?": "+S.message:"";throw new Error("bad point: is not on curve, sqrt error"+T)}l();const h=n.isOdd(f);return(y&1)===1!==h&&(f=n.neg(f)),{x:I,y:f}}else if(p===x&&y===4){const I=n.BYTES,C=n.fromBytes(v.subarray(0,I)),f=n.fromBytes(v.subarray(I,I*2));if(!b(C,f))throw new Error("bad point: is not on curve");return{x:C,y:f}}else throw new Error(`bad point: got length ${p}, expected compressed=${E} or uncompressed=${x}`)}const g=t.toBytes||d,w=t.fromBytes||m;function _(D){const E=n.sqr(D),x=n.mul(E,D);return n.add(n.add(x,n.mul(D,o.a)),o.b)}function b(D,E){const x=n.sqr(E),p=_(D);return n.eql(x,p)}if(!b(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const O=n.mul(n.pow(o.a,ye),uo),$=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(O,$)))throw new Error("bad curve params: a or b");function U(D,E,x=!1){if(!n.isValid(E)||x&&n.is0(E))throw new Error(`bad point coordinate ${D}`);return E}function R(D){if(!(D instanceof B))throw new Error("Weierstrass Point expected")}function j(D){if(!c||!c.basises)throw new Error("no endo");return ao(D,c.basises,s.ORDER)}const Y=zn((D,E)=>{const{X:x,Y:p,Z:y}=D;if(n.eql(y,n.ONE))return{x,y:p};const v=D.is0();E==null&&(E=v?n.ONE:n.inv(y));const I=n.mul(x,E),C=n.mul(p,E),f=n.mul(y,E);if(v)return{x:n.ZERO,y:n.ZERO};if(!n.eql(f,n.ONE))throw new Error("invZ was invalid");return{x:I,y:C}}),N=zn(D=>{if(D.is0()){if(t.allowInfinityPoint&&!n.is0(D.Y))return;throw new Error("bad point: ZERO")}const{x:E,y:x}=D.toAffine();if(!n.isValid(E)||!n.isValid(x))throw new Error("bad point: x or y not field elements");if(!b(E,x))throw new Error("bad point: equation left != right");if(!D.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function M(D,E,x,p,y){return x=new B(n.mul(x.X,D),x.Y,x.Z),E=me(p,E),x=me(y,x),E.add(x)}class B{static BASE=new B(o.Gx,o.Gy,n.ONE);static ZERO=new B(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=s;X;Y;Z;constructor(E,x,p){this.X=U("x",E),this.Y=U("y",x,!0),this.Z=U("z",p),Object.freeze(this)}static CURVE(){return o}static fromAffine(E){const{x,y:p}=E||{};if(!E||!n.isValid(x)||!n.isValid(p))throw new Error("invalid affine point");if(E instanceof B)throw new Error("projective point not allowed");return n.is0(x)&&n.is0(p)?B.ZERO:new B(x,p,n.ONE)}static fromBytes(E){const x=B.fromAffine(w(Q(E,void 0,"point")));return x.assertValidity(),x}static fromHex(E){return B.fromBytes(G(E))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(E=8,x=!0){return J.createCache(this,E),x||this.multiply(ye),this}assertValidity(){N(this)}hasEvenY(){const{y:E}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(E)}equals(E){R(E);const{X:x,Y:p,Z:y}=this,{X:v,Y:I,Z:C}=E,f=n.eql(n.mul(x,C),n.mul(v,y)),h=n.eql(n.mul(p,C),n.mul(I,y));return f&&h}negate(){return new B(this.X,n.neg(this.Y),this.Z)}double(){const{a:E,b:x}=o,p=n.mul(x,ye),{X:y,Y:v,Z:I}=this;let C=n.ZERO,f=n.ZERO,h=n.ZERO,k=n.mul(y,y),S=n.mul(v,v),T=n.mul(I,I),A=n.mul(y,v);return A=n.add(A,A),h=n.mul(y,I),h=n.add(h,h),C=n.mul(E,h),f=n.mul(p,T),f=n.add(C,f),C=n.sub(S,f),f=n.add(S,f),f=n.mul(C,f),C=n.mul(A,C),h=n.mul(p,h),T=n.mul(E,T),A=n.sub(k,T),A=n.mul(E,A),A=n.add(A,h),h=n.add(k,k),k=n.add(h,k),k=n.add(k,T),k=n.mul(k,A),f=n.add(f,k),T=n.mul(v,I),T=n.add(T,T),k=n.mul(T,A),C=n.sub(C,k),h=n.mul(T,S),h=n.add(h,h),h=n.add(h,h),new B(C,f,h)}add(E){R(E);const{X:x,Y:p,Z:y}=this,{X:v,Y:I,Z:C}=E;let f=n.ZERO,h=n.ZERO,k=n.ZERO;const S=o.a,T=n.mul(o.b,ye);let A=n.mul(x,v),q=n.mul(p,I),P=n.mul(y,C),F=n.add(x,p),L=n.add(v,I);F=n.mul(F,L),L=n.add(A,q),F=n.sub(F,L),L=n.add(x,y);let H=n.add(v,C);return L=n.mul(L,H),H=n.add(A,P),L=n.sub(L,H),H=n.add(p,y),f=n.add(I,C),H=n.mul(H,f),f=n.add(q,P),H=n.sub(H,f),k=n.mul(S,L),f=n.mul(T,P),k=n.add(f,k),f=n.sub(q,k),k=n.add(q,k),h=n.mul(f,k),q=n.add(A,A),q=n.add(q,A),P=n.mul(S,P),L=n.mul(T,L),q=n.add(q,P),P=n.sub(A,P),P=n.mul(S,P),L=n.add(L,P),A=n.mul(q,L),h=n.add(h,A),A=n.mul(H,L),f=n.mul(F,f),f=n.sub(f,A),A=n.mul(F,q),k=n.mul(H,k),k=n.add(k,A),new B(f,h,k)}subtract(E){return this.add(E.negate())}is0(){return this.equals(B.ZERO)}multiply(E){const{endo:x}=t;if(!s.isValidNot0(E))throw new Error("invalid scalar: out of range");let p,y;const v=I=>J.cached(this,I,C=>ir(B,C));if(x){const{k1neg:I,k1:C,k2neg:f,k2:h}=j(E),{p:k,f:S}=v(C),{p:T,f:A}=v(h);y=S.add(A),p=M(x.beta,k,T,I,f)}else{const{p:I,f:C}=v(E);p=I,y=C}return ir(B,[p,y])[0]}multiplyUnsafe(E){const{endo:x}=t,p=this;if(!s.isValid(E))throw new Error("invalid scalar: out of range");if(E===kt||p.is0())return B.ZERO;if(E===zt)return p;if(J.hasCache(this))return this.multiply(E);if(x){const{k1neg:y,k1:v,k2neg:I,k2:C}=j(E),{p1:f,p2:h}=oo(B,p,v,C);return M(x.beta,f,h,y,I)}else return J.unsafe(p,E)}toAffine(E){return Y(this,E)}isTorsionFree(){const{isTorsionFree:E}=t;return i===zt?!0:E?E(B,this):J.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:E}=t;return i===zt?this:E?E(B,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(E=!0){return fe(E,"isCompressed"),this.assertValidity(),g(B,this,E)}toHex(E=!0){return tt(this.toBytes(E))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const K=s.BITS,J=new so(B,t.endo?Math.ceil(K/2):K);return B.BASE.precompute(8),B}function mr(r){return Uint8Array.of(r?2:3)}function yr(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ho(r,t={}){const{Fn:e}=r,n=t.randomBytes||qt,s=Object.assign(yr(r.Fp,e),{seed:sr(e.ORDER)});function o(g){try{const w=e.fromBytes(g);return e.isValidNot0(w)}catch{return!1}}function i(g,w){const{publicKey:_,publicKeyUncompressed:b}=s;try{const O=g.length;return w===!0&&O!==_||w===!1&&O!==b?!1:!!r.fromBytes(g)}catch{return!1}}function a(g=n(s.seed)){return or(Q(g,s.seed,"seed"),e.ORDER)}function c(g,w=!0){return r.BASE.multiply(e.fromBytes(g)).toBytes(w)}function u(g){const{secretKey:w,publicKey:_,publicKeyUncompressed:b}=s;if(!Pe(g)||"_lengths"in e&&e._lengths||w===_)return;const O=Q(g,void 0,"key").length;return O===_||O===b}function l(g,w,_=!0){if(u(g)===!0)throw new Error("first arg must be private key");if(u(w)===!1)throw new Error("second arg must be public key");const b=e.fromBytes(g);return r.fromBytes(w).multiply(b).toBytes(_)}const d={isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a},m=fr(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:l,keygen:m,Point:r,utils:d,lengths:s})}function fo(r,t,e={}){Pn(t),Le(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||qt,s=e.hmac||((x,p)=>Xt(t,x,p)),{Fp:o,Fn:i}=r,{ORDER:a,BITS:c}=i,{keygen:u,getPublicKey:l,getSharedSecret:d,utils:m,lengths:g}=ho(r,e),w={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},_=a*gr<o.ORDER;function b(x){const p=a>>zt;return x>p}function O(x,p){if(!i.isValidNot0(p))throw new Error(`invalid signature ${x}: out of range 1..Point.Fn.ORDER`);return p}function $(){if(_)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function U(x,p){je(p);const y=g.signature,v=p==="compact"?y:p==="recovered"?y+1:void 0;return Q(x,v)}class R{r;s;recovery;constructor(p,y,v){if(this.r=O("r",p),this.s=O("s",y),v!=null){if($(),![0,1,2,3].includes(v))throw new Error("invalid recovery id");this.recovery=v}Object.freeze(this)}static fromBytes(p,y=w.format){U(p,y);let v;if(y==="der"){const{r:h,s:k}=Bt.toSig(Q(p));return new R(h,k)}y==="recovered"&&(v=p[0],y="compact",p=p.subarray(1));const I=g.signature/2,C=p.subarray(0,I),f=p.subarray(I,I*2);return new R(i.fromBytes(C),i.fromBytes(f),v)}static fromHex(p,y){return this.fromBytes(G(p),y)}assertRecovery(){const{recovery:p}=this;if(p==null)throw new Error("invalid recovery id: must be present");return p}addRecoveryBit(p){return new R(this.r,this.s,p)}recoverPublicKey(p){const{r:y,s:v}=this,I=this.assertRecovery(),C=I===2||I===3?y+a:y;if(!o.isValid(C))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const f=o.toBytes(C),h=r.fromBytes(ot(mr((I&1)===0),f)),k=i.inv(C),S=Y(Q(p,void 0,"msgHash")),T=i.create(-S*k),A=i.create(v*k),q=r.BASE.multiplyUnsafe(T).add(h.multiplyUnsafe(A));if(q.is0())throw new Error("invalid recovery: point at infinify");return q.assertValidity(),q}hasHighS(){return b(this.s)}toBytes(p=w.format){if(je(p),p==="der")return G(Bt.hexFromSig(this));const{r:y,s:v}=this,I=i.toBytes(y),C=i.toBytes(v);return p==="recovered"?($(),ot(Uint8Array.of(this.assertRecovery()),I,C)):ot(I,C)}toHex(p){return tt(this.toBytes(p))}}const j=e.bits2int||function(p){if(p.length>8192)throw new Error("input is too large");const y=Jt(p),v=p.length*8-c;return v>0?y>>BigInt(v):y},Y=e.bits2int_modN||function(p){return i.create(j(p))},N=De(c);function M(x){return Ws("num < 2^"+c,x,kt,N),i.toBytes(x)}function B(x,p){return Q(x,void 0,"message"),p?Q(t(x),void 0,"prehashed message"):x}function K(x,p,y){const{lowS:v,prehash:I,extraEntropy:C}=We(y,w);x=B(x,I);const f=Y(x),h=i.fromBytes(p);if(!i.isValidNot0(h))throw new Error("invalid private key");const k=[M(h),M(f)];if(C!=null&&C!==!1){const q=C===!0?n(g.secretKey):C;k.push(Q(q,void 0,"extraEntropy"))}const S=ot(...k),T=f;function A(q){const P=j(q);if(!i.isValidNot0(P))return;const F=i.inv(P),L=r.BASE.multiply(P).toAffine(),H=i.create(L.x);if(H===kt)return;const V=i.create(F*i.create(T+H*h));if(V===kt)return;let X=(L.x===H?0:2)|Number(L.y&zt),et=V;return v&&b(V)&&(et=i.neg(V),X^=1),new R(H,et,_?void 0:X)}return{seed:S,k2sig:A}}function J(x,p,y={}){const{seed:v,k2sig:I}=K(x,p,y);return Qs(t.outputLen,i.BYTES,s)(v,I).toBytes(y.format)}function D(x,p,y,v={}){const{lowS:I,prehash:C,format:f}=We(v,w);if(y=Q(y,void 0,"publicKey"),p=B(p,C),!Pe(x)){const h=x instanceof R?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+h)}U(x,f);try{const h=R.fromBytes(x,f),k=r.fromBytes(y);if(I&&h.hasHighS())return!1;const{r:S,s:T}=h,A=Y(p),q=i.inv(T),P=i.create(A*q),F=i.create(S*q),L=r.BASE.multiplyUnsafe(P).add(k.multiplyUnsafe(F));return L.is0()?!1:i.create(L.x)===S}catch{return!1}}function E(x,p,y={}){const{prehash:v}=We(y,w);return p=B(p,v),R.fromBytes(x,"recovered").recoverPublicKey(p).toBytes()}return Object.freeze({keygen:u,getPublicKey:l,getSharedSecret:d,utils:m,lengths:g,Point:r,sign:J,verify:D,recoverPublicKey:E,Signature:R,hash:t})}const we={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},po={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},go=BigInt(0),ze=BigInt(2);function mo(r){const t=we.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%t,l=u*u*r%t,d=ct(l,e,t)*l%t,m=ct(d,e,t)*l%t,g=ct(m,ze,t)*u%t,w=ct(g,s,t)*g%t,_=ct(w,o,t)*w%t,b=ct(_,a,t)*_%t,O=ct(b,c,t)*b%t,$=ct(O,a,t)*_%t,U=ct($,e,t)*l%t,R=ct(U,i,t)*w%t,j=ct(R,n,t)*u%t,Y=ct(j,ze,t);if(!be.eql(be.sqr(Y),r))throw new Error("Cannot find square root");return Y}const be=ge(we.p,{sqrt:mo}),Rt=lo(we,{Fp:be,endo:po}),Z=fo(Rt,nt),wr={};function ve(r,...t){let e=wr[r];if(e===void 0){const n=nt(Hs(r));e=ot(n,n),wr[r]=e}return nt(ot(e,...t))}const Qe=r=>r.toBytes(!0).slice(1),Ve=r=>r%ze===go;function Ze(r){const{Fn:t,BASE:e}=Rt,n=t.fromBytes(r),s=e.multiply(n);return{scalar:Ve(s.y)?n:t.neg(n),bytes:Qe(s)}}function br(r){const t=be;if(!t.isValidNot0(r))throw new Error("invalid x: Fail if x â‰¥ p");const e=t.create(r*r),n=t.create(e*r+BigInt(7));let s=t.sqrt(n);Ve(s)||(s=t.neg(s));const o=Rt.fromAffine({x:r,y:s});return o.assertValidity(),o}const te=Jt;function vr(...r){return Rt.Fn.create(te(ve("BIP0340/challenge",...r)))}function kr(r){return Ze(r).bytes}function yo(r,t,e=qt(32)){const{Fn:n}=Rt,s=Q(r,void 0,"message"),{bytes:o,scalar:i}=Ze(t),a=Q(e,32,"auxRand"),c=n.toBytes(i^te(ve("BIP0340/aux",a))),u=ve("BIP0340/nonce",c,o,s),{bytes:l,scalar:d}=Ze(u),m=vr(l,o,s),g=new Uint8Array(64);if(g.set(l,0),g.set(n.toBytes(n.create(d+m*i)),32),!Er(g,s,o))throw new Error("sign: Invalid signature produced");return g}function Er(r,t,e){const{Fp:n,Fn:s,BASE:o}=Rt,i=Q(r,64,"signature"),a=Q(t,void 0,"message"),c=Q(e,32,"publicKey");try{const u=br(te(c)),l=te(i.subarray(0,32));if(!n.isValidNot0(l))return!1;const d=te(i.subarray(32,64));if(!s.isValidNot0(d))return!1;const m=vr(s.toBytes(l),Qe(u),a),g=o.multiplyUnsafe(d).add(u.multiplyUnsafe(s.neg(m))),{x:w,y:_}=g.toAffine();return!(g.is0()||!Ve(_)||w!==l)}catch{return!1}}const ke=(()=>{const e=(n=qt(48))=>or(n,we.n);return{keygen:fr(e,kr),getPublicKey:kr,sign:yo,verify:Er,Point:Rt,utils:{randomSecretKey:e,taggedHash:ve,lift_x:br,pointToBytes:Qe},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),wo=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),xr=Uint8Array.from(new Array(16).fill(0).map((r,t)=>t)),bo=xr.map(r=>(9*r+5)%16),_r=(()=>{const e=[[xr],[bo]];for(let n=0;n<4;n++)for(let s of e)s.push(s[n].map(o=>wo[o]));return e})(),Ir=_r[0],Ar=_r[1],Sr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(r=>Uint8Array.from(r)),vo=Ir.map((r,t)=>r.map(e=>Sr[t][e])),ko=Ar.map((r,t)=>r.map(e=>Sr[t][e])),Eo=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),xo=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Br(r,t,e,n){return r===0?t^e^n:r===1?t&e|~t&n:r===2?(t|~e)^n:r===3?t&n|e&~n:t^(e|~n)}const Ee=new Uint32Array(16);class _o extends qe{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){const{h0:t,h1:e,h2:n,h3:s,h4:o}=this;return[t,e,n,s,o]}set(t,e,n,s,o){this.h0=t|0,this.h1=e|0,this.h2=n|0,this.h3=s|0,this.h4=o|0}process(t,e){for(let g=0;g<16;g++,e+=4)Ee[g]=t.getUint32(e,!0);let n=this.h0|0,s=n,o=this.h1|0,i=o,a=this.h2|0,c=a,u=this.h3|0,l=u,d=this.h4|0,m=d;for(let g=0;g<5;g++){const w=4-g,_=Eo[g],b=xo[g],O=Ir[g],$=Ar[g],U=vo[g],R=ko[g];for(let j=0;j<16;j++){const Y=ce(n+Br(g,o,a,u)+Ee[O[j]]+_,U[j])+d|0;n=d,d=u,u=ce(a,10)|0,a=o,o=Y}for(let j=0;j<16;j++){const Y=ce(s+Br(w,i,c,l)+Ee[$[j]]+b,R[j])+m|0;s=m,m=l,l=ce(c,10)|0,c=i,i=Y}}this.set(this.h1+a+l|0,this.h2+u+m|0,this.h3+d+s|0,this.h4+n+i|0,this.h0+o+c|0)}roundClean(){xt(Ee)}destroy(){this.destroyed=!0,xt(this.buffer),this.set(0,0,0,0,0)}}const Io=Oe(()=>new _o);const ee=Z.Point,{Fn:ne}=ee,Ge=Es(nt),Ao=Uint8Array.from("Bitcoin seed".split(""),r=>r.charCodeAt(0)),Ye={private:76066276,public:76067358},Je=2147483648,So=r=>Io(nt(r)),Bo=r=>$t(r).getUint32(0,!1),xe=r=>{if(!Number.isSafeInteger(r)||r<0||r>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+r);const t=new Uint8Array(4);return $t(t).setUint32(0,r,!1),t};class Dt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Bo(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return Ge.encode(this.serialize(this.versions.private,ot(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Ge.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,e=Ye){if(Q(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=Xt(Kn,Ao,t),s=n.slice(0,32),o=n.slice(32);return new Dt({versions:e,chainCode:o,privateKey:s})}static fromExtendedKey(t,e=Ye){const n=Ge.decode(t),s=$t(n),o=s.getUint32(0,!1),i={versions:e,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(o!==e[c?"private":"public"])throw new Error("Version mismatch");return c?new Dt({...i,privateKey:a.slice(1)}):new Dt({...i,publicKey:a})}static fromJSON(t){return Dt.fromExtendedKey(t.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(t){if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||Ye,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!Z.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=Z.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=ee.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=So(this._publicKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of e){const o=/^(\d+)('?)$/.exec(s),i=o&&o[1];if(!o||o.length!==3||typeof i!="string")throw new Error("invalid child index: "+s);let a=+i;if(!Number.isSafeInteger(a)||a>=Je)throw new Error("Invalid index");o[2]==="'"&&(a+=Je),n=n.deriveChild(a)}return n}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=xe(t);if(t>=Je){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");e=ot(Uint8Array.of(0),c,e)}else e=ot(this._publicKey,e);const n=Xt(Kn,this.chainCode,e),s=n.slice(0,32),o=n.slice(32);if(!Z.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},a=ne.fromBytes(s);try{if(this._privateKey){const c=ne.create(ne.fromBytes(this._privateKey)+a);if(!ne.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=ne.toBytes(c)}else{const c=ee.fromBytes(this._publicKey).add(ee.BASE.multiply(a));if(c.equals(ee.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=c.toBytes(!0)}return new Dt(i)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return Q(t,32),Z.sign(t,this._privateKey,{prehash:!1})}verify(t,e){if(Q(t,32),Q(e,64),!this._publicKey)throw new Error("No publicKey set!");return Z.verify(e,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return Q(e,33),ot(xe(t),new Uint8Array([this.depth]),xe(this.parentFingerprint),xe(this.index),this.chainCode,e)}}class re extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,re.prototype)}}class Xe extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,Xe.prototype)}}class tn extends re{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,tn.prototype)}}const ht={error(){},warn(){},info(){},debug(){},trace(){},log(){}};function _e(r,t=ht,e){throw t.error(r,e),new Error(r)}function en(r,t,e=ht,n){r&&_e(t,e,n)}function Mr(r,t,e=ht,n){r==null&&_e(t,e,n)}function se(r,t,e=ht,n){if(r)try{const s=r(t);s&&typeof s.then=="function"&&s.catch(o=>{try{e.warn("callback failed",{...n??{},error:o,cb:r.name??""})}catch{}})}catch(s){try{e.warn("callback failed",{...n??{},error:s,cb:r.name??""})}catch{}}}const Cr={error:0,warn:1,info:2,debug:3,trace:4};class Mo{constructor(t="info"){this.minLevel=t}should(t){return Cr[t]<=Cr[this.minLevel]}method(t){switch(t){case"error":return console.error;case"warn":return console.warn;case"info":return console.info;case"debug":return console.debug;case"trace":return console.trace;default:return console.log}}header(t,e){return`[${t.toUpperCase()}] ${e}`}flattenContext(t){if(!t)return;const e={};for(const[n,s]of Object.entries(t))e[n]=s instanceof Error?{message:s.message,stack:s.stack}:s;return e}emit(t,e,n){if(!this.should(t))return;const s=this.header(t,e),o=this.flattenContext(n),i=this.method(t);o&&Object.keys(o).length?i(s,o):i(s)}error(t,e){this.emit("error",t,e)}warn(t,e){this.emit("warn",t,e)}info(t,e){this.emit("info",t,e)}debug(t,e){this.emit("debug",t,e)}trace(t,e){this.emit("trace",t,e)}log(t,e,n){this.emit(t,e,n)}}function Co(){const r=Date.now();return{elapsed:()=>Date.now()-r}}let To={},Tr=ht;function Po(r){Tr=r}async function Oo({endpoint:r,requestBody:t,headers:e,...n}){const s=t?JSON.stringify(t):void 0,o={Accept:"application/json, text/plain, */*",...s?{"Content-Type":"application/json"}:void 0,...e};let i;try{i=await fetch(r,{body:s,headers:o,...n})}catch(a){throw new Xe(a instanceof Error?a.message:"Network request failed")}if(!i.ok){let a;try{a=await i.json()}catch{a={error:"bad response"}}if(i.status===400&&"code"in a&&typeof a.code=="number"&&"detail"in a&&typeof a.detail=="string")throw new tn(a.code,a.detail);let c="HTTP request failed";throw"error"in a&&typeof a.error=="string"?c=a.error:"detail"in a&&typeof a.detail=="string"&&(c=a.detail),new re(c,i.status)}try{return await i.json()}catch(a){throw Tr.error("Failed to parse HTTP response",{err:a}),new re("bad response",i.status)}}async function qo(r){return await Oo({...r,...To})}let nn;typeof WebSocket<"u"&&(nn=WebSocket);function No(){if(nn===void 0)throw new Error("WebSocket implementation not initialized");return nn}class W{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const e=t.match(/.{1,2}/g);if(!e)throw new Error("Invalid hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((o,i)=>o+i.length,0),n=new Uint8Array(e);let s=0;for(const o of t)n.set(o,s),s+=o.length;return n}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Buffer<"u")return Buffer.from(t).toString("base64");if(t.length>32768){let e="";for(let n=0;n<t.length;n+=32768){const s=t.slice(n,n+32768);e+=btoa(String.fromCharCode(...s))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){t=t.trim();let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return typeof Buffer<"u"?new Uint8Array(Buffer.from(e,"base64")):new Uint8Array([...atob(e)].map(n=>n.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let n=0;for(let s=0;s<t.length;s++)n|=t[s]^e[s];return n===0}static compare(t,e){const n=Math.min(t.length,e.length);for(let s=0;s<n;s++){if(t[s]<e[s])return-1;if(t[s]>e[s])return 1}return t.length-e.length}static toBigInt(t){let e=0n;for(const n of t)e=e<<8n|BigInt(n);return e}static fromBigInt(t){if(t<0n)throw new RangeError("value must be non-negative");if(t===0n)return new Uint8Array([0]);let e=t,n=0;for(;e>0n;)n++,e>>=8n;const s=new Uint8Array(n);e=t;for(let o=n-1;o>=0;o--)s[o]=Number(e&0xffn),e>>=8n;return s}}function rn(r){return W.toBase64(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function Pr(r){return W.fromBase64(r)}function Uo(r){const t=W.toString(W.fromBase64(Ro(r)));return JSON.parse(t)}function Ro(r){return r.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function sn(r){if(typeof r!="string"||r.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(r)&&!e.test(r))return!1;const n=r.replace(/-/g,"+").replace(/_/g,"/"),s=(4-n.length%4)%4;if(s>2)return!1;const o=n+"=".repeat(s);try{const i=W.fromBase64(o),a=W.toBase64(i),c=a.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),u=n.replace(/=+$/,"");return a.replace(/=+$/,"")===u||c===u}catch{return!1}}function Do(r){return typeof r=="number"||typeof r=="string"}function Lo(r){const t=[];return on(r,t),new Uint8Array(t)}function on(r,t){if(r===null)t.push(246);else if(r===void 0)t.push(247);else if(typeof r=="boolean")t.push(r?245:244);else if(typeof r=="number")Ho(r,t);else if(typeof r=="string")Or(r,t);else if(Array.isArray(r))Wo(r,t);else if(r instanceof Uint8Array)jo(r,t);else if(typeof r=="object"&&r!==null&&!Array.isArray(r))zo(r,t);else throw new Error("Unsupported type")}function Fo(r,t){if(r<24)t.push(r);else if(r<256)t.push(24,r);else if(r<65536)t.push(25,r>>>8&255,r&255);else if(r<4294967296)t.push(26,r>>>24&255,r>>>16&255,r>>>8&255,r&255);else throw new Error("Unsupported integer size")}function Ko(r,t){const e=-1-r;if(e<24)t.push(32|e);else if(e<256)t.push(56,e&255);else if(e<65536)t.push(57,e>>>8&255,e&255);else if(e<4294967296)t.push(58,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Unsupported integer size")}function $o(r,t){const e=new ArrayBuffer(8),n=new DataView(e);n.setFloat64(0,r,!1),t.push(251);for(let s=0;s<8;s++)t.push(n.getUint8(s))}function Ho(r,t){Number.isInteger(r)?r>=0?Fo(r,t):Ko(r,t):$o(r,t)}function jo(r,t){const e=r.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<r.length;n++)t.push(r[n])}function Or(r,t){const e=new TextEncoder().encode(r),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>>8&255,n&255);else if(n<4294967296)t.push(122,n>>>24&255,n>>>16&255,n>>>8&255,n&255);else throw new Error("String too long to encode");for(let s=0;s<e.length;s++)t.push(e[s])}function Wo(r,t){const e=r.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>>8&255,e&255);else throw new Error("Unsupported array length");for(const n of r)on(n,t)}function zo(r,t){const e=Object.keys(r),n=e.length;if(n>=4294967296)throw new Error("Object has too many keys to encode");n<24?t.push(160|n):n<256?t.push(184,n):n<65536?t.push(185,n>>8&255,n&255):t.push(186,n>>24&255,n>>16&255,n>>8&255,n&255);for(const s of e)Or(s,t),on(r[s],t)}function Qo(r){const t=new DataView(r.buffer,r.byteOffset,r.byteLength);return Ie(t,0).value}function Ie(r,t){if(t>=r.byteLength)throw new Error("Unexpected end of data");const e=r.getUint8(t++),n=e>>5,s=e&31;switch(n){case 0:return Vo(r,t,s);case 1:return Zo(r,t,s);case 2:return Go(r,t,s);case 3:return Yo(r,t,s);case 4:return Jo(r,t,s);case 5:return Xo(r,t,s);case 7:return ei(r,t,s);default:throw new Error(`Unsupported major type: ${n}`)}}function Mt(r,t,e){if(t+e>r.byteLength)throw new Error("Unexpected end of data")}function Qt(r,t,e){if(e<24)return{value:e,offset:t};if(e===24)return Mt(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){Mt(r,t,2);const n=r.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){Mt(r,t,4);const n=r.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Mt(r,t,8);const n=r.getUint32(t,!1),s=r.getUint32(t+4,!1);return t+=8,{value:n*2**32+s,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Vo(r,t,e){const{value:n,offset:s}=Qt(r,t,e);return{value:n,offset:s}}function Zo(r,t,e){const{value:n,offset:s}=Qt(r,t,e);return{value:-1-n,offset:s}}function Go(r,t,e){const{value:n,offset:s}=Qt(r,t,e);if(s+n>r.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(r.buffer,r.byteOffset+s,n),offset:s+n}}function Yo(r,t,e){const{value:n,offset:s}=Qt(r,t,e);if(s+n>r.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(r.buffer,r.byteOffset+s,n);return{value:new TextDecoder().decode(o),offset:s+n}}function Jo(r,t,e){const{value:n,offset:s}=Qt(r,t,e),o=[];let i=s;for(let a=0;a<n;a++){const c=Ie(r,i);o.push(c.value),i=c.offset}return{value:o,offset:i}}function Xo(r,t,e){const{value:n,offset:s}=Qt(r,t,e),o={};let i=s;for(let a=0;a<n;a++){const c=Ie(r,i);if(!Do(c.value))throw new Error("Invalid key type");const u=Ie(r,c.offset);o[c.value]=u.value,i=u.offset}return{value:o,offset:i}}function ti(r){const t=(r&31744)>>10,e=r&1023,n=r&32768?-1:1;return t===0?n*2**-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function ei(r,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return Mt(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){Mt(r,t,2);const n=ti(r.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){Mt(r,t,4);const n=r.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Mt(r,t,8);const n=r.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}const ni=Nn("Secp256k1_HashToCurve_Cashu_");function Ae(r){const t=nt(W.concat(ni,r)),e=new Uint32Array(1),n=2**16;for(let s=0;s<n;s++){const o=new Uint8Array(e.buffer),i=nt(W.concat(t,o));try{return Vt(tt(W.concat(new Uint8Array([2]),i)))}catch{e[0]++}}throw new Error("No valid point found")}function ri(r){const t=r.map(e=>e.toHex(!1)).join("");return nt(new TextEncoder().encode(t))}function Vt(r){return Z.Point.fromHex(r)}const si=r=>{let t;return/^[a-fA-F0-9]+$/.test(r)?t=Se(r)%BigInt(2**31-1):t=W.toBigInt(Pr(r))%BigInt(2**31-1),t};function oi(){return Z.utils.randomSecretKey()}function an(r,t){const e=Ae(r);t||(t=Z.Point.Fn.fromBytes(oi()));const n=Z.Point.BASE.multiply(t);return{B_:e.add(n),r:t,secret:r}}function ii(r,t,e){return r.subtract(e.multiply(t))}function ai(r,t,e,n){const s=n,o=ii(r.C_,t,s);return{id:r.id,amount:r.amount,secret:e,C:o}}const ci=r=>({amount:r.amount,C:r.C.toHex(!0),id:r.id,secret:new TextDecoder().decode(r.secret),witness:JSON.stringify(r.witness)}),ui=(r,t)=>{const e=nt(new TextEncoder().encode(r)),n=typeof t=="string"?G(t):t,s=ke.sign(e,n);return tt(s)},li=(r,t,e,n=!1)=>{try{const s=nt(new TextEncoder().encode(t)),o=e.length===66?e.slice(2):e;return ke.verify(G(r),s,G(o))}catch(s){if(n)throw s}return!1};function cn(r){let t;try{typeof r=="string"?t=JSON.parse(r):t=r}catch{throw new Error("Can't parse secret")}if(!Array.isArray(t)||t.length!==2||typeof t[0]!="string"||typeof t[1]!="object"||t[0].trim().length===0||t[1]===null)throw new Error("Invalid NUT-10 secret");const[e,n]=t;if(typeof n.nonce!="string"||typeof n.data!="string")throw new Error("Invalid NUT-10 secret nonce / data");if(n.tags){if(!Array.isArray(n.tags))throw new Error("Invalid NUT-10 secret tags");if(n.tags.some(s=>!Array.isArray(s)||s.length===0||s.some(o=>typeof o!="string"||!o.length)))throw new Error("Invalid NUT-10 tag(s)")}return[e,{nonce:n.nonce,data:n.data,tags:n.tags}]}function hi(r,t){const e=Array.isArray(r)?r:[r],n=cn(t),s=n[0];if(!e.includes(s))throw new Error(`Invalid secret kind: ${s} Allowed: ${e.join(", ")}`);return n}function fi(r){return cn(r)[0]}function qr(r){return cn(r)[1]}function di(r){const{data:t}=qr(r);return t}function pi(r){const{tags:t}=qr(r);return t??[]}function un(r,t){const e=pi(r).find(n=>n[0]===t);if(!(!e||e.length<=1))return e.slice(1)}function Nr(r,t){const e=un(r,t);return e&&e.length>0?e[0]:void 0}function gi(r,t){const e=Nr(r,t);if(e===void 0)return;const n=Number.parseInt(e,10);return Number.isFinite(n)?n:void 0}const Ur=Nn("Cashu_P2BK_v1");function mi(r,t,e){if(!r.length)return{blinded:[],Ehex:""};e=e??Z.utils.randomSecretKey();const n=Z.Point.Fn.fromBytes(e),s=Z.getPublicKey(e,!0),o=G(t);return{blinded:r.map((i,a)=>{const c=Vt(i),u=Rr(c,n,o,a),l=c.add(Z.Point.BASE.multiply(u));if(l.equals(Z.Point.ZERO))throw new Error("Blinded key at infinity");return l.toHex(!0)}),Ehex:tt(s)}}function yi(r,t,e,n){const s=Array.isArray(t)?t:[t],o=Array.isArray(e)?e:[e],i=new Set,a=Z.Point.fromHex(r),c=G(n);for(const u of s){const l=Z.Point.Fn.fromBytes(G(u)),d=Z.getPublicKey(G(u),!0);o.forEach((m,g)=>{const w=Rr(a,l,c,g),_=G(m),b=wi(u,w,_,d);b&&i.add(b)})}return Array.from(i)}function wi(r,t,e,n){const s=Z.Point.CURVE().n,o=typeof r=="string"?Se(r):r,i=typeof t=="string"?Se(t):t;if(o<=0n||o>=s)throw new Error("Invalid private key");if(i<=0n||i>=s)throw new Error("Invalid scalar r");if(n=n??Z.Point.BASE.multiply(o).toBytes(!0),n.length!==33)throw new Error("naturalPub must be 33 bytes");const a=(o+i)%s,c=(s-o+i)%s;if(!e){if(a===0n)throw new Error("Derived secret key is zero");return hn(a)}if(e.length!==33)throw new Error("blindPubkey must be 33 bytes");const u=Z.Point.fromHex(tt(e)),l=Z.Point.BASE.multiply(i),d=u.subtract(l);if(d.equals(Z.Point.ZERO))return null;const m=d.toBytes(!0).slice(1),g=n.slice(1);if(!W.equals(m,g))return null;const w=d.toBytes(!0)[0]&1,_=n[0]&1,b=w===_?a:c;if(b===0n)throw new Error("Derived secret key is zero");return hn(b)}function Rr(r,t,e,n){const s=r.multiply(t).toBytes(!0).slice(1),o=new Uint8Array([n&255]);let i=W.toBigInt(nt(W.concat(Ur,s,e,o)));if((i===0n||i>=Z.Point.CURVE().n)&&(i=W.toBigInt(nt(W.concat(Ur,s,e,o,new Uint8Array([255])))),i===0n||i>=Z.Point.CURVE().n))throw new Error("P2BK: tweak derivation failed");return i}function mt(r){return r instanceof Uint8Array&&(r=new TextDecoder().decode(r)),hi(["P2PK","HTLC"],r)}function bi(r){try{const t=mt(r),e=ki(t),n=Dr(t),s=Lr(t);if(e==="ACTIVE"||e==="PERMANENT")return n;if(e==="EXPIRED"&&s.length){const o=[...n,...s];return Array.from(new Set(o))}}catch{}return[]}function Dr(r){const t=mt(r);let e="";fi(t)==="P2PK"&&(e=di(t));const n=un(t,"pubkeys")??[],s=[e,...n].filter(Boolean);return Array.from(new Set(s))}function Lr(r){const t=mt(r);return un(t,"refund")??[]}function vi(r){const t=mt(r),e=gi(t,"locktime");return e===void 0||!Number.isFinite(e)||e<=0?1/0:e}function ki(r,t=Math.floor(Date.now()/1e3)){const e=mt(r),n=vi(e);return Number.isFinite(n)?t<n?"ACTIVE":"EXPIRED":"PERMANENT"}function ln(r){const t=mt(r);return Nr(t,"sigflag")==="SIG_ALL"?"SIG_ALL":"SIG_INPUTS"}function Ei(r){return Fr(r)?.signatures??[]}function Fr(r){if(!r)return;let t;try{t=typeof r=="string"?JSON.parse(r):r}catch(n){console.error("Failed to parse witness string:",n);return}const e={signatures:t.signatures??[]};return typeof t.preimage=="string"&&t.preimage.length>0&&(e.preimage=t.preimage),e}function Kr(r,t,e=ht,n){const s=i=>typeof i=="string"?i:tt(i),o=Array.isArray(t)?t.map(s):s(t);return r.map((i,a)=>{const c=_i(o,i);let u=i;for(const l of c)try{u=xi(u,l,n)}catch(d){const m=d instanceof Error?d.message:"Unknown error";e.warn(`Proof #${a+1}: ${m}`)}return u})}function xi(r,t,e){const n=mt(r.secret);e=e??r.secret;const s=typeof t=="string"?G(t):t,o=tt(ke.getPublicKey(s)),i=bi(n);if(!i.length||!i.some(l=>l.includes(o)))throw new Error(`Signature not required from [02|03]${o}`);if(Ei(r.witness).some(l=>li(l,e,o)))throw new Error(`Proof already signed by [02|03]${o}`);const a=ui(e,t),c=Fr(r.witness),u={...c&&c.preimage!==void 0?{preimage:c.preimage}:{},signatures:[...c?.signatures??[],a]};return{...r,witness:u}}function _i(r,t){const e=Array.isArray(r)?r:[r],n=t?.p2pk_e;if(!n)return Array.from(new Set(e));const s=mt(t.secret),o=[...Dr(s),...Lr(s)],i=t.id;return yi(n,e,o,i)}function Ii(r){if(r.length===0)throw new Error("No proofs");const t=mt(r[0].secret);if(ln(t)!=="SIG_ALL")throw new Error("First proof is not SIG_ALL");const e=t[1].data,n=JSON.stringify(t[1].tags??[]);for(let s=1;s<r.length;s++){const o=mt(r[s].secret);if(o[0]!==t[0])throw new Error(`Proof #${s+1} is not ${t[0]}`);if(ln(o)!=="SIG_ALL")throw new Error(`Proof #${s+1} is not SIG_ALL`);if(o[1].data!==e)throw new Error("SIG_ALL inputs must share identical Secret.data");if(JSON.stringify(o[1].tags??[])!==n)throw new Error("SIG_ALL inputs must share identical Secret.tags")}}function Ai(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.B_);return e&&n.push(e),n.join("")}function $r(r){return r.some(t=>{try{return ln(t.secret)==="SIG_ALL"}catch{return!1}})}function Si(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.id,s.blindedMessage.B_);return e&&n.push(e),n.join("")}function Bi(r,t,e){const n=[];for(const s of r)n.push(s.secret);for(const s of t)n.push(s.blindedMessage.B_);return e&&n.push(e),n.join("")}function Mi(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}const Ci=(r,t,e,n)=>{const s=Z.Point.Fn.fromBytes(r.s),o=Z.Point.Fn.fromBytes(r.e),i=Z.Point.BASE.multiply(s),a=n.multiply(o),c=t.multiply(s),u=e.multiply(o),l=i.subtract(a),d=c.subtract(u),m=ri([l,d,n,e]);return Mi(m,r.e)},Ti=(r,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const s=Ae(r),o=e.add(n.multiply(t.r)),i=Z.Point.BASE.multiply(t.r),a=s.add(i);return Ci(t,a,o,n)},Pi="m/129372'/0'",Hr=BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),Oi=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&sn(t)||n&&t.startsWith("00"))return Wr(r,t,e,0);if(n&&t.startsWith("01"))return jr(r,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},qi=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&sn(t)||n&&t.startsWith("00"))return Wr(r,t,e,1);if(n&&t.startsWith("01"))return jr(r,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},jr=(r,t,e,n)=>{let s=W.concat(W.fromString("Cashu_KDF_HMAC_SHA256"),W.fromHex(t),W.writeBigUint64BE(BigInt(e)));switch(n){case 0:s=W.concat(s,W.fromHex("00"));break;case 1:s=W.concat(s,W.fromHex("01"))}const o=Xt(nt,r,s);if(n===1){const i=W.toBigInt(o);if(i>=Hr)return W.fromBigInt(i-Hr);if(i===0n)throw new Error("Derived invalid blinding scalar r == 0");return o}return o},Wr=(r,t,e,n)=>{const s=Dt.fromMasterSeed(r),o=si(t),i=`${Pi}/${o}'/${e}'/${n}`,a=s.derive(i);if(a.privateKey===null)throw new Error("Could not derive private key");return a.privateKey};function Ni(r,t){let e=r;for(const s of t)e+=s.B_;const n=new TextEncoder().encode(e);return nt(n)}function Ui(r,t,e){const n=Ni(t,e),s=G(r),o=ke.sign(n,s);return tt(o)}function Ct(r,t,e,n){if(e){const o=Yr(e);if(r===0&&o===0)return e;const i=e.filter(c=>c>0),a=Yr(i);if(a>r)throw new Error(`Split is greater than total amount: ${a} > ${r}`);if(i.some(c=>!Qr(c,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(a===r)return i;e=i,r-=a}else e=[];const s=zr(t,"desc");if(!s||s.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");for(const o of s){if(o<=0)continue;const i=Math.floor(r/o);if(e.push(...Array(i).fill(o)),r-=o*i,r===0)break}if(r!==0)throw new Error(`Unable to split remaining amount: ${r}`);return n?e.sort((o,i)=>o-i):e}function Ri(r,t,e,n){const s=[],o=r.map(a=>a.amount);zr(e,"asc").forEach(a=>{const c=o.filter(l=>l===a).length,u=Math.max(n-c,0);for(let l=0;l<u&&!(s.reduce((d,m)=>d+m,0)+a>t);++l)s.push(a)});const i=t-s.reduce((a,c)=>a+c,0);return i&&Ct(i,e).forEach(a=>{s.push(a)}),s.sort((a,c)=>a-c)}function zr(r,t="desc"){return t=="desc"?Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>e-n)}function Qr(r,t){return r in t}function Se(r){return BigInt(`0x${r}`)}function hn(r){return r.toString(16).padStart(64,"0")}function Zt(r){return/^[a-f0-9]*$/i.test(r)}function Di(r){return Array.isArray(r)?r.some(t=>!Zt(t.id)):!Zt(r.id)}function Li(r){return r.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function Vr(r,t){if(r.proofs.forEach(a=>{if(a.dleq&&a.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Di(r.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");r.proofs=Li(r.proofs);const e=Fi(r),n=Lo(e),s="cashu",o="B",i=rn(n);return s+o+i}function Fi(r){const t={},e=r.mint;for(let s=0;s<r.proofs.length;s++){const o=r.proofs[s];t[o.id]?t[o.id].push(o):t[o.id]=[o]}const n={m:e,u:r.unit||"sat",t:Object.keys(t).map(s=>({i:G(s),p:t[s].map(o=>({a:o.amount,s:o.secret,c:G(o.C),...o.dleq&&{d:{e:G(o.dleq.e),s:G(o.dleq.s),r:G(o.dleq.r??"00")}},...o.p2pk_e&&{pe:G(o.p2pk_e)},...o.witness&&{w:JSON.stringify(o.witness)}}))}))};return r.memo&&(n.d=r.memo),n}function fn(r,t=!1){if(typeof r!="number"||!Number.isFinite(r)||!Number.isInteger(r))throw new Error(`Invalid amount: ${String(r)}`);if(!Number.isSafeInteger(r))throw new Error(`Amount must be a safe integer: ${r}`);if(t?r<0:r<=0)throw new Error(`Amount must be ${t?"non-negative":"positive"}: ${r}`)}function Ki(r){const t=[];r.t.forEach(n=>n.p.forEach(s=>{fn(s.a,!0),t.push({secret:s.s,C:tt(s.c),amount:s.a,id:tt(n.i),...s.d&&{dleq:{r:tt(s.d.r),s:tt(s.d.s),e:tt(s.d.e)}},...s.pe&&{p2pk_e:tt(s.pe)},...s.w&&{witness:s.w}})}));const e={mint:r.m,proofs:t,unit:r.u||"sat"};return r.d&&(e.memo=r.d),e}function $i(r,t){const e=(t??[]).map(o=>typeof o=="string"?o:o.id),n=Jr(r),s=Zr(n);return s.proofs=Qi(s.proofs,e),s}function Hi(r){r=Jr(r);const t=Zr(r);return{unit:t.unit||"sat",mint:t.mint,amount:Tt(t.proofs),...t.memo&&{memo:t.memo},incompleteProofs:t.proofs.map(e=>({secret:e.secret,C:e.C,amount:e.amount,...e.dleq&&{dleq:e.dleq},...e.witness&&{witness:e.witness}}))}}function Zr(r){const t=r.slice(0,1),e=r.slice(1);if(t==="A"){const n=Uo(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const s=n.token[0];for(const i of s.proofs)fn(i.amount,!0);const o={mint:s.mint,proofs:s.proofs,unit:n.unit||"sat"};return n.memo&&(o.memo=n.memo),o}else if(t==="B"){const n=Pr(e),s=Qo(n);return Ki(s)}throw new Error("Token version is not supported")}function ji(r,t,e,n=0,s=!1){if(s){const c=Object.entries(r).sort((l,d)=>+l[0]-+d[0]).map(([,l])=>l).reduce((l,d)=>l+d,""),u=nt(W.fromString(c));return W.toBase64(u).slice(0,12)}let o=Object.entries(r).sort((c,u)=>+c[0]-+u[0]).map(([,c])=>G(c)).reduce((c,u)=>dn(c,u),new Uint8Array),i,a;switch(n){case 0:return i=nt(o),a=W.toHex(i).slice(0,14),"00"+a;case 1:if(!t)throw new Error("Cannot compute keyset ID version 01: unit is required.");return o=dn(o,W.fromString("unit:"+t)),e&&(o=dn(o,W.fromString("final_expiry:"+e.toString()))),i=nt(o),a=W.toHex(i),"01"+a;default:throw new Error(`Unrecognized keyset ID version: ${n}`)}}function dn(r,t){const e=new Uint8Array(r.length+t.length);return e.set(r),e.set(t,r.length),e}function yt(r){return typeof r=="object"}function Gt(...r){return r.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function Gr(r){return r.replace(/\/$/,"")}function Tt(r){return r.reduce((t,e)=>t+e.amount,0)}class Wi{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class zi{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new Wi(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function Qi(r,t){const e=(t??[]).map(s=>typeof s=="string"?s:s.id),n=[];for(const s of r){let o;try{o=G(s.id)}catch{n.push(s);continue}if(o[0]===0)n.push(s);else if(o[0]===1){if(!e)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let i=!1;for(const a of e)if(s.id===a.slice(0,s.id.length)){s.id=a,n.push(s),i=!0;break}if(!i)throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${o[0]}`)}return n}function Vi(r,t){if(r.dleq==null)return!1;const e={e:G(r.dleq.e),s:G(r.dleq.s),r:Se(r.dleq.r??"00")};if(!Qr(r.amount,t.keys))throw new Error(`Undefined key for amount ${r.amount} in keyset ${t.id}`);const n=t.keys[r.amount];return Ti(new TextEncoder().encode(r.secret),e,Vt(r.C),Vt(n))}function Yr(r){return r.reduce((t,e)=>t+e,0)}function Jr(r){return["web+cashu://","cashu://","cashu:","cashu"].forEach(t=>{r.startsWith(t)&&(r=r.slice(t.length))}),r}function Zi(r){return/^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(r)}class Yt{constructor(){this.connectionMap=new Map}static getInstance(){return Yt.instance||(Yt.instance=new Yt),Yt.instance}getConnection(t,e){const n=this.connectionMap.get(t);if(n)return e&&n.setLogger(e),n;const s=new Gi(t,e);return this.connectionMap.set(t,s),s}}class Gi{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=No(),this.url=new URL(t),this.messageQueue=new zi,this._logger=e??ht}setLogger(t){this._logger=t}connect(t=1e4){return this.connectionPromise?this.connectionPromise:(this.connectionPromise=new Promise((e,n)=>{let s=!1,o=!1,i=null;const a=l=>{o||(o=!0,i&&clearTimeout(i),l())},c=()=>{if(this.ws){try{this.ws.onopen=null,this.ws.onerror=null,this.ws.onmessage=null,this.ws.onclose=null}catch{}try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling()}},u=l=>{this.connectionPromise=void 0,c();const d=l instanceof Error?l:new Error(String(l));this.failPendingRpc(d),a(()=>n(d))};try{this.ws=new this._WS(this.url.toString())}catch(l){u(l);return}i=setTimeout(()=>{u(new Error(`WebSocket connect timeout after ${t}ms`))},t),this.ws.onopen=()=>{s=!0,a(e)},this.ws.onerror=l=>{if(!s){u(new Error("Failed to open WebSocket"));return}this._logger.error("WebSocket error after open",{ev:l})},this.ws.onmessage=l=>{this.messageQueue.enqueue(l.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=l=>{if(this.connectionPromise=void 0,!s){const g=l?.reason?`, ${l.reason}`:"";u(new Error(`WebSocket closed before open (code ${l?.code??0}${g})`));return}this.stopMessageHandling();const d=l?.reason?`, ${l.reason}`:"",m=l?.code??0;!(typeof l.wasClean!="boolean"||l.wasClean)||m!==1e3&&m!==1001?this.failPendingRpc(new Error(`WebSocket closed (code ${m}${d})`)):this.rpcListeners={},this.onCloseCallbacks.forEach(g=>g(l))}}),this.connectionPromise)}sendRequest(t,e){if(this.ws?.readyState!==this._WS.OPEN){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const n=this.rpcId;this.rpcId++,this.sendRpcMessage(t,e,n)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}stopMessageHandling(){for(this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);this.messageQueue.size>0;)this.messageQueue.dequeue()}failPendingRpc(t){const e=this.rpcListeners;this.rpcListeners={};for(const n of Object.keys(e))try{e[n].errorCallback(t)}catch{}}sendRpcMessage(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw new Error("Socket not open");const s=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});try{this.ws.send(s)}catch(o){this._logger.error("WebSocket send failed",{e:o}),this.connectionPromise=void 0;try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling();const i=o instanceof Error?o:new Error(String(o));throw this.failPendingRpc(i),i}}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(t){this.ws?.readyState!==this._WS.OPEN&&await this.connect(t)}handleNextMessage(){if(this.messageQueue.size===0){this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);return}const t=this.messageQueue.dequeue();try{const e=JSON.parse(t);if("result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params?.subId;if(!n)return;if(this.subListeners[n]?.length>0){const s=e;this.subListeners[n].forEach(o=>{try{o(s.params?.payload)}catch(i){this._logger.error("Subscription handler threw",{e:i})}})}}}catch(e){this._logger.error("Error doing handleNextMessage",{e})}}createSubscription(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const s=(Math.random()+1).toString(36).substring(7),o=this.rpcId;this.addRpcListener(()=>{this.addSubListener(s,e)},n,o);try{this.sendRequest("subscribe",{...t,subId:s})}catch(i){throw this.removeRpcListener(o),i}return s}cancelSubscription(t,e,n){if(this.removeListener(t,e),this.ws?.readyState!==this._WS.OPEN){this._logger.info("Socket not open, removed listener locally {subId}",{subId:t});return}const s=this.rpcId;this.rpcId++,this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},n||(o=>this._logger.error("Unsubscribe failed",{e:o})),s);try{this.sendRpcMessage("unsubscribe",{subId:t},s)}catch(o){throw this.removeRpcListener(s),o}}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){if(this.ws){try{this.ws.close()}catch{}this.ws=void 0}this.connectionPromise=void 0,this.stopMessageHandling()}onClose(t){this.onCloseCallbacks.push(t)}}const pn={UNPAID:"UNPAID",PAID:"PAID"},oe={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},gn={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"};function mn(r,t){return r.state||(t.warn("Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof r.paid=="boolean"&&(r.state=r.paid?oe.PAID:oe.UNPAID)),r}function Xr(r,t){return r.state||(t.warn("Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof r.paid=="boolean"&&(r.state=r.paid?pn.PAID:pn.UNPAID)),r}function Yi(r,t){return Array.isArray(r?.contact)&&r?.contact.length>0&&(r.contact=r.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),r}class yn{constructor(t){this._mintInfo=t;const e=this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);this._protected22=this.buildIndex(e);const n=this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);this._protected21=this.buildIndex(n)}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t,e){return this.matchesProtected(this._protected22,t,e)}requiresClearAuthToken(t,e){return this.matchesProtected(this._protected21,t,e)}matchesProtected(t,e,n){if(!t)return!1;const s=`${e} ${n}`,o=t.cache[s];if(typeof o=="boolean")return o;const i=t.exact.some(u=>u.method===e&&u.path===n),a=i?!1:t.prefix.some(u=>u.method===e&&n.startsWith(u.path)),c=i||a;return t.cache[s]=c,c}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e?.methods??[]}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}toEndpoints(t){if(!Array.isArray(t))return[];const e=[];for(const n of t)if(n&&typeof n=="object"){const s=n,o=s.method,i=s.path;if(typeof o=="string"&&typeof i=="string"){const a=o.toUpperCase();(a==="GET"||a==="POST")&&e.push({method:a,path:i})}}return e}buildIndex(t){if(!t||t.length===0)return;const e=[],n=[];for(const s of t){let o=s.path;o.startsWith("^")&&(o=o.slice(1)),o.endsWith("$")&&(o=o.slice(0,-1)),o.endsWith(".*")?n.push({method:s.method,path:o.slice(0,-2)}):e.push({method:s.method,path:o})}return{cache:{},exact:e,prefix:n}}get cache(){return this._mintInfo}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this.supportsNut04Description("bolt12")}supportsNut04Description(t,e){return this._mintInfo.nuts[4]?.methods.some(n=>n.method===t&&(e?n.unit===e:!0)&&(n.options?.description===!0||n.description===!0))}supportsAmountless(t="bolt11",e="sat"){const n=this._mintInfo?.nuts?.[5]?.methods??[];return Array.isArray(n)?n.some(s=>s.method===t&&s.unit===e&&s.options?.amountless===!0):!1}}class wn{constructor(t,e){this.tokenListeners=[],this.discoveryUrl=t,this.logger=e?.logger??ht,this.clientId=e?.clientId??"cashu-client",this.scope=e?.scope??"openid",this.onTokens=e?.onTokens}static fromMintInfo(t,e){const n=t?.nuts?.["21"];if(!n?.openid_discovery)throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");const s=e?.clientId??n.client_id??"cashu-client";return new wn(n.openid_discovery,{...e,clientId:s})}setClient(t){this.clientId=t}setScope(t){this.scope=t??"openid"}addTokenListener(t){this.tokenListeners.push(t)}async loadConfig(){if(this.config)return this.config;const t=await fetch(this.discoveryUrl,{method:"GET",headers:{Accept:"application/json"}}),e=await t.text();let n;try{n=e?JSON.parse(e):void 0}catch(o){this.logger.warn("OIDCAuth: bad discovery JSON",{err:o})}if(!t.ok||!n)throw new Error("OIDCAuth: invalid discovery document");const s=n;if(typeof s.token_endpoint!="string"||s.token_endpoint.length===0)throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");return this.config=s,s}generatePKCE(){const t=qt(48),e=rn(t),n=W.fromString(e),s=nt(n),o=rn(s);return{verifier:e,challenge:o}}async buildAuthCodeUrl(t){const e=await this.loadConfig(),n=t.scope??this.scope,s=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:t.redirectUri,scope:n,code_challenge_method:t.codeChallengeMethod??"S256",code_challenge:t.codeChallenge});if(t.state&&s.set("state",t.state),!e.authorization_endpoint)throw new Error("OIDCAuth: discovery lacks authorization_endpoint");return`${e.authorization_endpoint}?${s.toString()}`}async exchangeAuthCode(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"authorization_code",code:t.code,redirect_uri:t.redirectUri,client_id:this.clientId,code_verifier:t.codeVerifier}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async deviceStart(){const t=(await this.loadConfig()).device_authorization_endpoint;if(!t)throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");const e=this.toForm({client_id:this.clientId,scope:this.scope});return this.postFormStrict(t,e)}async devicePoll(t,e=5){const n=await this.loadConfig();let s=Math.max(1,e);for(;;){await this.sleep(s*1e3);const o=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:t,client_id:this.clientId}),i=await this.postFormLoose(n.token_endpoint,o);if(i.access_token)return this.handleTokens(i),i;const a=(i.error??"").toString();if(a==="authorization_pending")continue;if(a==="slow_down"){s=Math.max(s+5,s*2);continue}const c=i.error_description||a||"device authorization failed";throw new Error(`OIDCAuth: ${c}`)}}async startDeviceAuth(t=5){const e=await this.deviceStart(),n=Math.max(e.interval??1,t);let s=!1;return{...e,poll:async()=>{const o=await this.loadConfig();let i=Math.max(1,n);for(;;){if(s)throw new Error("OIDCAuth: device polling cancelled");await this.sleep(i*1e3);const a=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:e.device_code,client_id:this.clientId}),c=await this.postFormLoose(o.token_endpoint,a);if(c.access_token)return this.handleTokens(c),c;const u=(c.error??"").toString();if(u==="authorization_pending")continue;if(u==="slow_down"){i=Math.max(i+5,i*2);continue}const l=c.error_description||u||"device authorization failed";throw new Error(`OIDCAuth: ${l}`)}},cancel:()=>{s=!0}}}async refresh(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"refresh_token",refresh_token:t,client_id:this.clientId}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async passwordGrant(t,e){const n=await this.loadConfig(),s=this.toForm({grant_type:"password",client_id:this.clientId,username:t,password:e,scope:this.scope}),o=await this.postFormStrict(n.token_endpoint,s);return this.handleTokens(o),o}handleTokens(t){if(!t.access_token){const e=t.error_description||t.error||"token response missing access_token";throw new Error(`OIDCAuth: ${e}`)}queueMicrotask(()=>se(this.onTokens,t,this.logger,{where:"OIDCAuth.handleTokens"}));for(const e of this.tokenListeners)queueMicrotask(()=>se(e,t,this.logger,{where:"OIDCAuth.handleTokens.listener"}))}toForm(t){const e=n=>encodeURIComponent(n).replace(/%20/g,"+");return Object.entries(t).map(([n,s])=>`${e(n)}=${e(s)}`).join("&")}async postFormStrict(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e}),s=await n.text();let o;try{o=s?JSON.parse(s):void 0}catch(i){this.logger.warn("OIDCAuth: bad JSON (strict)",{err:i})}if(!n.ok){const i=o??{},a=i.error_description||i.error||`HTTP ${n.status}`;throw new Error(`OIDCAuth: ${a}`)}return this.logger.debug("OIDCAuth Response",{json:o}),o??{}}catch(n){throw this.logger.error("OIDCAuth: postFormStrict failed",{err:n}),n}}async postFormLoose(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await(await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e})).text();let s;try{s=n?JSON.parse(n):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (loose)",{err:o})}return this.logger.debug("OIDCAuth Response",{json:s}),s??{}}catch(n){return this.logger.error("OIDCAuth: postFormLoose network error",{err:n}),{error:"network_error",error_description:String(n)}}}sleep(t){return new Promise(e=>setTimeout(e,t))}}class ts{constructor(t,e){this._mintUrl=Gr(t),this._request=e?.customRequest??qo,this._authProvider=e?.authProvider,this._logger=e?.logger??ht,Po(this._logger)}get mintUrl(){return this._mintUrl}async oidcAuth(t){const e=(await this.getLazyMintInfo()).nuts[21];if(!e?.openid_discovery)throw new Error("Mint: no NUT-21 openid_discovery");return new wn(e.openid_discovery,{...t,clientId:t?.clientId??e.client_id??"cashu-client"})}async getInfo(t){const e=await(t??this._request)({endpoint:Gt(this._mintUrl,"/v1/info")});return Yi(e,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await this.getInfo();return this._mintInfo=new yn(t),this._mintInfo}async swap(t,e){const n=await this.requestWithAuth("POST","/v1/swap",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"swap"}),new Error("Invalid response from mint");return n}async createMintQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/quote/bolt11",{requestBody:t},e);return Xr(n,this._logger)}async createMintQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/mint/quote/bolt12",{requestBody:t},e)}async checkMintQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/mint/quote/bolt11/${t}`,{},e);return Xr(n,this._logger)}async checkMintQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/mint/quote/bolt12/${t}`,{},e)}async mintBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt11",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt11"}),new Error("Invalid response from mint");return n}async mintBolt12(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt12",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt12"}),new Error("Invalid response from mint");return n}async createMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/melt/quote/bolt11",{requestBody:t},e),s=mn(n,this._logger);if(!yt(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string")throw this._logger.error("Invalid response from mint...",{data:s,op:"createMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async createMeltQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/melt/quote/bolt12",{requestBody:t},e)}async checkMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/melt/quote/bolt11/${t}`,{},e),s=mn(n,this._logger);if(!yt(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string"||typeof s?.state!="string"||!Object.values(oe).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"checkMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async checkMeltQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/melt/quote/bolt12/${t}`,{},e)}async melt(t,e,n){const s={...n?.preferAsync?{Prefer:"respond-async"}:{}};en(!this.isValidMethodString(t),`Invalid melt method: ${t}`,this._logger);const o=await this.requestWithAuth("POST",`/v1/melt/${t}`,{requestBody:e,headers:s},n?.customRequest);if(!yt(o))throw this._logger.error("Invalid response from mint...",{data:o,op:"melt"}),new Error("Invalid response from mint");return o}async meltBolt11(t,e){const n=await this.melt("bolt11",t,e),s=mn(n,this._logger);if(!yt(s)||typeof s?.state!="string"||!Object.values(oe).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"meltBolt11"}),new Error("Invalid response from mint");return s}async meltBolt12(t,e){return this.melt("bolt12",t,e)}async check(t,e){const n=await this.requestWithAuth("POST","/v1/checkstate",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.states))throw this._logger.error("Invalid response from mint...",{data:n,op:"check"}),new Error("Invalid response from mint");return n}async getKeys(t,e,n){const s=e||this._mintUrl;t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n??this._request)({endpoint:t?Gt(s,"/v1/keys",t):Gt(s,"/v1/keys")});if(!yt(o)||!Array.isArray(o.keysets))throw this._logger.error("Invalid response from mint...",{data:o,op:"getKeys"}),new Error("Invalid response from mint");return o}async getKeySets(t){return(t??this._request)({endpoint:Gt(this._mintUrl,"/v1/keysets")})}async restore(t,e){const n=await(e??this._request)({endpoint:Gt(this._mintUrl,"/v1/restore"),method:"POST",requestBody:t});if(!yt(n)||!Array.isArray(n?.outputs)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"restore"}),new Error("Invalid response from mint");return n}async connectWebSocket(){try{const t=new URL(this._mintUrl),e="v1/ws";t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e,t.protocol=t.protocol==="https:"?"wss:":"ws:";const n=t.toString();this.ws||(this.ws=Yt.getInstance().getConnection(n,this._logger)),await this.ws.ensureConnection()}catch(t){this._logger.error("Failed to connect to WebSocket...",{e:t});try{this.ws?.close()}catch{}throw this.ws=void 0,new Error("Failed to connect to WebSocket...")}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleClearAuth(t,e){if(!(!this._authProvider||!(await this.getLazyMintInfo()).requiresClearAuthToken(t,e)))return this._logger.error("Clear Authentication Token...",{cat:this._authProvider.getCAT()}),this._authProvider.getCAT()}async handleBlindAuth(t,e){if(!this._authProvider||!(await this.getLazyMintInfo()).requiresBlindAuthToken(t,e))return;const n=await this._authProvider.getBlindAuthToken({method:t,path:e});return this._logger.error("Blind Authentication Token...",{bat:n}),n}async requestWithAuth(t,e,n={},s){const o=s??this._request,i=await this.handleBlindAuth(t,e),a=await this.handleClearAuth(t,e),c={...n.headers??{},...i?{"Blind-auth":i}:{},...a?{"Clear-auth":a}:{}};return o({...n,endpoint:Gt(this._mintUrl,e),method:t,headers:c})}isValidMethodString(t){return!!(typeof t=="string"&&/^[a-z0-9_-]+$/.test(t))}}class ie{constructor(t,e,n,s,o){this._keys={},this._id=t,this._unit=e,this._active=n,this._input_fee_ppk=s,this._final_expiry=o}get id(){return this._id}get unit(){return this._unit}get isActive(){return this._active}get fee(){return this._input_fee_ppk??0}get expiry(){return this._final_expiry}get hasKeys(){return Object.keys(this._keys).length>0}get hasHexId(){return Zt(this._id)}get keys(){return this._keys}set keys(t){this._keys=t}get active(){return this.isActive}get input_fee_ppk(){return this.fee}get final_expiry(){return this.expiry}toMintKeyset(){return{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry}}toMintKeys(){return this.hasKeys?{id:this._id,unit:this._unit,keys:this._keys}:null}verify(){return this.hasKeys?ie.verifyKeysetId({id:this._id,unit:this._unit,final_expiry:this._final_expiry,keys:this._keys}):!1}static verifyKeysetId(t){if(!t.keys||Object.keys(t.keys).length===0)return!1;const e=sn(t.id)&&!Zt(t.id),n=Zt(t.id)?G(t.id)[0]:0;return ji(t.keys,t.unit,t.final_expiry,n,e)===t.id}static fromMintApi(t,e){const n=new ie(t.id,t.unit,t.active,t.input_fee_ppk,t.final_expiry);if(e){if(e.id!==t.id)throw new Error(`Mismatched keyset ids: meta=${t.id}, keys=${e.id}`);if(e.unit!==t.unit)throw new Error(`Mismatched keyset units: meta=${t.unit}, keys=${e.unit}`);if(e.final_expiry!==void 0&&t.final_expiry!==void 0&&e.final_expiry!==t.final_expiry)throw new Error(`Mismatched keyset expiry for id=${t.id}`);n.keys=e.keys}return n}}class Lt{constructor(t,e,n,s){if(this.keysets={},this.mint=typeof t=="string"?new ts(t):t,this.unit=e,n&&s){const o=Array.isArray(s)?s:[s];this.buildKeychain(n,o),this.getCheapestKeyset()}}static fromCache(t,e){const n=new Lt(t,e.unit);return n.loadFromCache(e),n}static mintToCacheDTO(t,e,n,s){const o=new Map(s.map(i=>[i.id,i]));return{keysets:n.map(i=>{const a=o.get(i.id),c={...i};return a&&(c.keys=a.keys),c}),unit:t,mintUrl:e}}static cacheToMintDTO(t){const e=t.keysets.map(s=>({id:s.id,unit:s.unit,active:s.active,input_fee_ppk:s.input_fee_ppk,final_expiry:s.final_expiry})),n=t.keysets.filter(s=>!!s.keys).map(s=>({id:s.id,unit:s.unit,keys:s.keys,final_expiry:s.final_expiry}));return{keysets:e,keys:n}}async init(t){if(Object.keys(this.keysets).length>0&&!t)return;const[e,n]=await Promise.all([this.mint.getKeySets(),this.mint.getKeys()]);this.buildKeychain(e.keysets,n.keysets),this.getCheapestKeyset()}loadFromCache(t){if(t.unit!==this.unit)throw new Error(`KeyChain unit mismatch in cache, expected '${this.unit}', got '${t.unit}' from ${t.mintUrl}`);const{keysets:e,keys:n}=Lt.cacheToMintDTO(t);this.buildKeychain(e,n),this.getCheapestKeyset()}buildKeychain(t,e){this.keysets={};const n=t.filter(o=>o.unit===this.unit);if(!n.length)throw new Error(`No Keysets found for unit: ${this.unit}`);const s=new Map(e.filter(o=>o.unit===this.unit).map(o=>[o.id,o]));for(const o of n){let i;if(o.active&&Zt(o.id)){const a=s.get(o.id);i=ie.fromMintApi(o,a)}else i=ie.fromMintApi(o);if(i.hasKeys&&!i.verify())throw new Error(`Keyset verification failed for ID ${i.id}`);this.keysets[i.id]=i}}getKeyset(t){const e=t?this.keysets[t]:this.getCheapestKeyset();if(!e)throw new Error(`Keyset '${t}' not found`);return e}getCheapestKeyset(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");const t=Object.values(this.keysets).filter(e=>e.isActive&&e.hasHexId&&e.hasKeys);if(t.length===0)throw new Error("No active keyset found");return t.sort((e,n)=>e.fee-n.fee)[0]}getKeysets(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");return Object.values(this.keysets)}getAllKeys(){return this.getKeysets().map(t=>t.toMintKeys()).filter(t=>t!==null)}getAllKeysetIds(){return this.getKeysets().map(t=>t.id)}get cache(){const t=this.getKeysets(),e=t.map(s=>s.toMintKeyset()),n=t.map(s=>s.toMintKeys()).filter(s=>s!==null);return Lt.mintToCacheDTO(this.unit,this.mint.mintUrl,e,n)}getCache(){const t=this.cache,{keysets:e,keys:n}=Lt.cacheToMintDTO(t);return{keysets:e,keys:n,unit:t.unit,mintUrl:t.mintUrl}}}class bn{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const Ji=new Set(["locktime","pubkeys","n_sigs","refund","n_sigs_refund"]);function Xi(r){if(!r||typeof r!="string")throw new Error("tag key must be a non empty string");if(Ji.has(r))throw new Error(`additionalTags must not use reserved key "${r}"`)}const es=1024,vn=new WeakMap;function ta(r,t){t&&vn.set(r,t)}function ea(r){const t=vn.get(r);if(t)return vn.delete(r),t}class ft{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:G(t.dleq.s),e:G(t.dleq.e),r:this.blindingFactor});const s={id:t.id,amount:t.amount,C_:Vt(t.C_)},o=Vt(e.keys[t.amount]),i=ai(s,this.blindingFactor,this.secret,o),a={...ci(i),...n&&{dleq:{s:tt(n.s),e:tt(n.e),r:hn(n.r??BigInt(0))}}},c=ea(this);return c&&(a.p2pk_e=c),a}static createP2PKData(t,e,n,s){return Ct(e,n.keys,s).map(o=>this.createSingleP2PKData(t,o,n.id))}static createSingleP2PKData(t,e,n){const s=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],o=t.refundKeys??[],i=Math.max(1,Math.min(t.requiredSignatures??1,s.length)),a=Math.max(1,Math.min(t.requiredRefundSignatures??1,o.length||1));if(s.length===0)throw new Error("P2PK requires at least one pubkey");const c=typeof t.hashlock=="string"&&t.hashlock.length>0;let u=c?t.hashlock:s[0],l=c?s:s.slice(1),d=o,m;if(t.blindKeys){const Y=[...s,...o],{blinded:N,Ehex:M}=mi(Y,n);c?l=N.slice(0,s.length):(u=N[0],l=N.slice(1,s.length)),d=N.slice(s.length),m=M}const g=[],w=t.locktime??NaN;if(Number.isSafeInteger(w)&&w>=0&&g.push(["locktime",String(w)]),l.length>0&&(g.push(["pubkeys",...l]),i>1&&g.push(["n_sigs",String(i)])),d.length>0&&(g.push(["refund",...d]),a>1&&g.push(["n_sigs_refund",String(a)])),t.sigFlag=="SIG_ALL"&&g.push(["sigflag","SIG_ALL"]),t.additionalTags?.length){const Y=t.additionalTags.map(([N,...M])=>(Xi(N),[N,...M.map(String)]));g.push(...Y)}const _=[c?"HTLC":"P2PK",{nonce:tt(qt(32)),data:u,tags:g}],b=JSON.stringify(_),O=[...b].length;if(O>es)throw new Error(`Secret too long (${O} characters), maximum is ${es}`);const $=new TextEncoder().encode(b),{r:U,B_:R}=an($),j=new ft(new bn(e,R,n).getSerializedBlindedMessage(),U,$);return t.blindKeys&&m&&ta(j,m),j}static createRandomData(t,e,n){return Ct(t,e.keys,n).map(s=>this.createSingleRandomData(s,e.id))}static createSingleRandomData(t,e){const n=tt(qt(32)),s=new TextEncoder().encode(n),{r:o,B_:i}=an(s);return new ft(new bn(t,i,e).getSerializedBlindedMessage(),o,s)}static createDeterministicData(t,e,n,s,o){return Ct(t,s.keys,o).map((i,a)=>this.createSingleDeterministicData(i,e,n+a,s.id))}static createSingleDeterministicData(t,e,n,s){const o=Oi(e,s,n),i=tt(o),a=new TextEncoder().encode(i),c=W.toBigInt(qi(e,s,n)),{r:u,B_:l}=an(a,c);return new ft(new bn(t,l,s).getSerializedBlindedMessage(),u,a)}static sumOutputAmounts(t){return t.reduce((e,n)=>e+n.blindedMessage.amount,0)}}const na=(r,t,e,n=!1,s=!1,o=ht)=>{const i=Co();let a=null,c=1/0,u=0,l=0;const d=N=>{try{return e.getKeyset(N.id).fee}catch(M){_e(`Could not get fee. No keyset found for keyset id: ${N.id}`,o,{error:M,keychain:e.getKeysets()})}},m=(N,M)=>N-(n?Math.ceil(M/1e3):0),g=N=>{const M=[...N];for(let B=M.length-1;B>0;B--){const K=Math.floor(Math.random()*(B+1));[M[B],M[K]]=[M[K],M[B]]}return M},w=(N,M,B)=>{let K=0,J=N.length-1,D=null;for(;K<=J;){const E=Math.floor((K+J)/2),x=N[E].exFee;(B?x<=M:x>=M)?(D=E,B?K=E+1:J=E-1):B?J=E-1:K=E+1}return B?D:K<N.length?K:null},_=(N,M)=>{const B=M.exFee;let K=0,J=N.length;for(;K<J;){const D=Math.floor((K+J)/2);N[D].exFee<B?K=D+1:J=D}N.splice(K,0,M)},b=(N,M)=>m(N,M)<t?1/0:N+M/1e3-t;let O=0,$=0;const U=r.map(N=>{const M=d(N),B=n?N.amount-M/1e3:N.amount,K={proof:N,exFee:B,ppkfee:M};return(!n||B>0)&&(O+=N.amount,$+=M),K});let R=n?U.filter(N=>N.exFee>0):U;if(R.sort((N,M)=>N.exFee-M.exFee),R.length>0){let N;if(s){const M=w(R,t,!0);N=M!==null?M+1:0}else{const M=w(R,t,!1);if(M!==null){const B=R[M].exFee,K=w(R,B,!0);Mr(K,"Unexpected null rightIndex in binary search",o),N=K+1}else N=R.length}for(let M=N;M<R.length;M++)O-=R[M].proof.amount,$-=R[M].ppkfee;R=R.slice(0,N)}const j=m(O,$);if(t<=0||t>j)return{keep:r,send:[]};const Y=Math.min(Math.ceil(t*(1+0/100)),t+0,j);for(let N=0;N<60;N++){const M=[];let B=0,K=0;for(const p of g(R)){const y=B+p.proof.amount,v=K+p.ppkfee,I=m(y,v);if(s&&I>t||(M.push(p),B=y,K=v,I>=t))break}const J=new Set(M),D=R.filter(p=>!J.has(p)),E=g(Array.from({length:M.length},(p,y)=>y)).slice(0,5e3);for(const p of E){const y=m(B,K);if(y===t||!s&&y>=t&&y<=Y)break;const v=M[p],I=B-v.proof.amount,C=K-v.ppkfee,f=m(I,C),h=t-f,k=w(D,h,s);if(k!==null){const S=D[k];(!s||S.exFee>v.exFee)&&(h>=0||S.exFee<=v.exFee)&&(M[p]=S,B=I+S.proof.amount,K=C+S.ppkfee,D.splice(k,1),_(D,v))}}const x=b(B,K);if(x<c){o.debug(`selectProofsToSend: best solution found in trial #${N} - amount: ${B}, delta: ${x}`),a=[...M].sort((y,v)=>v.exFee-y.exFee),c=x,u=B,l=K;const p=[...a];for(;p.length>1&&c>0;){const y=p.pop(),v=B-y.proof.amount,I=K-y.ppkfee,C=b(v,I);if(C==1/0)break;C<c&&(a=[...p],c=C,u=v,l=I,B=v,K=I)}}if(a&&c<1/0){const p=m(u,l);if(p===t||!s&&p>=t&&p<=Y)break}if(i.elapsed()>1e3){en(s,"Proof selection took too long. Try again with a smaller proof set.",o),o.warn("Proof selection took too long. Returning best selection so far.");break}}if(a&&c<1/0){const N=a.map(K=>K.proof),M=new Set(N),B=r.filter(K=>!M.has(K));return o.info(`Proof selection took ${i.elapsed()}ms`),{keep:B,send:N}}return{keep:r,send:[]}};class ra{constructor(t){if(this.next=new Map,this.locks=new Map,t)for(const[e,n]of Object.entries(t))this.next.set(e,n)}async withLock(t,e){const n=this.locks.get(t)??Promise.resolve();let s;const o=new Promise(a=>s=a),i=n.then(()=>o);this.locks.set(t,i);try{return await n,await e()}finally{s(),this.locks.get(t)===i&&this.locks.delete(t)}}async reserve(t,e){if(e<0)throw new Error("reserve called with negative count");return this.withLock(t,()=>{const n=this.next.get(t)??0;return e===0?{start:n,count:0}:(this.next.set(t,n+e),{start:n,count:e})})}async advanceToAtLeast(t,e){await this.withLock(t,()=>{const n=this.next.get(t)??0;e>n&&this.next.set(t,e)})}async setNext(t,e){await this.withLock(t,()=>{if(e<0)throw new Error("setNext: negative next not allowed");this.next.set(t,e)})}snapshot(){return Promise.resolve(Object.fromEntries(this.next.entries()))}}class sa{constructor(t){this.wallet=t}send(t,e){return new oa(this.wallet,t,e)}receive(t){return new ia(this.wallet,t)}mintBolt11(t,e){return new ns(this.wallet,"bolt11",t,e)}mintBolt12(t,e){return new ns(this.wallet,"bolt12",t,e)}meltBolt11(t,e){return new rs(this.wallet,"bolt11",t,e)}meltBolt12(t,e){return new rs(this.wallet,"bolt12",t,e)}}class oa{constructor(t,e,n){this.wallet=t,this.amount=e,this.proofs=n,this.config={}}asRandom(t){return this.sendOT={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.sendOT={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.sendOT={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.sendOT={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.sendOT={type:"custom",data:t},this}keepAsRandom(t){return this.keepOT={type:"random",denominations:t},this}keepAsDeterministic(t=0,e){return this.keepOT={type:"deterministic",counter:t,denominations:e},this}keepAsP2PK(t,e){return this.keepOT={type:"p2pk",options:t,denominations:e},this}keepAsFactory(t,e){return this.keepOT={type:"factory",factory:t,denominations:e},this}keepAsCustom(t){return this.keepOT={type:"custom",data:t},this}includeFees(t=!0){return this.config.includeFees=t,this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}offlineExactOnly(t=!1){return this.offlineExact={requireDleq:t},this}offlineCloseMatch(t=!1){return this.offlineClose={requireDleq:t},this}async prepare(){const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.prepareSwapToSend(this.amount,this.proofs,this.config,t)}async run(){if((this.offlineExact||this.offlineClose)&&(this.sendOT||this.keepOT))throw new Error("Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.");if(this.offlineExact)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!0,requireDleq:this.offlineExact.requireDleq});if(this.offlineClose)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!1,requireDleq:this.offlineClose.requireDleq});const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.send(this.amount,this.proofs,this.config,t)}}class ia{constructor(t,e){this.wallet=t,this.token=e,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}requireDleq(t=!0){return this.config.requireDleq=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async prepare(){return this.wallet.prepareSwapToReceive(this.token,this.config,this.outputType)}async run(){return this.wallet.receive(this.token,this.config,this.outputType)}}class ns{constructor(t,e,n,s){this.wallet=t,this.method=e,this.amount=n,this.quote=s,this.config={},this._hasPrivkey}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){if(this.method==="bolt11"){const e=this.quote;if(typeof e!="string"&&e.pubkey&&!this.config.privkey)throw new Error("privkey is required for locked BOLT11 mint quotes");return this.wallet.mintProofsBolt11(this.amount,e,this.config,this.outputType)}const t=this.quote;if(!this.config.privkey)throw new Error("privkey is required for BOLT12 mint quotes");return this.wallet.mintProofsBolt12(this.amount,t,this.config.privkey,this.config,this.outputType)}}class rs{constructor(t,e,n,s){this.wallet=t,this.method=e,this.quote=n,this.proofs=s,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}onChangeOutputsCreated(t){return this.config.onChangeOutputsCreated=t,this}async prepare(){return await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType)}async run(){const t=await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType);return this.wallet.completeMelt(t,this.config.privkey)}}function aa(r){const t=new WeakSet;try{return JSON.stringify(r,(e,n)=>{if(typeof n=="object"&&n!==null){if(t.has(n))return"[Circular]";t.add(n)}return n})}catch{return Object.prototype.toString.call(r)}}function ss(r){if(r instanceof Error)return r;const t=typeof r=="string"?r:aa(r),e=new Error(t);return e.cause=r,e}function os(){const r=new Error("Aborted");return Object.defineProperty(r,"name",{value:"AbortError"}),r}function Ft(r){r&&Promise.resolve(r).then(t=>{try{t()}catch{}}).catch(()=>{})}class ca{constructor(t){this.wallet=t,this.countersReservedHandlers=new Set,this.meltBlanksHandlers=new Set}withAbort(t,e){if(!t)return e;if(t.aborted)return e(),()=>{};const n=()=>e();return t.addEventListener("abort",n,{once:!0}),()=>{t.removeEventListener("abort",n),e()}}waitUntilPaid(t,e,n,s="Timeout waiting for paid"){return new Promise((o,i)=>{let a=null,c=null,u=!1;const l=m=>{u||(u=!0,Ft(a),c&&(clearTimeout(c),c=null),n?.signal&&n.signal.removeEventListener("abort",d),m&&i(ss(m)))},d=()=>l(os());if(n?.signal){if(n.signal.aborted)return d();n.signal.addEventListener("abort",d,{once:!0})}n?.timeoutMs&&n.timeoutMs>0&&(c=setTimeout(()=>l(new Error(s)),n.timeoutMs)),a=t(e,m=>{l(),o(m)},m=>l(m),{signal:n?.signal}),a.catch(m=>l(m))})}countersReserved(t,e){this.countersReservedHandlers.add(t);const n=()=>this.countersReservedHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitCountersReserved(t){for(const e of this.countersReservedHandlers)se(e,t,this.wallet.logger,{event:"countersReserved"})}meltBlanksCreated(t,e){this.meltBlanksHandlers.add(t);const n=()=>this.meltBlanksHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitMeltBlanksCreated(t){for(const e of this.meltBlanksHandlers)se(e,t,this.wallet.logger,{event:"meltBlanksCreated"})}async mintQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const o=this.wallet.mint.webSocketConnection;if(!o)throw new Error("Failed to establish WebSocket connection.");const i=Array.from(new Set(t)),a=o.createSubscription({kind:"bolt11_mint_quote",filters:i},e,n),c=()=>o.cancelSubscription(a,e);return this.withAbort(s?.signal,c)}async mintQuotePaid(t,e,n,s){return this.mintQuoteUpdates([t],o=>{o.state===pn.PAID&&e(o)},n,s)}async meltQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const o=this.wallet.mint.webSocketConnection;if(!o)throw new Error("Failed to establish WebSocket connection.");const i=Array.from(new Set(t)),a=o.createSubscription({kind:"bolt11_melt_quote",filters:i},e,n),c=()=>o.cancelSubscription(a,e);return this.withAbort(s?.signal,c)}async meltQuotePaid(t,e,n,s){return this.meltQuoteUpdates([t],o=>{o.state===oe.PAID&&e(o)},n,s)}async proofStateUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const o=this.wallet.mint.webSocketConnection;if(!o)throw new Error("Failed to establish WebSocket connection.");const i=new TextEncoder,a={};for(const m of t){const g=Ae(i.encode(m.secret)).toHex(!0);a[g]=m}const c=Object.keys(a),u=m=>{e({...m,proof:a[m.Y]})},l=o.createSubscription({kind:"proof_state",filters:c},u,n),d=()=>o.cancelSubscription(l,u);return this.withAbort(s?.signal,d)}onceMintPaid(t,e){return this.waitUntilPaid(this.mintQuotePaid.bind(this),t,e,"Timeout waiting for mint paid")}onceAnyMintPaid(t,e){return new Promise((n,s)=>{const o=Array.from(new Set(t)),i=new Map;let a=null,c=null,u=!1,l=!1;const d=g=>{if(!l){l=!0;for(const w of i.values())Ft(w);i.clear(),a&&(clearTimeout(a),a=null),e?.signal&&e.signal.removeEventListener("abort",m),g&&s(ss(g))}},m=()=>d(os());if(e?.signal){if(e.signal.aborted)return m();e.signal.addEventListener("abort",m,{once:!0})}if(e?.timeoutMs&&e.timeoutMs>0&&(a=setTimeout(()=>d(new Error("Timeout waiting for any mint paid")),e.timeoutMs)),o.length===0)return d(new Error("No quote ids provided"));for(const g of o){const w=this.mintQuotePaid(g,_=>{d(),n({id:g,quote:_})},_=>{if(e?.failOnError){d(_);return}c=_;const b=i.get(g);b&&(Ft(b),i.delete(g)),u&&i.size===0&&d(c??new Error("No subscriptions remaining"))});i.set(g,w),w.catch(_=>{if(e?.failOnError){d(_);return}c=_;const b=i.get(g);b&&(Ft(b),i.delete(g)),u&&i.size===0&&d(c??new Error("No subscriptions remaining"))})}u=!0})}onceMeltPaid(t,e){return this.waitUntilPaid(this.meltQuotePaid.bind(this),t,e,"Timeout waiting for melt paid")}proofStatesStream(t,e){return(async function*(){const n=[];let s=!1,o=null;const i=e?.maxBuffer&&e.maxBuffer>0?e.maxBuffer:1/0,a=e?.drop??"oldest",c=()=>{const m=o;o=null,m&&m()},u=m=>{if(n.length>=i)if(a==="oldest"){const g=n.shift();if(g!==void 0)try{e?.onDrop?.(g)}catch{}n.push(m)}else{try{e?.onDrop?.(m)}catch{}return}else n.push(m);c()},l=this.proofStateUpdates(t,m=>{u(m)},()=>{s=!0,c()},{signal:e?.signal}),d=()=>{s=!0,c()};try{for(e?.signal&&(e.signal.aborted?d():e.signal.addEventListener("abort",d,{once:!0}));!s||n.length;){for(;n.length;)yield n.shift();if(s)break;await new Promise(m=>o=m)}}finally{Ft(l),e?.signal&&e.signal.removeEventListener("abort",d)}}).call(this)}group(){const t=[];let e=!1;const n=(()=>{if(!e)for(e=!0;t.length;)Ft(t.pop())});return n.add=s=>e?(Ft(s),s):(t.push(s),s),Object.defineProperty(n,"cancelled",{get:()=>e,enumerable:!0}),n}}class ua{constructor(t){this.src=t}async peekNext(t){return(await this.src.reserve(t,0)).start}async advanceToAtLeast(t,e){await this.src.advanceToAtLeast(t,e)}async setNext(t,e){if(typeof this.src.setNext=="function"){await this.src.setNext(t,e);return}throw new Error("CounterSource does not support setNext()")}async snapshot(){if(typeof this.src.snapshot=="function")return await this.src.snapshot();throw new Error("CounterSource does not support snapshot()")}}const kn="__PENDING__";class En{constructor(t,e){if(this._seed=void 0,this._unit="sat",this._mintInfo=void 0,this._denominationTarget=3,this._secretsPolicy="auto",this._boundKeysetId=kn,this.swap=this.send.bind(this),this.ops=new sa(this),this.on=new ca(this),this._logger=e?.logger??ht,this._selectProofs=e?.selectProofs??na,this.mint=typeof t=="string"?new ts(t,{authProvider:e?.authProvider,logger:this._logger}):t,this._unit=e?.unit??this._unit,this._boundKeysetId=e?.keysetId??this._boundKeysetId,e?.bip39seed&&(this.failIf(!(e.bip39seed instanceof Uint8Array),"bip39seed must be a valid Uint8Array",{bip39seed:e.bip39seed}),this._seed=e.bip39seed),this._secretsPolicy=e?.secretsPolicy??this._secretsPolicy,e?.counterSource?this._counterSource=e.counterSource:this._counterSource=new ra(e?.counterInit),this.counters=new ua(this._counterSource),this._keyChain=new Lt(this.mint,this._unit),this._denominationTarget=e?.denominationTarget??this._denominationTarget,e?.keysets&&e?.keys&&e?.mintInfo){const n=Array.isArray(e.keys)?e.keys:[e.keys],s=Lt.mintToCacheDTO(this._unit,this.mint.mintUrl,e.keysets,n);this.loadMintFromCache(e.mintInfo,s)}}fail(t,e){return _e(t,this._logger,e)}failIf(t,e,n){return en(t,e,this._logger,n)}failIfNullish(t,e,n){return Mr(t,e,this._logger,n)}safeCallback(t,e,n){se(t,e,this._logger,n)}assertAmount(t,e){try{fn(t,!1)}catch(n){this.fail(n.message,{op:e,amount:t})}}async loadMint(t){const e=[];(!this._mintInfo||t)&&e.push(this.mint.getInfo().then(n=>(this._mintInfo=new yn(n),null))),e.push(this._keyChain.init(t).then(()=>null)),await Promise.all(e),this.finishInit()}loadMintFromCache(t,e){this._mintInfo=new yn(t),this._keyChain.loadFromCache(e),this.finishInit()}finishInit(){const t=this._keyChain.getCheapestKeyset().id;if(this._logger.debug("KeyChain",{keychain:this._keyChain.cache}),this._boundKeysetId===kn)this._boundKeysetId=t;else{const e=this._keyChain.getKeyset(this._boundKeysetId);this.failIf(!e.hasKeys,"Wallet keyset has no keys",{keyset:e.id})}this.getMintInfo()}get keyChain(){return this._keyChain}get unit(){return this._unit}getMintInfo(){return this.failIfNullish(this._mintInfo,"Mint info not initialized; call loadMint or loadMintFromCache first"),this._mintInfo}get keysetId(){return this.failIf(this._boundKeysetId===kn,"Wallet not initialised, call loadMint or loadMintFromCache first"),this._boundKeysetId}getKeyset(t){const e=this._keyChain.getKeyset(t??this.keysetId);return this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),e}get logger(){return this._logger}async reserveFor(t,e){return e<=0?{start:0,count:0}:this._counterSource.reserve(t,e)}countersNeeded(t){return t.type!=="deterministic"||t.counter!==0?0:(t.denominations??[]).length}async addCountersToOutputTypes(t,...e){const n=e.filter(u=>u.type==="deterministic"&&u.counter>0&&(u.denominations?.length??0)>0);if(n.length>1){const u=n.map(l=>({start:l.counter,end:l.counter+l.denominations.length})).sort((l,d)=>l.start-d.start);for(let l=1;l<u.length;l++)this.failIf(u[l].start<u[l-1].end,"Manual counter ranges overlap",{keysetId:t,prev:u[l-1],cur:u[l]})}if(n.length>0){const u=Math.max(...n.map(l=>l.counter+l.denominations.length));await this._counterSource.advanceToAtLeast(t,u),this._logger.debug("Counter source advanced to respect manual deterministic counters",{keysetId:t,maxManualEnd:u})}const s=e.reduce((u,l)=>u+this.countersNeeded(l),0);if(s===0)return{outputTypes:e};const o=await this.reserveFor(t,s);let i=o.start;const a=e.map(u=>{if(u.type==="deterministic"&&u.counter===0){const l=u.denominations?.length??0;if(l>0){const d={...u,counter:i};return i+=l,d}}return u}),c={keysetId:t,start:o.start,count:o.count,next:o.start+o.count};return this.on._emitCountersReserved(c),{outputTypes:a,used:c}}bindKeyset(t){const e=this._keyChain.getKeyset(t);this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),this._boundKeysetId=e.id,this._logger.debug("Wallet bound to keyset",{keysetId:e.id,unit:e.unit,feePPK:e.fee})}withKeyset(t,e){const n=new En(this.mint,{keysetId:t,bip39seed:this._seed,secretsPolicy:this._secretsPolicy,logger:this._logger,counterSource:e?.counterSource??this._counterSource});return n.loadMintFromCache(this.getMintInfo().cache,this._keyChain.cache),n}defaultOutputType(){return this._secretsPolicy==="random"?{type:"random"}:this._secretsPolicy==="deterministic"?(this.failIfNullish(this._seed,"Deterministic policy requires a seed"),{type:"deterministic",counter:0}):this._seed?{type:"deterministic",counter:0}:{type:"random"}}configureOutputs(t,e,n,s=!1,o=[]){let i=t;if(n.type==="custom"){this.failIf(s,"The custom OutputType does not support automatic fee inclusion");const c=ft.sumOutputAmounts(n.data);return this.failIf(c!==t,`Custom output data total (${c}) does not match amount (${t})`),n}let a=n.denominations??[];if(a.length===0&&o.length>0&&(a=Ri(o,i,e.keys,this._denominationTarget)),a=Ct(i,e.keys,a),s){let c=this.getFeesForKeyset(a.length,e.id),u=Ct(c,e.keys);for(;this.getFeesForKeyset(a.length+u.length,e.id)>c;)c++,u=Ct(c,e.keys);i+=c,a=[...a,...u]}return{...n,denominations:a}}preparedTotal(t){return t.type==="custom"?ft.sumOutputAmounts(t.data):(t.denominations??[]).reduce((e,n)=>e+n,0)}createOutputData(t,e,n){if(this.failIf(t<0,"Amount was negative",{amount:t}),n.type!="custom"&&n.denominations&&n.denominations.length>0){const o=n.denominations.reduce((i,a)=>i+a,0);this.failIf(o!==t,"Denominations do not sum to the expected amount",{splitSum:o,expected:t})}let s;switch(n.type){case"random":s=ft.createRandomData(t,e,n.denominations);break;case"deterministic":this.failIfNullish(this._seed,"Deterministic outputs require a seed configured in the wallet"),s=ft.createDeterministicData(t,this._seed,n.counter,e,n.denominations);break;case"p2pk":s=ft.createP2PKData(n.options,t,e,n.denominations);break;case"factory":{s=Ct(t,e.keys,n.denominations).map(o=>n.factory(o,e));break}case"custom":{s=n.data;const o=ft.sumOutputAmounts(s);this.failIf(o!==t,`Custom output data total (${o}) does not match amount (${t})`);break}default:this.fail("Invalid OutputType")}return s}createSwapTransaction(t,e,n=[]){t=this._prepareInputsForMint(t);const s=[...e,...n],o=s.map((l,d)=>d);$r(t)||o.sort((l,d)=>s[l].blindedMessage.amount-s[d].blindedMessage.amount);const i=[...Array.from({length:e.length},()=>!0),...Array.from({length:n.length},()=>!1)],a=o.map(l=>s[l]),c=o.map(l=>i[l]),u=a.map(l=>l.blindedMessage);return this._logger.debug("createSwapTransaction:",{indices:o,sortedKeepVector:c}),{payload:{inputs:t,outputs:u},outputData:a,keepVector:c,sortedIndices:o}}async receive(t,e,n){const s=await this.prepareSwapToReceive(t,e,n),{keep:o}=await this.completeSwap(s,e?.privkey);return o}async prepareSwapToReceive(t,e,n){const{keysetId:s,requireDleq:o,proofsWeHave:i,onCountersReserved:a}=e||{};n=n??this.defaultOutputType();const c=typeof t=="string"?this.decodeToken(t):t,u=Gr(c.mint);this.failIf(u!==this.mint.mintUrl,"Token belongs to a different mint",{token:u,wallet:this.mint.mintUrl}),this.failIf(c.unit!==this._unit,"Token is not in wallet unit",{token:c.unit,wallet:this._unit});let l=[];({proofs:l}=c);const d=Tt(l);this.failIf(d===0,"Token contains no proofs",{proofs:l}),this.assertAmount(d,"prepareSwapToReceive");const m=this.getKeyset(s);if(o)for(const $ of l){const U=this._keyChain.getKeyset($.id);Vi($,U)||this.fail("Token contains proofs with invalid or missing DLEQ")}const g=this.getFeesForProofs(l),w=d-g;let _=this.configureOutputs(w,m,n,!1,i);const b=await this.addCountersToOutputTypes(m.id,_);[_]=b.outputTypes,b.used&&this.safeCallback(a,b.used,{op:"receive"}),this._logger.debug("receive counter",{counter:b.used,receiveOT:_});const O=this.createOutputData(this.preparedTotal(_),m,_);return{amount:w,fees:g,keysetId:m.id,inputs:l,keepOutputs:O}}sendOffline(t,e,n){this.assertAmount(t,"sendOffline");const{requireDleq:s=!1,includeFees:o=!1,exactMatch:i=!0}=n||{};s&&(e=e.filter(l=>l.dleq!=null)),this.failIf(Tt(e)<t,"Not enough funds available to send");const{keep:a,send:c}=this.selectProofsToSend(e,t,o,i),u=this._prepareInputsForMint(c,s);return{keep:a,send:u}}async send(t,e,n,s){this.assertAmount(t,"send");const{keysetId:o,includeFees:i=!1}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};try{const c=this.defaultOutputType().type==="deterministic",u=g=>!g||g.type==="random"&&(!g.denominations||g.denominations.length===0);if(o||c||!u(s.send)||s.keep&&!u(s.keep)){const g=[];throw o&&g.push("keysetId override"),c&&g.push("wallet default is deterministic"),u(s.send)||g.push("non-default send output type"),s.keep&&!u(s.keep)&&g.push("non-default keep output type"),new Error(`Options require a swap: ${g.join(", ")}`)}const{keep:l,send:d}=this.sendOffline(t,e,{includeFees:i,exactMatch:!0,requireDleq:!1}),m=i?this.getFeesForProofs(d):0;if(Tt(d)===t+m)return this._logger.info("Successful exactMatch offline selection!"),{keep:l,send:d}}catch(c){const u=c instanceof Error?c.message:"Unknown error";this._logger.debug("ExactMatch offline selection failed.",{e:u})}const a=await this.prepareSwapToSend(t,e,n,s);return await this.completeSwap(a,n?.privkey)}async prepareSwapToSend(t,e,n,s){const{keysetId:o,includeFees:i=!1,onCountersReserved:a}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};const c=this.getKeyset(o);let u=this.configureOutputs(t,c,s.send??this.defaultOutputType(),i);const l=this.preparedTotal(u),{keep:d,send:m}=this.selectProofsToSend(e,l,!0);if(m.length===0)throw new Error("Not enough funds available to send");const g=Tt(m),w=this.getFeesForProofs(m),_=g-w-l;this.failIf(_<0,"Not enough funds available for swap",{selectedSum:g,swapFee:w,sendAmount:l,changeAmount:_});let b=this.configureOutputs(_,c,s.keep??this.defaultOutputType(),!1,n?.proofsWeHave);const O=this.preparedTotal(b),$=await this.addCountersToOutputTypes(c.id,u,b);[u,b]=$.outputTypes,$.used&&this.safeCallback(a,$.used,{op:"send"}),this._logger.debug("send counters",{counter:$.used,sendOT:u,keepOT:b});const U=this.createOutputData(l,c,u),R=this.createOutputData(O,c,b);return{amount:t,fees:w,keysetId:c.id,inputs:m,sendOutputs:U,keepOutputs:R,unselectedProofs:d}}async completeSwap(t,e){const n=t?.keepOutputs?t.keepOutputs:[],s=t.sendOutputs?t.sendOutputs:[],o=t.unselectedProofs?t.unselectedProofs:[];e&&(t.inputs=this.signP2PKProofs(t.inputs,e,[...n,...s]));const i=this.createSwapTransaction(t.inputs,n,s),{signatures:a}=await this.mint.swap(i.payload);this.failIf(a.length<i.outputData.length,`Mint returned ${a.length} signatures, expected ${i.outputData.length}`);const c=this.getKeyset(t.keysetId),u=i.outputData.map((w,_)=>w.toProof(a[_],c)),l=Array(u.length),d=Array(i.keepVector.length);i.sortedIndices.forEach((w,_)=>{d[w]=i.keepVector[_],l[w]=u[_]});const m=[],g=[];return l.forEach((w,_)=>{d[_]?m.push(w):g.push(w)}),this._logger.debug("SEND COMPLETED",{unselectedProofs:o.map(w=>w.amount),keepProofs:m.map(w=>w.amount),sendProofs:g.map(w=>w.amount)}),{keep:[...m,...o],send:g}}selectProofsToSend(t,e,n=!1,s=!1){this.assertAmount(e,"selectProofsToSend");const{keep:o,send:i}=this._selectProofs(t,e,this._keyChain,n,s);return{keep:o,send:i}}signP2PKProofs(t,e,n,s){if(!$r(t))return Kr(t,e,this._logger);this.failIfNullish(n,"OutputData is required for SIG_ALL proof signing."),Ii(t);const[o,...i]=t;let a=o;const c=[Bi(t,n,s),Si(t,n,s),Ai(t,n,s)];for(const u of c)a=Kr([a],e,this._logger,u)[0];return[a,...i]}getFeesForProofs(t){const e=t.reduce((n,s)=>n+this.getProofFeePPK(s),0);return Math.ceil(e/1e3)}getProofFeePPK(t){try{return this._keyChain.getKeyset(t.id).fee}catch(e){this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`,{e,keychain:this._keyChain.getKeysets()})}}getFeesForKeyset(t,e){try{const n=this._keyChain.getKeyset(e).fee;return Math.floor(Math.max((t*n+999)/1e3,0))}catch(n){this.fail(`No keyset found with ID ${e}`,{e:n})}}_prepareInputsForMint(t,e=!1){return t.map(n=>{const s=n.witness&&typeof n.witness!="string"?JSON.stringify(n.witness):n.witness,{dleq:o,p2pk_e:i,...a}=n;return e&&o?{...a,dleq:o,witness:s}:{...a,witness:s}})}decodeToken(t){const e=this._keyChain.getAllKeysetIds();return $i(t,e)}async batchRestore(t=300,e=100,n=0,s){const o=Math.ceil(t/e),i=[];let a,c=0;for(;c<o;){const u=await this.restore(n,e,{keysetId:s});u.proofs.length>0?(c=0,i.push(...u.proofs),a=u.lastCounterWithSignature):c++,n+=e}return{proofs:i,lastCounterWithSignature:a}}async restore(t,e,n){const{keysetId:s}=n||{},o=this.getKeyset(s);this.failIfNullish(this._seed,"Cashu Wallet must be initialized with a seed to use restore");const i=Array(e).fill(0),a=ft.createDeterministicData(0,this._seed,t,o,i),{outputs:c,signatures:u}=await this.mint.restore({outputs:a.map(g=>g.blindedMessage)}),l={};c.forEach((g,w)=>l[g.B_]=u[w]);const d=[];let m;for(let g=0;g<a.length;g++){const w=l[a[g].blindedMessage.B_];w&&(m=t+g,a[g].blindedMessage.amount=w.amount,d.push(a[g].toProof(w,o)))}return{proofs:d,lastCounterWithSignature:m}}async createMintQuote(t,e){return this.createMintQuoteBolt11(t,e)}async createMintQuoteBolt11(t,e){this.assertAmount(t,"createMintQuoteBolt11"),e&&(this.getMintInfo().supportsNut04Description("bolt11",this._unit)||this.fail("Mint does not support description for bolt11"));const n={unit:this._unit,amount:t,description:e},s=await this.mint.createMintQuoteBolt11(n);return{...s,amount:s.amount||t,unit:s.unit||this._unit}}async createLockedMintQuote(t,e,n){this.assertAmount(t,"createLockedMintQuote");const{supported:s}=this.getMintInfo().isSupported(20);this.failIf(!s,"Mint does not support NUT-20");const o={unit:this._unit,amount:t,description:n,pubkey:e},i=await this.mint.createMintQuoteBolt11(o);this.failIf(typeof i.pubkey!="string","Mint returned unlocked mint quote");const a=i.pubkey;return{...i,pubkey:a,amount:i.amount||t,unit:i.unit||this._unit}}async createMintQuoteBolt12(t,e){const n=this.getMintInfo();e?.description&&!n.supportsNut04Description("bolt12",this._unit)&&this.fail("Mint does not support description for bolt12");const s={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(s)}async checkMintQuote(t){return this.checkMintQuoteBolt11(t)}async checkMintQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuoteBolt11(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt11(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt12(t,e,n,s,o){return this._mintProofs("bolt12",t,e,{...s,privkey:n},o)}async _mintProofs(t,e,n,s,o){this.assertAmount(e,`_mintProofs: ${t}`),o=o??this.defaultOutputType();const{privkey:i,keysetId:a,proofsWeHave:c,onCountersReserved:u}=s??{},l=this.getKeyset(a);let d=this.configureOutputs(e,l,o,!1,c);const m=this.preparedTotal(d),g=await this.addCountersToOutputTypes(l.id,d);[d]=g.outputTypes,g.used&&this.safeCallback(u,g.used,{op:"mintProofs"}),this._logger.debug("mint counter",{counter:g.used,mintOT:d});const w=this.createOutputData(m,l,d),_=w.map($=>$.blindedMessage),b={outputs:_,quote:typeof n=="string"?n:n.quote};if(typeof n!="string"&&n.pubkey){this.failIf(!i,"Can not sign locked quote without private key");const $=Ui(i,n.quote,_);b.signature=$}let O;return t==="bolt12"?{signatures:O}=await this.mint.mintBolt12(b):{signatures:O}=await this.mint.mintBolt11(b),this.failIf(O.length!==w.length,`Mint returned ${O.length} signatures, expected ${w.length}`),this._logger.debug("MINT COMPLETED",{amounts:w.map($=>$.blindedMessage.amount)}),w.map(($,U)=>$.toProof(O[U],l))}async createMeltQuote(t,e){return this.createMeltQuoteBolt11(t,e)}async createMeltQuoteBolt11(t,e){e!==void 0&&(this.failIf(Zi(t),"amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices."),this.assertAmount(e,"createMeltQuoteBolt11"));const n=this._mintInfo?.supportsAmountless?.("bolt11",this._unit)??!1,s={unit:this._unit,request:t,...n&&e!==void 0?{options:{amountless:{amount_msat:e}}}:{}},o=await this.mint.createMeltQuoteBolt11(s);return{...o,unit:o.unit||this._unit,request:o.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){this.assertAmount(e,"createMultiPathMeltQuote");const{supported:n,params:s}=this.getMintInfo().isSupported(15);this.failIf(!n,"Mint does not support NUT-15"),this.failIf(!s?.some(i=>i.method==="bolt11"&&i.unit===this._unit),`Mint does not support MPP for bolt11 and ${this._unit}`);const o={unit:this._unit,request:t,options:{mpp:{amount:e}}};return{...await this.mint.createMeltQuoteBolt11(o),request:t,unit:this._unit}}async checkMeltQuote(t){return this.checkMeltQuoteBolt11(t)}async checkMeltQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuoteBolt11(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,n,s){return this.meltProofsBolt11(t,e,n,s)}async meltProofsBolt11(t,e,n,s){const o=await this.prepareMelt("bolt11",t,e,n,s),i=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(o,n?.privkey,i)}async meltProofsBolt12(t,e,n,s){const o=await this.prepareMelt("bolt12",t,e,n,s),i=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(o,n?.privkey,i)}async prepareMelt(t,e,n,s,o){o=o??this.defaultOutputType();const{keysetId:i,onChangeOutputsCreated:a,onCountersReserved:c}=s||{},u=this.getKeyset(i),l=Tt(n),d=l-e.amount;let m=[];if(this.failIf(d<0,"Not enough proofs to cover amount + fee reserve",{sendAmount:l,quoteAmount:e.amount}),d>0){let w=Math.ceil(Math.log2(d))||1;w<0&&(w=0);const _=w?new Array(w).fill(0):[];this._logger.debug("Creating NUT-08 blanks for fee reserve",{feeReserve:d,denominations:_}),o.type==="custom"&&this.fail("Custom OutputType not supported for melt change (must be 0-sat blanks)");let b={...o,denominations:_};const O=await this.addCountersToOutputTypes(u.id,b);[b]=O.outputTypes,O.used&&this.safeCallback(c,O.used,{op:"meltProofs"}),this._logger.debug("melt counter",{counter:O.used,meltOT:b}),m=this.createOutputData(0,u,b)}const g={method:t,inputs:n,outputData:m,keysetId:u.id,quote:e};if(m.length>0){const w={method:t,payload:{quote:e.quote,inputs:n,outputs:m.map(_=>_.blindedMessage)},outputData:m,keyset:u,quote:e};this.safeCallback(a,w,{op:"meltProofs"}),this.on._emitMeltBlanksCreated(w)}return g}async completeMelt(t,e,n){this._logger.debug("meltPreview",{meltPreview:t}),t=this.maybeConvertMeltBlanks(t),this._logger.debug("meltPreview post covert",{meltPreview:t});let s=t.inputs;this._logger.debug("inputs",{inputs:s});const o=t.outputData.map(d=>d.blindedMessage),i=t.quote.quote,a=this.getKeyset(t.keysetId);e&&(s=this.signP2PKProofs(s,e,t.outputData,i)),s=this._prepareInputsForMint(s),this._logger.debug("inputs post prepare",{inputs:s});const c={quote:i,inputs:s,outputs:o},u=t.method==="bolt11"?await this.mint.meltBolt11(c,{preferAsync:n}):await this.mint.melt(t.method,c,{preferAsync:n});this.failIf((u.change?.length??0)>t.outputData.length,`Mint returned ${u.change?.length??0} signatures, but only ${t.outputData.length} blanks were provided`);const l=u.change?.map((d,m)=>t.outputData[m].toProof(d,a))??[];return n?this._logger.debug("ASYNC MELT REQUESTED",u):this._logger.debug("MELT COMPLETED",{changeAmounts:l.map(d=>d.amount)}),{quote:{...t.quote,...u},change:l}}maybeConvertMeltBlanks(t){if(!("payload"in t))return t;this._logger.warn("MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.");const{method:e,payload:n,outputData:s,keyset:o,quote:i}=t;return{method:e,inputs:n.inputs,outputData:s,keysetId:o.id,quote:i}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(i=>Ae(e.encode(i.secret)).toHex(!0)),s=100,o=[];for(let i=0;i<n.length;i+=s){const a=n.slice(i,i+s),{states:c}=await this.mint.check({Ys:a}),u={};c.forEach(l=>{u[l.Y]=l});for(let l=0;l<a.length;l++){const d=u[a[l]];this.failIfNullish(d,"Could not find state for proof with Y: "+a[l]),o.push(d)}}return o}async groupProofsByState(t){const e=await this.checkProofsStates(t),n={unspent:[],pending:[],spent:[]};for(let s=0;s<e.length;s++){const o=t[s];switch(e[s].state){case gn.UNSPENT:n.unspent.push(o);break;case gn.PENDING:n.pending.push(o);break;case gn.SPENT:n.spent.push(o);break}}return n}}var xn={};(function r(t,e,n,s){var o=!!(t.Worker&&t.Blob&&t.Promise&&t.OffscreenCanvas&&t.OffscreenCanvasRenderingContext2D&&t.HTMLCanvasElement&&t.HTMLCanvasElement.prototype.transferControlToOffscreen&&t.URL&&t.URL.createObjectURL),i=typeof Path2D=="function"&&typeof DOMMatrix=="function",a=(function(){if(!t.OffscreenCanvas)return!1;try{var f=new OffscreenCanvas(1,1),h=f.getContext("2d");h.fillRect(0,0,1,1);var k=f.transferToImageBitmap();h.createPattern(k,"no-repeat")}catch{return!1}return!0})();function c(){}function u(f){var h=e.exports.Promise,k=h!==void 0?h:t.Promise;return typeof k=="function"?new k(f):(f(c,c),null)}var l=(function(f,h){return{transform:function(k){if(f)return k;if(h.has(k))return h.get(k);var S=new OffscreenCanvas(k.width,k.height),T=S.getContext("2d");return T.drawImage(k,0,0),h.set(k,S),S},clear:function(){h.clear()}}})(a,new Map),d=(function(){var f=Math.floor(16.666666666666668),h,k,S={},T=0;return typeof requestAnimationFrame=="function"&&typeof cancelAnimationFrame=="function"?(h=function(A){var q=Math.random();return S[q]=requestAnimationFrame(function P(F){T===F||T+f-1<F?(T=F,delete S[q],A()):S[q]=requestAnimationFrame(P)}),q},k=function(A){S[A]&&cancelAnimationFrame(S[A])}):(h=function(A){return setTimeout(A,f)},k=function(A){return clearTimeout(A)}),{frame:h,cancel:k}})(),m=(function(){var f,h,k={};function S(T){function A(q,P){T.postMessage({options:q||{},callback:P})}T.init=function(P){var F=P.transferControlToOffscreen();T.postMessage({canvas:F},[F])},T.fire=function(P,F,L){if(h)return A(P,null),h;var H=Math.random().toString(36).slice(2);return h=u(function(V){function X(et){et.data.callback===H&&(delete k[H],T.removeEventListener("message",X),h=null,l.clear(),L(),V())}T.addEventListener("message",X),A(P,H),k[H]=X.bind(null,{data:{callback:H}})}),h},T.reset=function(){T.postMessage({reset:!0});for(var P in k)k[P](),delete k[P]}}return function(){if(f)return f;if(!n&&o){var T=["var CONFETTI, SIZE = {}, module = {};","("+r.toString()+")(this, module, true, SIZE);","onmessage = function(msg) {","  if (msg.data.options) {","    CONFETTI(msg.data.options).then(function () {","      if (msg.data.callback) {","        postMessage({ callback: msg.data.callback });","      }","    });","  } else if (msg.data.reset) {","    CONFETTI && CONFETTI.reset();","  } else if (msg.data.resize) {","    SIZE.width = msg.data.resize.width;","    SIZE.height = msg.data.resize.height;","  } else if (msg.data.canvas) {","    SIZE.width = msg.data.canvas.width;","    SIZE.height = msg.data.canvas.height;","    CONFETTI = module.exports.create(msg.data.canvas);","  }","}"].join(`
`);try{f=new Worker(URL.createObjectURL(new Blob([T])))}catch(A){return typeof console<"u"&&typeof console.warn=="function"&&console.warn("ðŸŽŠ Could not load worker",A),null}S(f)}return f}})(),g={particleCount:50,angle:90,spread:45,startVelocity:45,decay:.9,gravity:1,drift:0,ticks:200,x:.5,y:.5,shapes:["square","circle"],zIndex:100,colors:["#26ccff","#a25afd","#ff5e7e","#88ff5a","#fcff42","#ffa62d","#ff36ff"],disableForReducedMotion:!1,scalar:1};function w(f,h){return h?h(f):f}function _(f){return f!=null}function b(f,h,k){return w(f&&_(f[h])?f[h]:g[h],k)}function O(f){return f<0?0:Math.floor(f)}function $(f,h){return Math.floor(Math.random()*(h-f))+f}function U(f){return parseInt(f,16)}function R(f){return f.map(j)}function j(f){var h=String(f).replace(/[^0-9a-f]/gi,"");return h.length<6&&(h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2]),{r:U(h.substring(0,2)),g:U(h.substring(2,4)),b:U(h.substring(4,6))}}function Y(f){var h=b(f,"origin",Object);return h.x=b(h,"x",Number),h.y=b(h,"y",Number),h}function N(f){f.width=document.documentElement.clientWidth,f.height=document.documentElement.clientHeight}function M(f){var h=f.getBoundingClientRect();f.width=h.width,f.height=h.height}function B(f){var h=document.createElement("canvas");return h.style.position="fixed",h.style.top="0px",h.style.left="0px",h.style.pointerEvents="none",h.style.zIndex=f,h}function K(f,h,k,S,T,A,q,P,F){f.save(),f.translate(h,k),f.rotate(A),f.scale(S,T),f.arc(0,0,1,q,P,F),f.restore()}function J(f){var h=f.angle*(Math.PI/180),k=f.spread*(Math.PI/180);return{x:f.x,y:f.y,wobble:Math.random()*10,wobbleSpeed:Math.min(.11,Math.random()*.1+.05),velocity:f.startVelocity*.5+Math.random()*f.startVelocity,angle2D:-h+(.5*k-Math.random()*k),tiltAngle:(Math.random()*(.75-.25)+.25)*Math.PI,color:f.color,shape:f.shape,tick:0,totalTicks:f.ticks,decay:f.decay,drift:f.drift,random:Math.random()+2,tiltSin:0,tiltCos:0,wobbleX:0,wobbleY:0,gravity:f.gravity*3,ovalScalar:.6,scalar:f.scalar,flat:f.flat}}function D(f,h){h.x+=Math.cos(h.angle2D)*h.velocity+h.drift,h.y+=Math.sin(h.angle2D)*h.velocity+h.gravity,h.velocity*=h.decay,h.flat?(h.wobble=0,h.wobbleX=h.x+10*h.scalar,h.wobbleY=h.y+10*h.scalar,h.tiltSin=0,h.tiltCos=0,h.random=1):(h.wobble+=h.wobbleSpeed,h.wobbleX=h.x+10*h.scalar*Math.cos(h.wobble),h.wobbleY=h.y+10*h.scalar*Math.sin(h.wobble),h.tiltAngle+=.1,h.tiltSin=Math.sin(h.tiltAngle),h.tiltCos=Math.cos(h.tiltAngle),h.random=Math.random()+2);var k=h.tick++/h.totalTicks,S=h.x+h.random*h.tiltCos,T=h.y+h.random*h.tiltSin,A=h.wobbleX+h.random*h.tiltCos,q=h.wobbleY+h.random*h.tiltSin;if(f.fillStyle="rgba("+h.color.r+", "+h.color.g+", "+h.color.b+", "+(1-k)+")",f.beginPath(),i&&h.shape.type==="path"&&typeof h.shape.path=="string"&&Array.isArray(h.shape.matrix))f.fill(v(h.shape.path,h.shape.matrix,h.x,h.y,Math.abs(A-S)*.1,Math.abs(q-T)*.1,Math.PI/10*h.wobble));else if(h.shape.type==="bitmap"){var P=Math.PI/10*h.wobble,F=Math.abs(A-S)*.1,L=Math.abs(q-T)*.1,H=h.shape.bitmap.width*h.scalar,V=h.shape.bitmap.height*h.scalar,X=new DOMMatrix([Math.cos(P)*F,Math.sin(P)*F,-Math.sin(P)*L,Math.cos(P)*L,h.x,h.y]);X.multiplySelf(new DOMMatrix(h.shape.matrix));var et=f.createPattern(l.transform(h.shape.bitmap),"no-repeat");et.setTransform(X),f.globalAlpha=1-k,f.fillStyle=et,f.fillRect(h.x-H/2,h.y-V/2,H,V),f.globalAlpha=1}else if(h.shape==="circle")f.ellipse?f.ellipse(h.x,h.y,Math.abs(A-S)*h.ovalScalar,Math.abs(q-T)*h.ovalScalar,Math.PI/10*h.wobble,0,2*Math.PI):K(f,h.x,h.y,Math.abs(A-S)*h.ovalScalar,Math.abs(q-T)*h.ovalScalar,Math.PI/10*h.wobble,0,2*Math.PI);else if(h.shape==="star")for(var z=Math.PI/2*3,at=4*h.scalar,dt=8*h.scalar,pt=h.x,Et=h.y,Kt=5,wt=Math.PI/Kt;Kt--;)pt=h.x+Math.cos(z)*dt,Et=h.y+Math.sin(z)*dt,f.lineTo(pt,Et),z+=wt,pt=h.x+Math.cos(z)*at,Et=h.y+Math.sin(z)*at,f.lineTo(pt,Et),z+=wt;else f.moveTo(Math.floor(h.x),Math.floor(h.y)),f.lineTo(Math.floor(h.wobbleX),Math.floor(T)),f.lineTo(Math.floor(A),Math.floor(q)),f.lineTo(Math.floor(S),Math.floor(h.wobbleY));return f.closePath(),f.fill(),h.tick<h.totalTicks}function E(f,h,k,S,T){var A=h.slice(),q=f.getContext("2d"),P,F,L=u(function(H){function V(){P=F=null,q.clearRect(0,0,S.width,S.height),l.clear(),T(),H()}function X(){n&&!(S.width===s.width&&S.height===s.height)&&(S.width=f.width=s.width,S.height=f.height=s.height),!S.width&&!S.height&&(k(f),S.width=f.width,S.height=f.height),q.clearRect(0,0,S.width,S.height),A=A.filter(function(et){return D(q,et)}),A.length?P=d.frame(X):V()}P=d.frame(X),F=V});return{addFettis:function(H){return A=A.concat(H),L},canvas:f,promise:L,reset:function(){P&&d.cancel(P),F&&F()}}}function x(f,h){var k=!f,S=!!b(h||{},"resize"),T=!1,A=b(h,"disableForReducedMotion",Boolean),q=o&&!!b(h||{},"useWorker"),P=q?m():null,F=k?N:M,L=f&&P?!!f.__confetti_initialized:!1,H=typeof matchMedia=="function"&&matchMedia("(prefers-reduced-motion)").matches,V;function X(z,at,dt){for(var pt=b(z,"particleCount",O),Et=b(z,"angle",Number),Kt=b(z,"spread",Number),wt=b(z,"startVelocity",Number),pa=b(z,"decay",Number),ga=b(z,"gravity",Number),ma=b(z,"drift",Number),hs=b(z,"colors",R),ya=b(z,"ticks",Number),fs=b(z,"shapes"),wa=b(z,"scalar"),ba=!!b(z,"flat"),ds=Y(z),ps=pt,Sn=[],va=f.width*ds.x,ka=f.height*ds.y;ps--;)Sn.push(J({x:va,y:ka,angle:Et,spread:Kt,startVelocity:wt,color:hs[ps%hs.length],shape:fs[$(0,fs.length)],ticks:ya,decay:pa,gravity:ga,drift:ma,scalar:wa,flat:ba}));return V?V.addFettis(Sn):(V=E(f,Sn,F,at,dt),V.promise)}function et(z){var at=A||b(z,"disableForReducedMotion",Boolean),dt=b(z,"zIndex",Number);if(at&&H)return u(function(wt){wt()});k&&V?f=V.canvas:k&&!f&&(f=B(dt),document.body.appendChild(f)),S&&!L&&F(f);var pt={width:f.width,height:f.height};P&&!L&&P.init(f),L=!0,P&&(f.__confetti_initialized=!0);function Et(){if(P){var wt={getBoundingClientRect:function(){if(!k)return f.getBoundingClientRect()}};F(wt),P.postMessage({resize:{width:wt.width,height:wt.height}});return}pt.width=pt.height=null}function Kt(){V=null,S&&(T=!1,t.removeEventListener("resize",Et)),k&&f&&(document.body.contains(f)&&document.body.removeChild(f),f=null,L=!1)}return S&&!T&&(T=!0,t.addEventListener("resize",Et,!1)),P?P.fire(z,pt,Kt):X(z,pt,Kt)}return et.reset=function(){P&&P.reset(),V&&V.reset()},et}var p;function y(){return p||(p=x(null,{useWorker:!0,resize:!0})),p}function v(f,h,k,S,T,A,q){var P=new Path2D(f),F=new Path2D;F.addPath(P,new DOMMatrix(h));var L=new Path2D;return L.addPath(F,new DOMMatrix([Math.cos(q)*T,Math.sin(q)*T,-Math.sin(q)*A,Math.cos(q)*A,k,S])),L}function I(f){if(!i)throw new Error("path confetti are not supported in this browser");var h,k;typeof f=="string"?h=f:(h=f.path,k=f.matrix);var S=new Path2D(h),T=document.createElement("canvas"),A=T.getContext("2d");if(!k){for(var q=1e3,P=q,F=q,L=0,H=0,V,X,et=0;et<q;et+=2)for(var z=0;z<q;z+=2)A.isPointInPath(S,et,z,"nonzero")&&(P=Math.min(P,et),F=Math.min(F,z),L=Math.max(L,et),H=Math.max(H,z));V=L-P,X=H-F;var at=10,dt=Math.min(at/V,at/X);k=[dt,0,0,dt,-Math.round(V/2+P)*dt,-Math.round(X/2+F)*dt]}return{type:"path",path:h,matrix:k}}function C(f){var h,k=1,S="#000000",T='"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';typeof f=="string"?h=f:(h=f.text,k="scalar"in f?f.scalar:k,T="fontFamily"in f?f.fontFamily:T,S="color"in f?f.color:S);var A=10*k,q=""+A+"px "+T,P=new OffscreenCanvas(A,A),F=P.getContext("2d");F.font=q;var L=F.measureText(h),H=Math.ceil(L.actualBoundingBoxRight+L.actualBoundingBoxLeft),V=Math.ceil(L.actualBoundingBoxAscent+L.actualBoundingBoxDescent),X=2,et=L.actualBoundingBoxLeft+X,z=L.actualBoundingBoxAscent+X;H+=X+X,V+=X+X,P=new OffscreenCanvas(H,V),F=P.getContext("2d"),F.font=q,F.fillStyle=S,F.fillText(h,et,z);var at=1/k;return{type:"bitmap",bitmap:P.transferToImageBitmap(),matrix:[at,0,0,at,-H*at/2,-V*at/2]}}e.exports=function(){return y().apply(this,arguments)},e.exports.reset=function(){y().reset()},e.exports.create=x,e.exports.shapeFromPath=I,e.exports.shapeFromText=C})((function(){return typeof window<"u"?window:typeof self<"u"?self:this||{}})(),xn,!1);const _n=xn.exports;xn.exports.create;async function la(r){if(!r)return Promise.resolve(!1);if(navigator.clipboard&&navigator.clipboard.writeText)return navigator.clipboard.writeText(r).then(()=>!0).catch(()=>!1);try{const t=document.createElement("textarea");t.value=r,t.style.top="0",t.style.left="0",t.style.position="fixed",document.body.appendChild(t),t.focus(),t.select();const e=document.execCommand("copy");return document.body.removeChild(t),Promise.resolve(!!e)}catch{return Promise.resolve(!1)}}function ha(){var r=250,t=Date.now()+r;(function e(){_n({particleCount:7,angle:60,spread:55,origin:{x:0}}),_n({particleCount:7,angle:120,spread:55,origin:{x:1}}),Date.now()<t&&requestAnimationFrame(e)})(),_n.reset()}const ut=r=>new Promise(t=>setTimeout(t,r));function is(r,t="Unknown error"){return r instanceof Error?r.message:typeof r=="string"?r:r&&typeof r=="object"&&"message"in r?String(r.message):t}const Pt=new AbortController;window.addEventListener("pagehide",()=>Pt.abort(),{once:!0}),window.addEventListener("beforeunload",()=>Pt.abort(),{once:!0});const In=new Map;function as(r,t="sat"){const e=`${String(r).replace(/\/+$/,"")}|${t}`,n=In.get(e);if(n)return n;const s=(async()=>{const o=new En(r,{unit:t,logger:new Mo("debug")});return await o.loadMint(),o})();return s.catch(()=>In.delete(e)),In.set(e,s),s}function fa(r){const t=Number(r.data("order-id")),e=String(r.data("order-key")??""),n=String(r.data("return-url")??""),s=Number(r.data("pay-amount-sats")??0),o=String(r.data("melt-quote-id")??""),i=Number(r.data("spot-quote-expiry")??0)*1e3,a=String(r.data("trusted-mint")??"");if(!Number.isFinite(t)||t<=0||!e||!n||!a||!Number.isFinite(s)||s<=0||!o)throw new Error("Bad order data");return{orderId:t,orderKey:e,returnUrl:n,expectedPaySats:s,quoteId:o,quoteExpiryMs:i,trustedMint:a}}function An(r,t){try{const e=new URL(r),n=new URL(t),s=e.origin+e.pathname.replace(/\/+$/,""),o=n.origin+n.pathname.replace(/\/+$/,"");return s===o}catch{return r.replace(/\/+$/,"")===t.replace(/\/+$/,"")}}function cs(r){try{const t=localStorage.getItem(r);return t?JSON.parse(t):null}catch{return null}}function us(r,t){try{localStorage.setItem(r,JSON.stringify(t))}catch{}}function ls(r){try{localStorage.removeItem(r)}catch{}}function da(r){try{const t=cs(r);return!t||!Array.isArray(t.items)||Date.now()-t.created>3600*1e3?{v:1,created:Date.now(),items:[]}:t}catch{return{v:1,created:Date.now(),items:[]}}}jQuery(function(r){const t=r("#cashu-pay-root");if(!t.length)return;const e=t.next("section.cashu-checkout");if(!e.length)return;const n=e.find("form.cashu-token"),s=e.find("[data-cashu-token-input]"),o=n.find('button[type="submit"]'),i=e.find(".cashu-status"),a=e.find("[data-cashu-qr]"),c=(p,y=!1)=>{const v=y?"var(--cashu-warning)":"var(--cashu-status)";i.text(p).css("background-color",v)},u=p=>{o.prop("disabled",p),s.prop("disabled",p)};u(!1),n.off("submit").on("submit",p=>{p.preventDefault();const y=b();if(!y){c("Paste a Cashu token first...",!0);return}R(()=>N(y),{user:!0})});let l;try{l=fa(t)}catch{i.text("Payment data incomplete, please refresh and try again.");return}let d=null,m=Promise.resolve(),g=null,w=0;const _=as(l.trustedMint,"sat"),b=()=>String(s.val()??"").trim(),O={mq:"cashu_wc_mq",change:"cashu_wc_change",recovery:"cashu_wc_recovery"};try{ls(O.change)}catch{}$().catch(()=>{c("Could not prepare the invoice, please refresh and try again",!0)});async function $(){U(),x(),K();const p=localStorage.getItem(O.recovery);p&&N(p).catch(y=>{console.error(y),c("Payment failed. Please copy the new token from the form input below.",!0),s.val(p),localStorage.removeItem(O.recovery)})}async function U(){const p=await M(),y=a.get(0);if(!y||typeof QRCode>"u")return;y.innerHTML="",new QRCode(y,{text:"lightning:"+p.request,width:360,height:360,colorDark:"#000000",colorLight:"#ffffff",correctLevel:QRCode.CorrectLevel.Q}),a.parent().off("click").on("click",async()=>{la(p.request),c("Copied!"),await ut(500),c("Waiting for payment...")})}async function R(p,y={}){const v=!!y.user;if(v&&w>0)return c("Payment already in progress",!0),Promise.resolve(void 0);v&&(w++,w===1&&u(!0));const I=m.then(p).catch(C=>{const f=is(C);c(f,!0)});m=I.then(()=>{});try{return await I}finally{v&&(w--,w===0&&u(!1))}}async function j(p,y){if(p.length<1)return;const v=Tt(p),I=y.getFeesForProofs(p),C=Vr({mint:y.mint.mintUrl,proofs:p,unit:"sat"}),f=An(y.mint.mintUrl,l.trustedMint)?"Change From Network Fee Reserve":"Change From Your Token";Y({mint:y.mint.mintUrl,token:C,amount:v,kind:f,dust:v<=I})}function Y(p){const y=da(O.change);y.items.some(I=>I.token===p.token)||y.items.push(p),y.items=y.items.slice(-5),us(O.change,y)}async function N(p){c("Checking token..."),await ut(500);let y;try{y=Hi(p)}catch(H){console.error(is(H)),c("That token does not look valid",!0);return}const v=String(y.mint??"").trim(),I=String(y.unit??"sat");if(!v||y.amount===0){c("Token has no spendable proofs",!0);return}if(I!=="sat"){c("This checkout expects sat denominated tokens",!0);return}c("Connecting to mint..."),await ut(500);const C=await as(v,"sat");let h=C.decodeToken(p).proofs;if(!Array.isArray(h)||h.length===0){c("Token has no usable proofs",!0);return}if(An(v,l.trustedMint)){const H=await _;await D(h,H);return}const k=await M(),S=Tt(h),T=C.getFeesForProofs(h);c("Calculating your mintâ€™s fees..."),await ut(500);const A=await C.createMeltQuoteBolt11(k.request),q=A.amount+A.fee_reserve+T,P=A.fee_reserve+T;if(S<q){c(`Token amount (â‚¿${S}) is too small. At least â‚¿${q} is required to cover your mint's fees (â‚¿${P})`,!0);return}c("Sending payment to our mint..."),await ut(500);const F=await C.meltProofsBolt11(A,h),L=Array.isArray(F?.change)?F.change:[];j(L,C),c("Waiting for payment confirmation...")}async function M(){return d||(d=(async()=>{const p=cs(O.mq);if(B(p))return p;const v=await(await _).createMintQuoteBolt11(l.expectedPaySats),I={mint:l.trustedMint,amount:l.expectedPaySats,quote:v.quote,request:v.request,expiry:v.expiry??null};return us(O.mq,I),I})(),d.catch(()=>{d=null}),d)}function B(p){if(!p||!p.quote||!p.request||!p.mint||p.amount!==l.expectedPaySats||!An(p.mint,l.trustedMint))return!1;const y=typeof p.expiry=="number"?p.expiry:0,v=Math.floor(Date.now()/1e3);return!(y>0&&y<=v)}async function K(){const p=await M(),y=await _,v=async()=>{const f=l.quoteExpiryMs-Date.now();if(f<=0||Pt.signal.aborted)return!1;const h=Math.max(1e4,f);try{return await Promise.race([y.on.onceMintPaid(p.quote,{signal:Pt.signal,timeoutMs:h}),ut(f).then(()=>{throw new Error("Quote expired")})]),!0}catch{return!1}},I=async()=>{try{for(;!Pt.signal.aborted&&Date.now()<l.quoteExpiryMs;){if((await y.checkMintQuoteBolt11(p.quote)).state==="PAID")return!0;await ut(3e3)}return!1}catch{return!1}};(await v()||!Pt.signal.aborted&&await I())&&R(()=>J(p))}async function J(p){if(g)return g;g=(async()=>{c("Payment received by our mint..."),await ut(500);const y=await _,v=await y.mintProofsBolt11(l.expectedPaySats,p.quote);ls(O.mq),d=null,await D(v,y)})();try{await g}catch(y){throw g=null,y}}async function D(p,y){const v=Vr({mint:l.trustedMint,proofs:p,unit:"sat"});let I;c("Paying invoice...");try{localStorage.setItem(O.recovery,v);const f=await y.checkMeltQuoteBolt11(l.quoteId);console.log({token:v}),console.log("proofs",p),console.log("mtv quote",f),I=await y.meltProofsBolt11(f,p)}catch(f){console.log(f),s.val(v),c(f,!0);return}finally{localStorage.removeItem(O.recovery)}const C=Array.isArray(I?.change)?I.change:[];j(C,y),c("Confirming payment...")}async function E(){const p=String(window.cashu_wc?.rest_root??""),y=String(window.cashu_wc?.confirm_route??"");if(!p||!y)return null;const v=p.replace(/\/?$/,"/")+y.replace(/^\//,""),I={order_id:l.orderId,order_key:l.orderKey,quote_id:l.quoteId};try{const f=await(await fetch(v,{method:"POST",headers:{"Content-Type":"application/json"},credentials:"same-origin",body:JSON.stringify(I)})).json();return f?.state==="PAID"&&(ha(),await ut(2e3),window.location.assign(String(f.redirect??l.returnUrl))),f?.state==="EXPIRED"&&(c("This payment quote has expired",!0),await ut(2e3),window.location.assign(String(l.returnUrl))),f??null}catch{return null}}async function x(){if(Pt.signal.aborted||Date.now()>l.quoteExpiryMs){window.location.assign(String(l.returnUrl));return}for(;!Pt.signal.aborted&&Date.now()<l.quoteExpiryMs;){await ut(3e3);const p=await R(()=>E());if(p?.state==="PAID"||p?.state==="EXPIRED")return}await ut(3e3),await R(()=>E())}})})();
