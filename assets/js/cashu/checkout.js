(function(){"use strict";function Be(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Bn(r,t){return Array.isArray(t)?t.length===0?!0:r?t.every(e=>typeof e=="string"):t.every(e=>Number.isSafeInteger(e)):!1}function gs(r){if(typeof r!="function")throw new Error("function expected");return!0}function Me(r,t){if(typeof t!="string")throw new Error(`${r}: string expected`);return!0}function Ce(r){if(!Number.isSafeInteger(r))throw new Error(`invalid integer: ${r}`)}function Te(r){if(!Array.isArray(r))throw new Error("array expected")}function Mn(r,t){if(!Bn(!0,t))throw new Error(`${r}: array of strings expected`)}function ms(r,t){if(!Bn(!1,t))throw new Error(`${r}: array of numbers expected`)}function Cn(...r){const t=o=>o,e=(o,i)=>a=>o(i(a)),n=r.map(o=>o.encode).reduceRight(e,t),s=r.map(o=>o.decode).reduce(e,t);return{encode:n,decode:s}}function ys(r){const t=typeof r=="string"?r.split(""):r,e=t.length;Mn("alphabet",t);const n=new Map(t.map((s,o)=>[s,o]));return{encode:s=>(Te(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=e)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${r}`);return t[o]})),decode:s=>(Te(s),s.map(o=>{Me("alphabet.decode",o);const i=n.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${r}`);return i}))}}function ws(r=""){return Me("join",r),{encode:t=>(Mn("join.decode",t),t.join(r)),decode:t=>(Me("join.decode",t),t.split(r))}}function Tn(r,t,e){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(e<2)throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);if(Te(r),!r.length)return[];let n=0;const s=[],o=Array.from(r,a=>{if(Ce(a),a<0||a>=t)throw new Error(`invalid integer: ${a}`);return a}),i=o.length;for(;;){let a=0,c=!0;for(let l=n;l<i;l++){const h=o[l],d=t*a,g=d+h;if(!Number.isSafeInteger(g)||d/t!==a||g-h!==d)throw new Error("convertRadix: carry overflow");const p=g/e;a=g%e;const y=Math.floor(p);if(o[l]=y,!Number.isSafeInteger(y)||y*e+a!==g)throw new Error("convertRadix: carry overflow");if(c)y?c=!1:n=l;else continue}if(s.push(a),c)break}for(let a=0;a<r.length-1&&r[a]===0;a++)s.push(0);return s.reverse()}function bs(r){Ce(r);const t=2**8;return{encode:e=>{if(!Be(e))throw new Error("radix.encode input should be Uint8Array");return Tn(Array.from(e),t,r)},decode:e=>(ms("radix.decode",e),Uint8Array.from(Tn(e,r,t)))}}function vs(r,t){return Ce(r),gs(t),{encode(e){if(!Be(e))throw new Error("checksum.encode: input should be Uint8Array");const n=t(e).slice(0,r),s=new Uint8Array(e.length+r);return s.set(e),s.set(n,e.length),s},decode(e){if(!Be(e))throw new Error("checksum.decode: input should be Uint8Array");const n=e.slice(0,-r),s=e.slice(-r),o=t(n).slice(0,r);for(let i=0;i<r;i++)if(o[i]!==s[i])throw new Error("Invalid checksum");return n}}}const ks=(r=>Cn(bs(58),ys(r),ws("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Es=r=>Cn(vs(4,t=>r(r(t))),ks);function Pe(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ot(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function V(r,t,e=""){const n=Pe(r),s=r?.length,o=t!==void 0;if(!n||o&&s!==t){const i=e&&`"${e}" `,a=o?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(i+"expected Uint8Array"+a+", got "+c)}return r}function Pn(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Ot(r.outputLen),Ot(r.blockLen)}function ae(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function xs(r,t){V(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function xt(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function $t(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function gt(r,t){return r<<32-t|r>>>t}function ce(r,t){return r<<t|r>>>32-t>>>0}const On=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",_s=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function tt(r){if(V(r),On)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=_s[r[e]];return t}const bt={_0:48,_9:57,A:65,F:70,a:97,f:102};function qn(r){if(r>=bt._0&&r<=bt._9)return r-bt._0;if(r>=bt.A&&r<=bt.F)return r-(bt.A-10);if(r>=bt.a&&r<=bt.f)return r-(bt.a-10)}function G(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(On)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const i=qn(r.charCodeAt(o)),a=qn(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function Nn(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function ot(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];V(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const o=r[n];e.set(o,s),s+=o.length}return e}function Oe(r,t={}){const e=(s,o)=>r(o).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function qt(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const Un=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Is(r,t,e){return r&t^~r&e}function As(r,t,e){return r&t^r&e^t&e}class qe{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,e,n,s){this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=$t(this.buffer)}update(t){ae(this),V(t);const{view:e,buffer:n,blockLen:s}=this,o=t.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=$t(t);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ae(this),xs(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;e[i++]=128,xt(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(n,0),i=0);for(let d=i;d<s;d++)e[d]=0;n.setBigUint64(s-8,BigInt(this.length*8),o),this.process(n,0);const a=$t(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,h=this.get();if(l>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,h[d],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return t.destroyed=i,t.finished=o,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const _t=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),rt=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),ue=BigInt(2**32-1),Dn=BigInt(32);function Ss(r,t=!1){return t?{h:Number(r&ue),l:Number(r>>Dn&ue)}:{h:Number(r>>Dn&ue)|0,l:Number(r&ue)|0}}function Bs(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let o=0;o<e;o++){const{h:i,l:a}=Ss(r[o],t);[n[o],s[o]]=[i,a]}return[n,s]}const Rn=(r,t,e)=>r>>>e,Ln=(r,t,e)=>r<<32-e|t>>>e,Ht=(r,t,e)=>r>>>e|t<<32-e,jt=(r,t,e)=>r<<32-e|t>>>e,le=(r,t,e)=>r<<64-e|t>>>e-32,he=(r,t,e)=>r>>>e-32|t<<64-e;function vt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Ms=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Cs=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Ts=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Ps=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Os=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),qs=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0,Ns=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),It=new Uint32Array(64);class Us extends qe{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[t,e,n,s,o,i,a,c]}set(t,e,n,s,o,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let d=0;d<16;d++,e+=4)It[d]=t.getUint32(e,!1);for(let d=16;d<64;d++){const g=It[d-15],p=It[d-2],y=gt(g,7)^gt(g,18)^g>>>3,I=gt(p,17)^gt(p,19)^p>>>10;It[d]=I+It[d-7]+y+It[d-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:l,H:h}=this;for(let d=0;d<64;d++){const g=gt(a,6)^gt(a,11)^gt(a,25),p=h+g+Is(a,c,l)+Ns[d]+It[d]|0,I=(gt(n,2)^gt(n,13)^gt(n,22))+As(n,s,o)|0;h=l,l=c,c=a,a=i+p|0,i=o,o=s,s=n,n=p+I|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,h=h+this.H|0,this.set(n,s,o,i,a,c,l,h)}roundClean(){xt(It)}destroy(){this.set(0,0,0,0,0,0,0,0),xt(this.buffer)}}class Ds extends Us{A=_t[0]|0;B=_t[1]|0;C=_t[2]|0;D=_t[3]|0;E=_t[4]|0;F=_t[5]|0;G=_t[6]|0;H=_t[7]|0;constructor(){super(32)}}const Fn=Bs(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Rs=Fn[0],Ls=Fn[1],At=new Uint32Array(80),St=new Uint32Array(80);class Fs extends qe{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:l,El:h,Fh:d,Fl:g,Gh:p,Gl:y,Hh:I,Hl:k}=this;return[t,e,n,s,o,i,a,c,l,h,d,g,p,y,I,k]}set(t,e,n,s,o,i,a,c,l,h,d,g,p,y,I,k){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=h|0,this.Fh=d|0,this.Fl=g|0,this.Gh=p|0,this.Gl=y|0,this.Hh=I|0,this.Hl=k|0}process(t,e){for(let U=0;U<16;U++,e+=4)At[U]=t.getUint32(e),St[U]=t.getUint32(e+=4);for(let U=16;U<80;U++){const R=At[U-15]|0,j=St[U-15]|0,Y=Ht(R,j,1)^Ht(R,j,8)^Rn(R,j,7),N=jt(R,j,1)^jt(R,j,8)^Ln(R,j,7),C=At[U-2]|0,M=St[U-2]|0,K=Ht(C,M,19)^le(C,M,61)^Rn(C,M,6),J=jt(C,M,19)^he(C,M,61)^Ln(C,M,6),L=Ts(N,J,St[U-7],St[U-16]),E=Ps(L,Y,K,At[U-7],At[U-16]);At[U]=E|0,St[U]=L|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:l,Dl:h,Eh:d,El:g,Fh:p,Fl:y,Gh:I,Gl:k,Hh:O,Hl:$}=this;for(let U=0;U<80;U++){const R=Ht(d,g,14)^Ht(d,g,18)^le(d,g,41),j=jt(d,g,14)^jt(d,g,18)^he(d,g,41),Y=d&p^~d&I,N=g&y^~g&k,C=Os($,j,N,Ls[U],St[U]),M=qs(C,O,R,Y,Rs[U],At[U]),K=C|0,J=Ht(n,s,28)^le(n,s,34)^le(n,s,39),L=jt(n,s,28)^he(n,s,34)^he(n,s,39),E=n&o^n&a^o&a,x=s&i^s&c^i&c;O=I|0,$=k|0,I=p|0,k=y|0,p=d|0,y=g|0,{h:d,l:g}=vt(l|0,h|0,M|0,K|0),l=a|0,h=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const w=Ms(K,L,x);n=Cs(w,M,J,E),s=w|0}({h:n,l:s}=vt(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=vt(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=vt(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:h}=vt(this.Dh|0,this.Dl|0,l|0,h|0),{h:d,l:g}=vt(this.Eh|0,this.El|0,d|0,g|0),{h:p,l:y}=vt(this.Fh|0,this.Fl|0,p|0,y|0),{h:I,l:k}=vt(this.Gh|0,this.Gl|0,I|0,k|0),{h:O,l:$}=vt(this.Hh|0,this.Hl|0,O|0,$|0),this.set(n,s,o,i,a,c,l,h,d,g,p,y,I,k,O,$)}roundClean(){xt(At,St)}destroy(){xt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Ks extends Fs{Ah=rt[0]|0;Al=rt[1]|0;Bh=rt[2]|0;Bl=rt[3]|0;Ch=rt[4]|0;Cl=rt[5]|0;Dh=rt[6]|0;Dl=rt[7]|0;Eh=rt[8]|0;El=rt[9]|0;Fh=rt[10]|0;Fl=rt[11]|0;Gh=rt[12]|0;Gl=rt[13]|0;Hh=rt[14]|0;Hl=rt[15]|0;constructor(){super(64)}}const nt=Oe(()=>new Ds,Un(1)),Kn=Oe(()=>new Ks,Un(3));const Ne=BigInt(0),Ue=BigInt(1);function fe(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function $n(r){if(typeof r=="bigint"){if(!pe(r))throw new Error("positive bigint expected, got "+r)}else Ot(r);return r}function de(r){const t=$n(r).toString(16);return t.length&1?"0"+t:t}function Hn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ne:BigInt("0x"+r)}function Jt(r){return Hn(tt(r))}function jn(r){return Hn(tt($s(V(r)).reverse()))}function De(r,t){Ot(t),r=$n(r);const e=G(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function Wn(r,t){return De(r,t).reverse()}function $s(r){return Uint8Array.from(r)}function Hs(r){return Uint8Array.from(r,(t,e)=>{const n=t.charCodeAt(0);if(t.length!==1||n>127)throw new Error(`string contains non-ASCII character "${r[e]}" with code ${n} at position ${e}`);return n})}const pe=r=>typeof r=="bigint"&&Ne<=r;function js(r,t,e){return pe(r)&&pe(t)&&pe(e)&&t<=r&&r<e}function Ws(r,t,e,n){if(!js(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function zs(r){let t;for(t=0;r>Ne;r>>=Ue,t+=1);return t}const Re=r=>(Ue<<BigInt(r))-Ue;function Qs(r,t,e){if(Ot(r,"hashLen"),Ot(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=k=>new Uint8Array(k),s=Uint8Array.of(),o=Uint8Array.of(0),i=Uint8Array.of(1),a=1e3;let c=n(r),l=n(r),h=0;const d=()=>{c.fill(1),l.fill(0),h=0},g=(...k)=>e(l,ot(c,...k)),p=(k=s)=>{l=g(o,k),c=g(),k.length!==0&&(l=g(i,k),c=g())},y=()=>{if(h++>=a)throw new Error("drbg: tried max amount of iterations");let k=0;const O=[];for(;k<t;){c=g();const $=c.slice();O.push($),k+=c.length}return ot(...O)};return(k,O)=>{d(),p(k);let $;for(;!($=O(y()));)p();return d(),$}}function Le(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(o,i,a){const c=r[o];if(a&&c===void 0)return;const l=typeof c;if(l!==i||c===null)throw new Error(`param "${o}" is invalid: expected ${i}, got ${l}`)}const s=(o,i)=>Object.entries(o).forEach(([a,c])=>n(a,c,i));s(t,!1),s(e,!0)}function zn(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const o=r(e,...n);return t.set(e,o),o}}const it=BigInt(0),st=BigInt(1),Nt=BigInt(2),Qn=BigInt(3),Vn=BigInt(4),Zn=BigInt(5),Vs=BigInt(7),Gn=BigInt(8),Zs=BigInt(9),Yn=BigInt(16);function lt(r,t){const e=r%t;return e>=it?e:t+e}function ct(r,t,e){let n=r;for(;t-- >it;)n*=n,n%=e;return n}function Jn(r,t){if(r===it)throw new Error("invert: expected non-zero number");if(t<=it)throw new Error("invert: expected positive modulus, got "+t);let e=lt(r,t),n=t,s=it,o=st;for(;e!==it;){const a=n/e,c=n%e,l=s-o*a;n=e,e=c,s=o,o=l}if(n!==st)throw new Error("invert: does not exist");return lt(s,t)}function Fe(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function Xn(r,t){const e=(r.ORDER+st)/Vn,n=r.pow(t,e);return Fe(r,n,t),n}function Gs(r,t){const e=(r.ORDER-Zn)/Gn,n=r.mul(t,Nt),s=r.pow(n,e),o=r.mul(t,s),i=r.mul(r.mul(o,Nt),s),a=r.mul(o,r.sub(i,r.ONE));return Fe(r,a,t),a}function Ys(r){const t=ge(r),e=tr(r),n=e(t,t.neg(t.ONE)),s=e(t,n),o=e(t,t.neg(n)),i=(r+Vs)/Yn;return(a,c)=>{let l=a.pow(c,i),h=a.mul(l,n);const d=a.mul(l,s),g=a.mul(l,o),p=a.eql(a.sqr(h),c),y=a.eql(a.sqr(d),c);l=a.cmov(l,h,p),h=a.cmov(g,d,y);const I=a.eql(a.sqr(h),c),k=a.cmov(l,h,I);return Fe(a,k,c),k}}function tr(r){if(r<Qn)throw new Error("sqrt is not defined for small field");let t=r-st,e=0;for(;t%Nt===it;)t/=Nt,e++;let n=Nt;const s=ge(r);for(;nr(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Xn;let o=s.pow(n,t);const i=(t+st)/Nt;return function(c,l){if(c.is0(l))return l;if(nr(c,l)!==1)throw new Error("Cannot find square root");let h=e,d=c.mul(c.ONE,o),g=c.pow(l,t),p=c.pow(l,i);for(;!c.eql(g,c.ONE);){if(c.is0(g))return c.ZERO;let y=1,I=c.sqr(g);for(;!c.eql(I,c.ONE);)if(y++,I=c.sqr(I),y===h)throw new Error("Cannot find square root");const k=st<<BigInt(h-y-1),O=c.pow(d,k);h=y,d=c.sqr(O),g=c.mul(g,d),p=c.mul(p,O)}return p}}function Js(r){return r%Vn===Qn?Xn:r%Gn===Zn?Gs:r%Yn===Zs?Ys(r):tr(r)}const Xs=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function to(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=Xs.reduce((n,s)=>(n[s]="function",n),t);return Le(r,e),r}function eo(r,t,e){if(e<it)throw new Error("invalid exponent, negatives unsupported");if(e===it)return r.ONE;if(e===st)return t;let n=r.ONE,s=t;for(;e>it;)e&st&&(n=r.mul(n,s)),s=r.sqr(s),e>>=st;return n}function er(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((i,a,c)=>r.is0(a)?i:(n[c]=i,r.mul(i,a)),r.ONE),o=r.inv(s);return t.reduceRight((i,a,c)=>r.is0(a)?i:(n[c]=r.mul(i,n[c]),r.mul(i,a)),o),n}function nr(r,t){const e=(r.ORDER-st)/Nt,n=r.pow(t,e),s=r.eql(n,r.ONE),o=r.eql(n,r.ZERO),i=r.eql(n,r.neg(r.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function no(r,t){t!==void 0&&Ot(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class ro{ORDER;BITS;BYTES;isLE;ZERO=it;ONE=st;_lengths;_sqrt;_mod;constructor(t,e={}){if(t<=it)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=e.allowedLengths?.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:o}=no(t,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=o,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return lt(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return it<=t&&t<this.ORDER}is0(t){return t===it}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&st)===st}neg(t){return lt(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return lt(t*t,this.ORDER)}add(t,e){return lt(t+e,this.ORDER)}sub(t,e){return lt(t-e,this.ORDER)}mul(t,e){return lt(t*e,this.ORDER)}pow(t,e){return eo(this,t,e)}div(t,e){return lt(t*Jn(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return Jn(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Js(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Wn(t,this.BYTES):De(t,this.BYTES)}fromBytes(t,e=!1){V(t);const{_lengths:n,BYTES:s,isLE:o,ORDER:i,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const l=new Uint8Array(s);l.set(t,o?0:l.length-t.length),t=l}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=o?jn(t):Jt(t);if(a&&(c=lt(c,i)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return er(this,t)}cmov(t,e,n){return n?e:t}}function ge(r,t={}){return new ro(r,t)}function rr(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function sr(r){const t=rr(r);return t+Math.ceil(t/2)}function or(r,t,e=!1){V(r);const n=r.length,s=rr(t),o=sr(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const i=e?jn(r):Jt(r),a=lt(i,t-st)+st;return e?Wn(a,s):De(a,s)}const Wt=BigInt(0),Ut=BigInt(1);function me(r,t){const e=t.negate();return r?e:t}function ir(r,t){const e=er(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function ar(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Ke(r,t){ar(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,o=Re(r),i=BigInt(r);return{windows:e,windowSize:n,mask:o,maxNumber:s,shiftBy:i}}function cr(r,t,e){const{windowSize:n,mask:s,maxNumber:o,shiftBy:i}=e;let a=Number(r&s),c=r>>i;a>n&&(a-=o,c+=Ut);const l=t*n,h=l+Math.abs(a)-1,d=a===0,g=a<0,p=t%2!==0;return{nextN:c,offset:h,isZero:d,isNeg:g,isNegF:p,offsetF:l}}const $e=new WeakMap,ur=new WeakMap;function He(r){return ur.get(r)||1}function lr(r){if(r!==Wt)throw new Error("invalid wNAF")}class so{BASE;ZERO;Fn;bits;constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>Wt;)e&Ut&&(n=n.add(s)),s=s.double(),e>>=Ut;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=Ke(e,this.bits),o=[];let i=t,a=i;for(let c=0;c<n;c++){a=i,o.push(a);for(let l=1;l<s;l++)a=a.add(i),o.push(a);i=a.double()}return o}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const i=Ke(t,this.bits);for(let a=0;a<i.windows;a++){const{nextN:c,offset:l,isZero:h,isNeg:d,isNegF:g,offsetF:p}=cr(n,a,i);n=c,h?o=o.add(me(g,e[p])):s=s.add(me(d,e[l]))}return lr(n),{p:s,f:o}}wNAFUnsafe(t,e,n,s=this.ZERO){const o=Ke(t,this.bits);for(let i=0;i<o.windows&&n!==Wt;i++){const{nextN:a,offset:c,isZero:l,isNeg:h}=cr(n,i,o);if(n=a,!l){const d=e[c];s=s.add(h?d.negate():d)}}return lr(n),s}getPrecomputes(t,e,n){let s=$e.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),$e.set(e,s))),s}cached(t,e,n){const s=He(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const o=He(t);return o===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,s)}createCache(t,e){ar(e,this.bits),ur.set(t,e),$e.delete(t)}hasCache(t){return He(t)!==1}}function oo(r,t,e,n){let s=t,o=r.ZERO,i=r.ZERO;for(;e>Wt||n>Wt;)e&Ut&&(o=o.add(s)),n&Ut&&(i=i.add(s)),s=s.double(),e>>=Ut,n>>=Ut;return{p1:o,p2:i}}function hr(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return to(t),t}else return ge(r,{isLE:e})}function io(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const l=t[c];if(!(typeof l=="bigint"&&l>Wt))throw new Error(`CURVE.${c} must be positive bigint`)}const s=hr(t.p,e.Fp,n),o=hr(t.n,e.Fn,n),a=["Gx","Gy","a","b"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:o}}function fr(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}class dr{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,e){if(Pn(t),V(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),xt(s)}update(t){return ae(this),this.iHash.update(t),this}digestInto(t){ae(this),V(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:e,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=o,t.blockLen=i,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Xt=(r,t,e)=>new dr(r,t).update(e).digest();Xt.create=(r,t)=>new dr(r,t);const pr=(r,t)=>(r+(r>=0?t:-t)/gr)/t;function ao(r,t,e){const[[n,s],[o,i]]=t,a=pr(i*r,e),c=pr(-s*r,e);let l=r-a*n-c*o,h=-a*s-c*i;const d=l<kt,g=h<kt;d&&(l=-l),g&&(h=-h);const p=Re(Math.ceil(zs(e)/2))+zt;if(l<kt||l>=p||h<kt||h>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:d,k1:l,k2neg:g,k2:h}}function je(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function We(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return fe(e.lowS,"lowS"),fe(e.prehash,"prehash"),e.format!==void 0&&je(e.format),e}class co extends Error{constructor(t=""){super(t)}}const Bt={Err:co,_tlv:{encode:(r,t)=>{const{Err:e}=Bt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=de(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=n>127?de(s.length/2|128):"";return de(r)+o+s+t},decode(r,t){const{Err:e}=Bt;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const l=t.subarray(n,n+c);if(l.length!==c)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const h of l)i=i<<8|h;if(n+=c,i<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+i);if(a.length!==i)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+i)}}},_int:{encode(r){const{Err:t}=Bt;if(r<kt)throw new t("integer: negative integers are not allowed");let e=de(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=Bt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Jt(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=Bt,s=V(r,void 0,"signature"),{v:o,l:i}=n.decode(48,s);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:l,l:h}=n.decode(2,c);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(l)}},hexFromSig(r){const{_tlv:t,_int:e}=Bt,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),o=n+s;return t.encode(48,o)}},kt=BigInt(0),zt=BigInt(1),gr=BigInt(2),ye=BigInt(3),uo=BigInt(4);function lo(r,t={}){const e=io("weierstrass",r,t),{Fp:n,Fn:s}=e;let o=e.CURVE;const{h:i,n:a}=o;Le(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=yr(n,s);function h(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(L,E,x){const{x:w,y:m}=E.toAffine(),b=n.toBytes(w);if(fe(x,"isCompressed"),x){h();const _=!n.isOdd(m);return ot(mr(_),b)}else return ot(Uint8Array.of(4),b,n.toBytes(m))}function g(L){V(L,void 0,"Point");const{publicKey:E,publicKeyUncompressed:x}=l,w=L.length,m=L[0],b=L.subarray(1);if(w===E&&(m===2||m===3)){const _=n.fromBytes(b);if(!n.isValid(_))throw new Error("bad point: is not on curve, wrong x");const A=I(_);let f;try{f=n.sqrt(A)}catch(S){const P=S instanceof Error?": "+S.message:"";throw new Error("bad point: is not on curve, sqrt error"+P)}h();const u=n.isOdd(f);return(m&1)===1!==u&&(f=n.neg(f)),{x:_,y:f}}else if(w===x&&m===4){const _=n.BYTES,A=n.fromBytes(b.subarray(0,_)),f=n.fromBytes(b.subarray(_,_*2));if(!k(A,f))throw new Error("bad point: is not on curve");return{x:A,y:f}}else throw new Error(`bad point: got length ${w}, expected compressed=${E} or uncompressed=${x}`)}const p=t.toBytes||d,y=t.fromBytes||g;function I(L){const E=n.sqr(L),x=n.mul(E,L);return n.add(n.add(x,n.mul(L,o.a)),o.b)}function k(L,E){const x=n.sqr(E),w=I(L);return n.eql(x,w)}if(!k(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const O=n.mul(n.pow(o.a,ye),uo),$=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(O,$)))throw new Error("bad curve params: a or b");function U(L,E,x=!1){if(!n.isValid(E)||x&&n.is0(E))throw new Error(`bad point coordinate ${L}`);return E}function R(L){if(!(L instanceof M))throw new Error("Weierstrass Point expected")}function j(L){if(!c||!c.basises)throw new Error("no endo");return ao(L,c.basises,s.ORDER)}const Y=zn((L,E)=>{const{X:x,Y:w,Z:m}=L;if(n.eql(m,n.ONE))return{x,y:w};const b=L.is0();E==null&&(E=b?n.ONE:n.inv(m));const _=n.mul(x,E),A=n.mul(w,E),f=n.mul(m,E);if(b)return{x:n.ZERO,y:n.ZERO};if(!n.eql(f,n.ONE))throw new Error("invZ was invalid");return{x:_,y:A}}),N=zn(L=>{if(L.is0()){if(t.allowInfinityPoint&&!n.is0(L.Y))return;throw new Error("bad point: ZERO")}const{x:E,y:x}=L.toAffine();if(!n.isValid(E)||!n.isValid(x))throw new Error("bad point: x or y not field elements");if(!k(E,x))throw new Error("bad point: equation left != right");if(!L.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function C(L,E,x,w,m){return x=new M(n.mul(x.X,L),x.Y,x.Z),E=me(w,E),x=me(m,x),E.add(x)}class M{static BASE=new M(o.Gx,o.Gy,n.ONE);static ZERO=new M(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=s;X;Y;Z;constructor(E,x,w){this.X=U("x",E),this.Y=U("y",x,!0),this.Z=U("z",w),Object.freeze(this)}static CURVE(){return o}static fromAffine(E){const{x,y:w}=E||{};if(!E||!n.isValid(x)||!n.isValid(w))throw new Error("invalid affine point");if(E instanceof M)throw new Error("projective point not allowed");return n.is0(x)&&n.is0(w)?M.ZERO:new M(x,w,n.ONE)}static fromBytes(E){const x=M.fromAffine(y(V(E,void 0,"point")));return x.assertValidity(),x}static fromHex(E){return M.fromBytes(G(E))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(E=8,x=!0){return J.createCache(this,E),x||this.multiply(ye),this}assertValidity(){N(this)}hasEvenY(){const{y:E}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(E)}equals(E){R(E);const{X:x,Y:w,Z:m}=this,{X:b,Y:_,Z:A}=E,f=n.eql(n.mul(x,A),n.mul(b,m)),u=n.eql(n.mul(w,A),n.mul(_,m));return f&&u}negate(){return new M(this.X,n.neg(this.Y),this.Z)}double(){const{a:E,b:x}=o,w=n.mul(x,ye),{X:m,Y:b,Z:_}=this;let A=n.ZERO,f=n.ZERO,u=n.ZERO,v=n.mul(m,m),S=n.mul(b,b),P=n.mul(_,_),B=n.mul(m,b);return B=n.add(B,B),u=n.mul(m,_),u=n.add(u,u),A=n.mul(E,u),f=n.mul(w,P),f=n.add(A,f),A=n.sub(S,f),f=n.add(S,f),f=n.mul(A,f),A=n.mul(B,A),u=n.mul(w,u),P=n.mul(E,P),B=n.sub(v,P),B=n.mul(E,B),B=n.add(B,u),u=n.add(v,v),v=n.add(u,v),v=n.add(v,P),v=n.mul(v,B),f=n.add(f,v),P=n.mul(b,_),P=n.add(P,P),v=n.mul(P,B),A=n.sub(A,v),u=n.mul(P,S),u=n.add(u,u),u=n.add(u,u),new M(A,f,u)}add(E){R(E);const{X:x,Y:w,Z:m}=this,{X:b,Y:_,Z:A}=E;let f=n.ZERO,u=n.ZERO,v=n.ZERO;const S=o.a,P=n.mul(o.b,ye);let B=n.mul(x,b),q=n.mul(w,_),T=n.mul(m,A),F=n.add(x,w),D=n.add(b,_);F=n.mul(F,D),D=n.add(B,q),F=n.sub(F,D),D=n.add(x,m);let H=n.add(b,A);return D=n.mul(D,H),H=n.add(B,T),D=n.sub(D,H),H=n.add(w,m),f=n.add(_,A),H=n.mul(H,f),f=n.add(q,T),H=n.sub(H,f),v=n.mul(S,D),f=n.mul(P,T),v=n.add(f,v),f=n.sub(q,v),v=n.add(q,v),u=n.mul(f,v),q=n.add(B,B),q=n.add(q,B),T=n.mul(S,T),D=n.mul(P,D),q=n.add(q,T),T=n.sub(B,T),T=n.mul(S,T),D=n.add(D,T),B=n.mul(q,D),u=n.add(u,B),B=n.mul(H,D),f=n.mul(F,f),f=n.sub(f,B),B=n.mul(F,q),v=n.mul(H,v),v=n.add(v,B),new M(f,u,v)}subtract(E){return this.add(E.negate())}is0(){return this.equals(M.ZERO)}multiply(E){const{endo:x}=t;if(!s.isValidNot0(E))throw new Error("invalid scalar: out of range");let w,m;const b=_=>J.cached(this,_,A=>ir(M,A));if(x){const{k1neg:_,k1:A,k2neg:f,k2:u}=j(E),{p:v,f:S}=b(A),{p:P,f:B}=b(u);m=S.add(B),w=C(x.beta,v,P,_,f)}else{const{p:_,f:A}=b(E);w=_,m=A}return ir(M,[w,m])[0]}multiplyUnsafe(E){const{endo:x}=t,w=this;if(!s.isValid(E))throw new Error("invalid scalar: out of range");if(E===kt||w.is0())return M.ZERO;if(E===zt)return w;if(J.hasCache(this))return this.multiply(E);if(x){const{k1neg:m,k1:b,k2neg:_,k2:A}=j(E),{p1:f,p2:u}=oo(M,w,b,A);return C(x.beta,f,u,m,_)}else return J.unsafe(w,E)}toAffine(E){return Y(this,E)}isTorsionFree(){const{isTorsionFree:E}=t;return i===zt?!0:E?E(M,this):J.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:E}=t;return i===zt?this:E?E(M,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(E=!0){return fe(E,"isCompressed"),this.assertValidity(),p(M,this,E)}toHex(E=!0){return tt(this.toBytes(E))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const K=s.BITS,J=new so(M,t.endo?Math.ceil(K/2):K);return M.BASE.precompute(8),M}function mr(r){return Uint8Array.of(r?2:3)}function yr(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ho(r,t={}){const{Fn:e}=r,n=t.randomBytes||qt,s=Object.assign(yr(r.Fp,e),{seed:sr(e.ORDER)});function o(p){try{const y=e.fromBytes(p);return e.isValidNot0(y)}catch{return!1}}function i(p,y){const{publicKey:I,publicKeyUncompressed:k}=s;try{const O=p.length;return y===!0&&O!==I||y===!1&&O!==k?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return or(V(p,s.seed,"seed"),e.ORDER)}function c(p,y=!0){return r.BASE.multiply(e.fromBytes(p)).toBytes(y)}function l(p){const{secretKey:y,publicKey:I,publicKeyUncompressed:k}=s;if(!Pe(p)||"_lengths"in e&&e._lengths||y===I)return;const O=V(p,void 0,"key").length;return O===I||O===k}function h(p,y,I=!0){if(l(p)===!0)throw new Error("first arg must be private key");if(l(y)===!1)throw new Error("second arg must be public key");const k=e.fromBytes(p);return r.fromBytes(y).multiply(k).toBytes(I)}const d={isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a},g=fr(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:h,keygen:g,Point:r,utils:d,lengths:s})}function fo(r,t,e={}){Pn(t),Le(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||qt,s=e.hmac||((x,w)=>Xt(t,x,w)),{Fp:o,Fn:i}=r,{ORDER:a,BITS:c}=i,{keygen:l,getPublicKey:h,getSharedSecret:d,utils:g,lengths:p}=ho(r,e),y={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},I=a*gr<o.ORDER;function k(x){const w=a>>zt;return x>w}function O(x,w){if(!i.isValidNot0(w))throw new Error(`invalid signature ${x}: out of range 1..Point.Fn.ORDER`);return w}function $(){if(I)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function U(x,w){je(w);const m=p.signature,b=w==="compact"?m:w==="recovered"?m+1:void 0;return V(x,b)}class R{r;s;recovery;constructor(w,m,b){if(this.r=O("r",w),this.s=O("s",m),b!=null){if($(),![0,1,2,3].includes(b))throw new Error("invalid recovery id");this.recovery=b}Object.freeze(this)}static fromBytes(w,m=y.format){U(w,m);let b;if(m==="der"){const{r:u,s:v}=Bt.toSig(V(w));return new R(u,v)}m==="recovered"&&(b=w[0],m="compact",w=w.subarray(1));const _=p.signature/2,A=w.subarray(0,_),f=w.subarray(_,_*2);return new R(i.fromBytes(A),i.fromBytes(f),b)}static fromHex(w,m){return this.fromBytes(G(w),m)}assertRecovery(){const{recovery:w}=this;if(w==null)throw new Error("invalid recovery id: must be present");return w}addRecoveryBit(w){return new R(this.r,this.s,w)}recoverPublicKey(w){const{r:m,s:b}=this,_=this.assertRecovery(),A=_===2||_===3?m+a:m;if(!o.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const f=o.toBytes(A),u=r.fromBytes(ot(mr((_&1)===0),f)),v=i.inv(A),S=Y(V(w,void 0,"msgHash")),P=i.create(-S*v),B=i.create(b*v),q=r.BASE.multiplyUnsafe(P).add(u.multiplyUnsafe(B));if(q.is0())throw new Error("invalid recovery: point at infinify");return q.assertValidity(),q}hasHighS(){return k(this.s)}toBytes(w=y.format){if(je(w),w==="der")return G(Bt.hexFromSig(this));const{r:m,s:b}=this,_=i.toBytes(m),A=i.toBytes(b);return w==="recovered"?($(),ot(Uint8Array.of(this.assertRecovery()),_,A)):ot(_,A)}toHex(w){return tt(this.toBytes(w))}}const j=e.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const m=Jt(w),b=w.length*8-c;return b>0?m>>BigInt(b):m},Y=e.bits2int_modN||function(w){return i.create(j(w))},N=Re(c);function C(x){return Ws("num < 2^"+c,x,kt,N),i.toBytes(x)}function M(x,w){return V(x,void 0,"message"),w?V(t(x),void 0,"prehashed message"):x}function K(x,w,m){const{lowS:b,prehash:_,extraEntropy:A}=We(m,y);x=M(x,_);const f=Y(x),u=i.fromBytes(w);if(!i.isValidNot0(u))throw new Error("invalid private key");const v=[C(u),C(f)];if(A!=null&&A!==!1){const q=A===!0?n(p.secretKey):A;v.push(V(q,void 0,"extraEntropy"))}const S=ot(...v),P=f;function B(q){const T=j(q);if(!i.isValidNot0(T))return;const F=i.inv(T),D=r.BASE.multiply(T).toAffine(),H=i.create(D.x);if(H===kt)return;const W=i.create(F*i.create(P+H*u));if(W===kt)return;let X=(D.x===H?0:2)|Number(D.y&zt),et=W;return b&&k(W)&&(et=i.neg(W),X^=1),new R(H,et,I?void 0:X)}return{seed:S,k2sig:B}}function J(x,w,m={}){const{seed:b,k2sig:_}=K(x,w,m);return Qs(t.outputLen,i.BYTES,s)(b,_).toBytes(m.format)}function L(x,w,m,b={}){const{lowS:_,prehash:A,format:f}=We(b,y);if(m=V(m,void 0,"publicKey"),w=M(w,A),!Pe(x)){const u=x instanceof R?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+u)}U(x,f);try{const u=R.fromBytes(x,f),v=r.fromBytes(m);if(_&&u.hasHighS())return!1;const{r:S,s:P}=u,B=Y(w),q=i.inv(P),T=i.create(B*q),F=i.create(S*q),D=r.BASE.multiplyUnsafe(T).add(v.multiplyUnsafe(F));return D.is0()?!1:i.create(D.x)===S}catch{return!1}}function E(x,w,m={}){const{prehash:b}=We(m,y);return w=M(w,b),R.fromBytes(x,"recovered").recoverPublicKey(w).toBytes()}return Object.freeze({keygen:l,getPublicKey:h,getSharedSecret:d,utils:g,lengths:p,Point:r,sign:J,verify:L,recoverPublicKey:E,Signature:R,hash:t})}const we={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},po={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},go=BigInt(0),ze=BigInt(2);function mo(r){const t=we.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%t,h=l*l*r%t,d=ct(h,e,t)*h%t,g=ct(d,e,t)*h%t,p=ct(g,ze,t)*l%t,y=ct(p,s,t)*p%t,I=ct(y,o,t)*y%t,k=ct(I,a,t)*I%t,O=ct(k,c,t)*k%t,$=ct(O,a,t)*I%t,U=ct($,e,t)*h%t,R=ct(U,i,t)*y%t,j=ct(R,n,t)*l%t,Y=ct(j,ze,t);if(!be.eql(be.sqr(Y),r))throw new Error("Cannot find square root");return Y}const be=ge(we.p,{sqrt:mo}),Dt=lo(we,{Fp:be,endo:po}),Z=fo(Dt,nt),wr={};function ve(r,...t){let e=wr[r];if(e===void 0){const n=nt(Hs(r));e=ot(n,n),wr[r]=e}return nt(ot(e,...t))}const Qe=r=>r.toBytes(!0).slice(1),Ve=r=>r%ze===go;function Ze(r){const{Fn:t,BASE:e}=Dt,n=t.fromBytes(r),s=e.multiply(n);return{scalar:Ve(s.y)?n:t.neg(n),bytes:Qe(s)}}function br(r){const t=be;if(!t.isValidNot0(r))throw new Error("invalid x: Fail if x â‰¥ p");const e=t.create(r*r),n=t.create(e*r+BigInt(7));let s=t.sqrt(n);Ve(s)||(s=t.neg(s));const o=Dt.fromAffine({x:r,y:s});return o.assertValidity(),o}const te=Jt;function vr(...r){return Dt.Fn.create(te(ve("BIP0340/challenge",...r)))}function kr(r){return Ze(r).bytes}function yo(r,t,e=qt(32)){const{Fn:n}=Dt,s=V(r,void 0,"message"),{bytes:o,scalar:i}=Ze(t),a=V(e,32,"auxRand"),c=n.toBytes(i^te(ve("BIP0340/aux",a))),l=ve("BIP0340/nonce",c,o,s),{bytes:h,scalar:d}=Ze(l),g=vr(h,o,s),p=new Uint8Array(64);if(p.set(h,0),p.set(n.toBytes(n.create(d+g*i)),32),!Er(p,s,o))throw new Error("sign: Invalid signature produced");return p}function Er(r,t,e){const{Fp:n,Fn:s,BASE:o}=Dt,i=V(r,64,"signature"),a=V(t,void 0,"message"),c=V(e,32,"publicKey");try{const l=br(te(c)),h=te(i.subarray(0,32));if(!n.isValidNot0(h))return!1;const d=te(i.subarray(32,64));if(!s.isValidNot0(d))return!1;const g=vr(s.toBytes(h),Qe(l),a),p=o.multiplyUnsafe(d).add(l.multiplyUnsafe(s.neg(g))),{x:y,y:I}=p.toAffine();return!(p.is0()||!Ve(I)||y!==h)}catch{return!1}}const ke=(()=>{const e=(n=qt(48))=>or(n,we.n);return{keygen:fr(e,kr),getPublicKey:kr,sign:yo,verify:Er,Point:Dt,utils:{randomSecretKey:e,taggedHash:ve,lift_x:br,pointToBytes:Qe},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),wo=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),xr=Uint8Array.from(new Array(16).fill(0).map((r,t)=>t)),bo=xr.map(r=>(9*r+5)%16),_r=(()=>{const e=[[xr],[bo]];for(let n=0;n<4;n++)for(let s of e)s.push(s[n].map(o=>wo[o]));return e})(),Ir=_r[0],Ar=_r[1],Sr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(r=>Uint8Array.from(r)),vo=Ir.map((r,t)=>r.map(e=>Sr[t][e])),ko=Ar.map((r,t)=>r.map(e=>Sr[t][e])),Eo=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),xo=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Br(r,t,e,n){return r===0?t^e^n:r===1?t&e|~t&n:r===2?(t|~e)^n:r===3?t&n|e&~n:t^(e|~n)}const Ee=new Uint32Array(16);class _o extends qe{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){const{h0:t,h1:e,h2:n,h3:s,h4:o}=this;return[t,e,n,s,o]}set(t,e,n,s,o){this.h0=t|0,this.h1=e|0,this.h2=n|0,this.h3=s|0,this.h4=o|0}process(t,e){for(let p=0;p<16;p++,e+=4)Ee[p]=t.getUint32(e,!0);let n=this.h0|0,s=n,o=this.h1|0,i=o,a=this.h2|0,c=a,l=this.h3|0,h=l,d=this.h4|0,g=d;for(let p=0;p<5;p++){const y=4-p,I=Eo[p],k=xo[p],O=Ir[p],$=Ar[p],U=vo[p],R=ko[p];for(let j=0;j<16;j++){const Y=ce(n+Br(p,o,a,l)+Ee[O[j]]+I,U[j])+d|0;n=d,d=l,l=ce(a,10)|0,a=o,o=Y}for(let j=0;j<16;j++){const Y=ce(s+Br(y,i,c,h)+Ee[$[j]]+k,R[j])+g|0;s=g,g=h,h=ce(c,10)|0,c=i,i=Y}}this.set(this.h1+a+h|0,this.h2+l+g|0,this.h3+d+s|0,this.h4+n+i|0,this.h0+o+c|0)}roundClean(){xt(Ee)}destroy(){this.destroyed=!0,xt(this.buffer),this.set(0,0,0,0,0)}}const Io=Oe(()=>new _o);const ee=Z.Point,{Fn:ne}=ee,Ge=Es(nt),Ao=Uint8Array.from("Bitcoin seed".split(""),r=>r.charCodeAt(0)),Ye={private:76066276,public:76067358},Je=2147483648,So=r=>Io(nt(r)),Bo=r=>$t(r).getUint32(0,!1),xe=r=>{if(!Number.isSafeInteger(r)||r<0||r>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+r);const t=new Uint8Array(4);return $t(t).setUint32(0,r,!1),t};class Rt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Bo(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return Ge.encode(this.serialize(this.versions.private,ot(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Ge.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,e=Ye){if(V(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=Xt(Kn,Ao,t),s=n.slice(0,32),o=n.slice(32);return new Rt({versions:e,chainCode:o,privateKey:s})}static fromExtendedKey(t,e=Ye){const n=Ge.decode(t),s=$t(n),o=s.getUint32(0,!1),i={versions:e,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(o!==e[c?"private":"public"])throw new Error("Version mismatch");return c?new Rt({...i,privateKey:a.slice(1)}):new Rt({...i,publicKey:a})}static fromJSON(t){return Rt.fromExtendedKey(t.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(t){if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||Ye,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!Z.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=Z.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=ee.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=So(this._publicKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of e){const o=/^(\d+)('?)$/.exec(s),i=o&&o[1];if(!o||o.length!==3||typeof i!="string")throw new Error("invalid child index: "+s);let a=+i;if(!Number.isSafeInteger(a)||a>=Je)throw new Error("Invalid index");o[2]==="'"&&(a+=Je),n=n.deriveChild(a)}return n}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=xe(t);if(t>=Je){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");e=ot(Uint8Array.of(0),c,e)}else e=ot(this._publicKey,e);const n=Xt(Kn,this.chainCode,e),s=n.slice(0,32),o=n.slice(32);if(!Z.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},a=ne.fromBytes(s);try{if(this._privateKey){const c=ne.create(ne.fromBytes(this._privateKey)+a);if(!ne.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=ne.toBytes(c)}else{const c=ee.fromBytes(this._publicKey).add(ee.BASE.multiply(a));if(c.equals(ee.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=c.toBytes(!0)}return new Rt(i)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return V(t,32),Z.sign(t,this._privateKey,{prehash:!1})}verify(t,e){if(V(t,32),V(e,64),!this._publicKey)throw new Error("No publicKey set!");return Z.verify(e,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return V(e,33),ot(xe(t),new Uint8Array([this.depth]),xe(this.parentFingerprint),xe(this.index),this.chainCode,e)}}class re extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,re.prototype)}}class Xe extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,Xe.prototype)}}class tn extends re{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,tn.prototype)}}const ht={error(){},warn(){},info(){},debug(){},trace(){},log(){}};function _e(r,t=ht,e){throw t.error(r,e),new Error(r)}function en(r,t,e=ht,n){r&&_e(t,e,n)}function Mr(r,t,e=ht,n){r==null&&_e(t,e,n)}function se(r,t,e=ht,n){if(r)try{const s=r(t);s&&typeof s.then=="function"&&s.catch(o=>{try{e.warn("callback failed",{...n??{},error:o,cb:r.name??""})}catch{}})}catch(s){try{e.warn("callback failed",{...n??{},error:s,cb:r.name??""})}catch{}}}const Cr={error:0,warn:1,info:2,debug:3,trace:4};class Mo{constructor(t="info"){this.minLevel=t}should(t){return Cr[t]<=Cr[this.minLevel]}method(t){switch(t){case"error":return console.error;case"warn":return console.warn;case"info":return console.info;case"debug":return console.debug;case"trace":return console.trace;default:return console.log}}header(t,e){return`[${t.toUpperCase()}] ${e}`}flattenContext(t){if(!t)return;const e={};for(const[n,s]of Object.entries(t))e[n]=s instanceof Error?{message:s.message,stack:s.stack}:s;return e}emit(t,e,n){if(!this.should(t))return;const s=this.header(t,e),o=this.flattenContext(n),i=this.method(t);o&&Object.keys(o).length?i(s,o):i(s)}error(t,e){this.emit("error",t,e)}warn(t,e){this.emit("warn",t,e)}info(t,e){this.emit("info",t,e)}debug(t,e){this.emit("debug",t,e)}trace(t,e){this.emit("trace",t,e)}log(t,e,n){this.emit(t,e,n)}}function Co(){const r=Date.now();return{elapsed:()=>Date.now()-r}}let To={},Tr=ht;function Po(r){Tr=r}async function Oo({endpoint:r,requestBody:t,headers:e,...n}){const s=t?JSON.stringify(t):void 0,o={Accept:"application/json, text/plain, */*",...s?{"Content-Type":"application/json"}:void 0,...e};let i;try{i=await fetch(r,{body:s,headers:o,...n})}catch(a){throw new Xe(a instanceof Error?a.message:"Network request failed")}if(!i.ok){let a;try{a=await i.json()}catch{a={error:"bad response"}}if(i.status===400&&"code"in a&&typeof a.code=="number"&&"detail"in a&&typeof a.detail=="string")throw new tn(a.code,a.detail);let c="HTTP request failed";throw"error"in a&&typeof a.error=="string"?c=a.error:"detail"in a&&typeof a.detail=="string"&&(c=a.detail),new re(c,i.status)}try{return await i.json()}catch(a){throw Tr.error("Failed to parse HTTP response",{err:a}),new re("bad response",i.status)}}async function qo(r){return await Oo({...r,...To})}let nn;typeof WebSocket<"u"&&(nn=WebSocket);function No(){if(nn===void 0)throw new Error("WebSocket implementation not initialized");return nn}class z{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const e=t.match(/.{1,2}/g);if(!e)throw new Error("Invalid hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((o,i)=>o+i.length,0),n=new Uint8Array(e);let s=0;for(const o of t)n.set(o,s),s+=o.length;return n}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Buffer<"u")return Buffer.from(t).toString("base64");if(t.length>32768){let e="";for(let n=0;n<t.length;n+=32768){const s=t.slice(n,n+32768);e+=btoa(String.fromCharCode(...s))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){t=t.trim();let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return typeof Buffer<"u"?new Uint8Array(Buffer.from(e,"base64")):new Uint8Array([...atob(e)].map(n=>n.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let n=0;for(let s=0;s<t.length;s++)n|=t[s]^e[s];return n===0}static compare(t,e){const n=Math.min(t.length,e.length);for(let s=0;s<n;s++){if(t[s]<e[s])return-1;if(t[s]>e[s])return 1}return t.length-e.length}static toBigInt(t){let e=0n;for(const n of t)e=e<<8n|BigInt(n);return e}static fromBigInt(t){if(t<0n)throw new RangeError("value must be non-negative");if(t===0n)return new Uint8Array([0]);let e=t,n=0;for(;e>0n;)n++,e>>=8n;const s=new Uint8Array(n);e=t;for(let o=n-1;o>=0;o--)s[o]=Number(e&0xffn),e>>=8n;return s}}function rn(r){return z.toBase64(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function Pr(r){return z.fromBase64(r)}function Uo(r){const t=z.toString(z.fromBase64(Do(r)));return JSON.parse(t)}function Do(r){return r.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function sn(r){if(typeof r!="string"||r.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(r)&&!e.test(r))return!1;const n=r.replace(/-/g,"+").replace(/_/g,"/"),s=(4-n.length%4)%4;if(s>2)return!1;const o=n+"=".repeat(s);try{const i=z.fromBase64(o),a=z.toBase64(i),c=a.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),l=n.replace(/=+$/,"");return a.replace(/=+$/,"")===l||c===l}catch{return!1}}function Ro(r){return typeof r=="number"||typeof r=="string"}function Lo(r){const t=[];return on(r,t),new Uint8Array(t)}function on(r,t){if(r===null)t.push(246);else if(r===void 0)t.push(247);else if(typeof r=="boolean")t.push(r?245:244);else if(typeof r=="number")Ho(r,t);else if(typeof r=="string")Or(r,t);else if(Array.isArray(r))Wo(r,t);else if(r instanceof Uint8Array)jo(r,t);else if(typeof r=="object"&&r!==null&&!Array.isArray(r))zo(r,t);else throw new Error("Unsupported type")}function Fo(r,t){if(r<24)t.push(r);else if(r<256)t.push(24,r);else if(r<65536)t.push(25,r>>>8&255,r&255);else if(r<4294967296)t.push(26,r>>>24&255,r>>>16&255,r>>>8&255,r&255);else throw new Error("Unsupported integer size")}function Ko(r,t){const e=-1-r;if(e<24)t.push(32|e);else if(e<256)t.push(56,e&255);else if(e<65536)t.push(57,e>>>8&255,e&255);else if(e<4294967296)t.push(58,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Unsupported integer size")}function $o(r,t){const e=new ArrayBuffer(8),n=new DataView(e);n.setFloat64(0,r,!1),t.push(251);for(let s=0;s<8;s++)t.push(n.getUint8(s))}function Ho(r,t){Number.isInteger(r)?r>=0?Fo(r,t):Ko(r,t):$o(r,t)}function jo(r,t){const e=r.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<r.length;n++)t.push(r[n])}function Or(r,t){const e=new TextEncoder().encode(r),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>>8&255,n&255);else if(n<4294967296)t.push(122,n>>>24&255,n>>>16&255,n>>>8&255,n&255);else throw new Error("String too long to encode");for(let s=0;s<e.length;s++)t.push(e[s])}function Wo(r,t){const e=r.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>>8&255,e&255);else throw new Error("Unsupported array length");for(const n of r)on(n,t)}function zo(r,t){const e=Object.keys(r),n=e.length;if(n>=4294967296)throw new Error("Object has too many keys to encode");n<24?t.push(160|n):n<256?t.push(184,n):n<65536?t.push(185,n>>8&255,n&255):t.push(186,n>>24&255,n>>16&255,n>>8&255,n&255);for(const s of e)Or(s,t),on(r[s],t)}function Qo(r){const t=new DataView(r.buffer,r.byteOffset,r.byteLength);return Ie(t,0).value}function Ie(r,t){if(t>=r.byteLength)throw new Error("Unexpected end of data");const e=r.getUint8(t++),n=e>>5,s=e&31;switch(n){case 0:return Vo(r,t,s);case 1:return Zo(r,t,s);case 2:return Go(r,t,s);case 3:return Yo(r,t,s);case 4:return Jo(r,t,s);case 5:return Xo(r,t,s);case 7:return ei(r,t,s);default:throw new Error(`Unsupported major type: ${n}`)}}function Mt(r,t,e){if(t+e>r.byteLength)throw new Error("Unexpected end of data")}function Qt(r,t,e){if(e<24)return{value:e,offset:t};if(e===24)return Mt(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){Mt(r,t,2);const n=r.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){Mt(r,t,4);const n=r.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Mt(r,t,8);const n=r.getUint32(t,!1),s=r.getUint32(t+4,!1);return t+=8,{value:n*2**32+s,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Vo(r,t,e){const{value:n,offset:s}=Qt(r,t,e);return{value:n,offset:s}}function Zo(r,t,e){const{value:n,offset:s}=Qt(r,t,e);return{value:-1-n,offset:s}}function Go(r,t,e){const{value:n,offset:s}=Qt(r,t,e);if(s+n>r.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(r.buffer,r.byteOffset+s,n),offset:s+n}}function Yo(r,t,e){const{value:n,offset:s}=Qt(r,t,e);if(s+n>r.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(r.buffer,r.byteOffset+s,n);return{value:new TextDecoder().decode(o),offset:s+n}}function Jo(r,t,e){const{value:n,offset:s}=Qt(r,t,e),o=[];let i=s;for(let a=0;a<n;a++){const c=Ie(r,i);o.push(c.value),i=c.offset}return{value:o,offset:i}}function Xo(r,t,e){const{value:n,offset:s}=Qt(r,t,e),o={};let i=s;for(let a=0;a<n;a++){const c=Ie(r,i);if(!Ro(c.value))throw new Error("Invalid key type");const l=Ie(r,c.offset);o[c.value]=l.value,i=l.offset}return{value:o,offset:i}}function ti(r){const t=(r&31744)>>10,e=r&1023,n=r&32768?-1:1;return t===0?n*2**-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function ei(r,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return Mt(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){Mt(r,t,2);const n=ti(r.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){Mt(r,t,4);const n=r.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Mt(r,t,8);const n=r.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}const ni=Nn("Secp256k1_HashToCurve_Cashu_");function Ae(r){const t=nt(z.concat(ni,r)),e=new Uint32Array(1),n=2**16;for(let s=0;s<n;s++){const o=new Uint8Array(e.buffer),i=nt(z.concat(t,o));try{return Vt(tt(z.concat(new Uint8Array([2]),i)))}catch{e[0]++}}throw new Error("No valid point found")}function ri(r){const t=r.map(e=>e.toHex(!1)).join("");return nt(new TextEncoder().encode(t))}function Vt(r){return Z.Point.fromHex(r)}const si=r=>{let t;return/^[a-fA-F0-9]+$/.test(r)?t=Se(r)%BigInt(2**31-1):t=z.toBigInt(Pr(r))%BigInt(2**31-1),t};function oi(){return Z.utils.randomSecretKey()}function an(r,t){const e=Ae(r);t||(t=Z.Point.Fn.fromBytes(oi()));const n=Z.Point.BASE.multiply(t);return{B_:e.add(n),r:t,secret:r}}function ii(r,t,e){return r.subtract(e.multiply(t))}function ai(r,t,e,n){const s=n,o=ii(r.C_,t,s);return{id:r.id,amount:r.amount,secret:e,C:o}}const ci=r=>({amount:r.amount,C:r.C.toHex(!0),id:r.id,secret:new TextDecoder().decode(r.secret),witness:JSON.stringify(r.witness)}),ui=(r,t)=>{const e=nt(new TextEncoder().encode(r)),n=typeof t=="string"?G(t):t,s=ke.sign(e,n);return tt(s)},li=(r,t,e,n=!1)=>{try{const s=nt(new TextEncoder().encode(t)),o=e.length===66?e.slice(2):e;return ke.verify(G(r),s,G(o))}catch(s){if(n)throw s}return!1};function cn(r){let t;try{typeof r=="string"?t=JSON.parse(r):t=r}catch{throw new Error("Can't parse secret")}if(!Array.isArray(t)||t.length!==2||typeof t[0]!="string"||typeof t[1]!="object"||t[0].trim().length===0||t[1]===null)throw new Error("Invalid NUT-10 secret");const[e,n]=t;if(typeof n.nonce!="string"||typeof n.data!="string")throw new Error("Invalid NUT-10 secret nonce / data");if(n.tags){if(!Array.isArray(n.tags))throw new Error("Invalid NUT-10 secret tags");if(n.tags.some(s=>!Array.isArray(s)||s.length===0||s.some(o=>typeof o!="string"||!o.length)))throw new Error("Invalid NUT-10 tag(s)")}return[e,{nonce:n.nonce,data:n.data,tags:n.tags}]}function hi(r,t){const e=Array.isArray(r)?r:[r],n=cn(t),s=n[0];if(!e.includes(s))throw new Error(`Invalid secret kind: ${s} Allowed: ${e.join(", ")}`);return n}function fi(r){return cn(r)[0]}function qr(r){return cn(r)[1]}function di(r){const{data:t}=qr(r);return t}function pi(r){const{tags:t}=qr(r);return t??[]}function un(r,t){const e=pi(r).find(n=>n[0]===t);if(!(!e||e.length<=1))return e.slice(1)}function Nr(r,t){const e=un(r,t);return e&&e.length>0?e[0]:void 0}function gi(r,t){const e=Nr(r,t);if(e===void 0)return;const n=Number.parseInt(e,10);return Number.isFinite(n)?n:void 0}const Ur=Nn("Cashu_P2BK_v1");function mi(r,t,e){if(!r.length)return{blinded:[],Ehex:""};e=e??Z.utils.randomSecretKey();const n=Z.Point.Fn.fromBytes(e),s=Z.getPublicKey(e,!0),o=G(t);return{blinded:r.map((i,a)=>{const c=Vt(i),l=Dr(c,n,o,a),h=c.add(Z.Point.BASE.multiply(l));if(h.equals(Z.Point.ZERO))throw new Error("Blinded key at infinity");return h.toHex(!0)}),Ehex:tt(s)}}function yi(r,t,e,n){const s=Array.isArray(t)?t:[t],o=Array.isArray(e)?e:[e],i=new Set,a=Z.Point.fromHex(r),c=G(n);for(const l of s){const h=Z.Point.Fn.fromBytes(G(l)),d=Z.getPublicKey(G(l),!0);o.forEach((g,p)=>{const y=Dr(a,h,c,p),I=G(g),k=wi(l,y,I,d);k&&i.add(k)})}return Array.from(i)}function wi(r,t,e,n){const s=Z.Point.CURVE().n,o=typeof r=="string"?Se(r):r,i=typeof t=="string"?Se(t):t;if(o<=0n||o>=s)throw new Error("Invalid private key");if(i<=0n||i>=s)throw new Error("Invalid scalar r");if(n=n??Z.Point.BASE.multiply(o).toBytes(!0),n.length!==33)throw new Error("naturalPub must be 33 bytes");const a=(o+i)%s,c=(s-o+i)%s;if(!e){if(a===0n)throw new Error("Derived secret key is zero");return hn(a)}if(e.length!==33)throw new Error("blindPubkey must be 33 bytes");const l=Z.Point.fromHex(tt(e)),h=Z.Point.BASE.multiply(i),d=l.subtract(h);if(d.equals(Z.Point.ZERO))return null;const g=d.toBytes(!0).slice(1),p=n.slice(1);if(!z.equals(g,p))return null;const y=d.toBytes(!0)[0]&1,I=n[0]&1,k=y===I?a:c;if(k===0n)throw new Error("Derived secret key is zero");return hn(k)}function Dr(r,t,e,n){const s=r.multiply(t).toBytes(!0).slice(1),o=new Uint8Array([n&255]);let i=z.toBigInt(nt(z.concat(Ur,s,e,o)));if((i===0n||i>=Z.Point.CURVE().n)&&(i=z.toBigInt(nt(z.concat(Ur,s,e,o,new Uint8Array([255])))),i===0n||i>=Z.Point.CURVE().n))throw new Error("P2BK: tweak derivation failed");return i}function mt(r){return r instanceof Uint8Array&&(r=new TextDecoder().decode(r)),hi(["P2PK","HTLC"],r)}function bi(r){try{const t=mt(r),e=ki(t),n=Rr(t),s=Lr(t);if(e==="ACTIVE"||e==="PERMANENT")return n;if(e==="EXPIRED"&&s.length){const o=[...n,...s];return Array.from(new Set(o))}}catch{}return[]}function Rr(r){const t=mt(r);let e="";fi(t)==="P2PK"&&(e=di(t));const n=un(t,"pubkeys")??[],s=[e,...n].filter(Boolean);return Array.from(new Set(s))}function Lr(r){const t=mt(r);return un(t,"refund")??[]}function vi(r){const t=mt(r),e=gi(t,"locktime");return e===void 0||!Number.isFinite(e)||e<=0?1/0:e}function ki(r,t=Math.floor(Date.now()/1e3)){const e=mt(r),n=vi(e);return Number.isFinite(n)?t<n?"ACTIVE":"EXPIRED":"PERMANENT"}function ln(r){const t=mt(r);return Nr(t,"sigflag")==="SIG_ALL"?"SIG_ALL":"SIG_INPUTS"}function Ei(r){return Fr(r)?.signatures??[]}function Fr(r){if(!r)return;let t;try{t=typeof r=="string"?JSON.parse(r):r}catch(n){console.error("Failed to parse witness string:",n);return}const e={signatures:t.signatures??[]};return typeof t.preimage=="string"&&t.preimage.length>0&&(e.preimage=t.preimage),e}function Kr(r,t,e=ht,n){const s=i=>typeof i=="string"?i:tt(i),o=Array.isArray(t)?t.map(s):s(t);return r.map((i,a)=>{const c=_i(o,i);let l=i;for(const h of c)try{l=xi(l,h,n)}catch(d){const g=d instanceof Error?d.message:"Unknown error";e.warn(`Proof #${a+1}: ${g}`)}return l})}function xi(r,t,e){const n=mt(r.secret);e=e??r.secret;const s=typeof t=="string"?G(t):t,o=tt(ke.getPublicKey(s)),i=bi(n);if(!i.length||!i.some(h=>h.includes(o)))throw new Error(`Signature not required from [02|03]${o}`);if(Ei(r.witness).some(h=>li(h,e,o)))throw new Error(`Proof already signed by [02|03]${o}`);const a=ui(e,t),c=Fr(r.witness),l={...c&&c.preimage!==void 0?{preimage:c.preimage}:{},signatures:[...c?.signatures??[],a]};return{...r,witness:l}}function _i(r,t){const e=Array.isArray(r)?r:[r],n=t?.p2pk_e;if(!n)return Array.from(new Set(e));const s=mt(t.secret),o=[...Rr(s),...Lr(s)],i=t.id;return yi(n,e,o,i)}function Ii(r){if(r.length===0)throw new Error("No proofs");const t=mt(r[0].secret);if(ln(t)!=="SIG_ALL")throw new Error("First proof is not SIG_ALL");const e=t[1].data,n=JSON.stringify(t[1].tags??[]);for(let s=1;s<r.length;s++){const o=mt(r[s].secret);if(o[0]!==t[0])throw new Error(`Proof #${s+1} is not ${t[0]}`);if(ln(o)!=="SIG_ALL")throw new Error(`Proof #${s+1} is not SIG_ALL`);if(o[1].data!==e)throw new Error("SIG_ALL inputs must share identical Secret.data");if(JSON.stringify(o[1].tags??[])!==n)throw new Error("SIG_ALL inputs must share identical Secret.tags")}}function Ai(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.B_);return e&&n.push(e),n.join("")}function $r(r){return r.some(t=>{try{return ln(t.secret)==="SIG_ALL"}catch{return!1}})}function Si(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.id,s.blindedMessage.B_);return e&&n.push(e),n.join("")}function Bi(r,t,e){const n=[];for(const s of r)n.push(s.secret);for(const s of t)n.push(s.blindedMessage.B_);return e&&n.push(e),n.join("")}function Mi(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}const Ci=(r,t,e,n)=>{const s=Z.Point.Fn.fromBytes(r.s),o=Z.Point.Fn.fromBytes(r.e),i=Z.Point.BASE.multiply(s),a=n.multiply(o),c=t.multiply(s),l=e.multiply(o),h=i.subtract(a),d=c.subtract(l),g=ri([h,d,n,e]);return Mi(g,r.e)},Ti=(r,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const s=Ae(r),o=e.add(n.multiply(t.r)),i=Z.Point.BASE.multiply(t.r),a=s.add(i);return Ci(t,a,o,n)},Pi="m/129372'/0'",Hr=BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),Oi=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&sn(t)||n&&t.startsWith("00"))return Wr(r,t,e,0);if(n&&t.startsWith("01"))return jr(r,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},qi=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&sn(t)||n&&t.startsWith("00"))return Wr(r,t,e,1);if(n&&t.startsWith("01"))return jr(r,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},jr=(r,t,e,n)=>{let s=z.concat(z.fromString("Cashu_KDF_HMAC_SHA256"),z.fromHex(t),z.writeBigUint64BE(BigInt(e)));switch(n){case 0:s=z.concat(s,z.fromHex("00"));break;case 1:s=z.concat(s,z.fromHex("01"))}const o=Xt(nt,r,s);if(n===1){const i=z.toBigInt(o);if(i>=Hr)return z.fromBigInt(i-Hr);if(i===0n)throw new Error("Derived invalid blinding scalar r == 0");return o}return o},Wr=(r,t,e,n)=>{const s=Rt.fromMasterSeed(r),o=si(t),i=`${Pi}/${o}'/${e}'/${n}`,a=s.derive(i);if(a.privateKey===null)throw new Error("Could not derive private key");return a.privateKey};function Ni(r,t){let e=r;for(const s of t)e+=s.B_;const n=new TextEncoder().encode(e);return nt(n)}function Ui(r,t,e){const n=Ni(t,e),s=G(r),o=ke.sign(n,s);return tt(o)}function Ct(r,t,e,n){if(e){const o=Yr(e);if(r===0&&o===0)return e;const i=e.filter(c=>c>0),a=Yr(i);if(a>r)throw new Error(`Split is greater than total amount: ${a} > ${r}`);if(i.some(c=>!Qr(c,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(a===r)return i;e=i,r-=a}else e=[];const s=zr(t,"desc");if(!s||s.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");for(const o of s){if(o<=0)continue;const i=Math.floor(r/o);if(e.push(...Array(i).fill(o)),r-=o*i,r===0)break}if(r!==0)throw new Error(`Unable to split remaining amount: ${r}`);return n?e.sort((o,i)=>o-i):e}function Di(r,t,e,n){const s=[],o=r.map(a=>a.amount);zr(e,"asc").forEach(a=>{const c=o.filter(h=>h===a).length,l=Math.max(n-c,0);for(let h=0;h<l&&!(s.reduce((d,g)=>d+g,0)+a>t);++h)s.push(a)});const i=t-s.reduce((a,c)=>a+c,0);return i&&Ct(i,e).forEach(a=>{s.push(a)}),s.sort((a,c)=>a-c)}function zr(r,t="desc"){return t=="desc"?Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>e-n)}function Qr(r,t){return r in t}function Se(r){return BigInt(`0x${r}`)}function hn(r){return r.toString(16).padStart(64,"0")}function Zt(r){return/^[a-f0-9]*$/i.test(r)}function Ri(r){return Array.isArray(r)?r.some(t=>!Zt(t.id)):!Zt(r.id)}function Li(r){return r.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function Vr(r,t){if(r.proofs.forEach(a=>{if(a.dleq&&a.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Ri(r.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");r.proofs=Li(r.proofs);const e=Fi(r),n=Lo(e),s="cashu",o="B",i=rn(n);return s+o+i}function Fi(r){const t={},e=r.mint;for(let s=0;s<r.proofs.length;s++){const o=r.proofs[s];t[o.id]?t[o.id].push(o):t[o.id]=[o]}const n={m:e,u:r.unit||"sat",t:Object.keys(t).map(s=>({i:G(s),p:t[s].map(o=>({a:o.amount,s:o.secret,c:G(o.C),...o.dleq&&{d:{e:G(o.dleq.e),s:G(o.dleq.s),r:G(o.dleq.r??"00")}},...o.p2pk_e&&{pe:G(o.p2pk_e)},...o.witness&&{w:JSON.stringify(o.witness)}}))}))};return r.memo&&(n.d=r.memo),n}function fn(r,t=!1){if(typeof r!="number"||!Number.isFinite(r)||!Number.isInteger(r))throw new Error(`Invalid amount: ${String(r)}`);if(!Number.isSafeInteger(r))throw new Error(`Amount must be a safe integer: ${r}`);if(t?r<0:r<=0)throw new Error(`Amount must be ${t?"non-negative":"positive"}: ${r}`)}function Ki(r){const t=[];r.t.forEach(n=>n.p.forEach(s=>{fn(s.a,!0),t.push({secret:s.s,C:tt(s.c),amount:s.a,id:tt(n.i),...s.d&&{dleq:{r:tt(s.d.r),s:tt(s.d.s),e:tt(s.d.e)}},...s.pe&&{p2pk_e:tt(s.pe)},...s.w&&{witness:s.w}})}));const e={mint:r.m,proofs:t,unit:r.u||"sat"};return r.d&&(e.memo=r.d),e}function $i(r,t){const e=(t??[]).map(o=>typeof o=="string"?o:o.id),n=Jr(r),s=Zr(n);return s.proofs=Qi(s.proofs,e),s}function Hi(r){r=Jr(r);const t=Zr(r);return{unit:t.unit||"sat",mint:t.mint,amount:Tt(t.proofs),...t.memo&&{memo:t.memo},incompleteProofs:t.proofs.map(e=>({secret:e.secret,C:e.C,amount:e.amount,...e.dleq&&{dleq:e.dleq},...e.witness&&{witness:e.witness}}))}}function Zr(r){const t=r.slice(0,1),e=r.slice(1);if(t==="A"){const n=Uo(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const s=n.token[0];for(const i of s.proofs)fn(i.amount,!0);const o={mint:s.mint,proofs:s.proofs,unit:n.unit||"sat"};return n.memo&&(o.memo=n.memo),o}else if(t==="B"){const n=Pr(e),s=Qo(n);return Ki(s)}throw new Error("Token version is not supported")}function ji(r,t,e,n=0,s=!1){if(s){const c=Object.entries(r).sort((h,d)=>+h[0]-+d[0]).map(([,h])=>h).reduce((h,d)=>h+d,""),l=nt(z.fromString(c));return z.toBase64(l).slice(0,12)}let o=Object.entries(r).sort((c,l)=>+c[0]-+l[0]).map(([,c])=>G(c)).reduce((c,l)=>dn(c,l),new Uint8Array),i,a;switch(n){case 0:return i=nt(o),a=z.toHex(i).slice(0,14),"00"+a;case 1:if(!t)throw new Error("Cannot compute keyset ID version 01: unit is required.");return o=dn(o,z.fromString("unit:"+t)),e&&(o=dn(o,z.fromString("final_expiry:"+e.toString()))),i=nt(o),a=z.toHex(i),"01"+a;default:throw new Error(`Unrecognized keyset ID version: ${n}`)}}function dn(r,t){const e=new Uint8Array(r.length+t.length);return e.set(r),e.set(t,r.length),e}function yt(r){return typeof r=="object"}function Gt(...r){return r.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function Gr(r){return r.replace(/\/$/,"")}function Tt(r){return r.reduce((t,e)=>t+e.amount,0)}class Wi{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class zi{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new Wi(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function Qi(r,t){const e=(t??[]).map(s=>typeof s=="string"?s:s.id),n=[];for(const s of r){let o;try{o=G(s.id)}catch{n.push(s);continue}if(o[0]===0)n.push(s);else if(o[0]===1){if(!e)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let i=!1;for(const a of e)if(s.id===a.slice(0,s.id.length)){s.id=a,n.push(s),i=!0;break}if(!i)throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${o[0]}`)}return n}function Vi(r,t){if(r.dleq==null)return!1;const e={e:G(r.dleq.e),s:G(r.dleq.s),r:Se(r.dleq.r??"00")};if(!Qr(r.amount,t.keys))throw new Error(`Undefined key for amount ${r.amount} in keyset ${t.id}`);const n=t.keys[r.amount];return Ti(new TextEncoder().encode(r.secret),e,Vt(r.C),Vt(n))}function Yr(r){return r.reduce((t,e)=>t+e,0)}function Jr(r){return["web+cashu://","cashu://","cashu:","cashu"].forEach(t=>{r.startsWith(t)&&(r=r.slice(t.length))}),r}function Zi(r){return/^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(r)}class Yt{constructor(){this.connectionMap=new Map}static getInstance(){return Yt.instance||(Yt.instance=new Yt),Yt.instance}getConnection(t,e){const n=this.connectionMap.get(t);if(n)return e&&n.setLogger(e),n;const s=new Gi(t,e);return this.connectionMap.set(t,s),s}}class Gi{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=No(),this.url=new URL(t),this.messageQueue=new zi,this._logger=e??ht}setLogger(t){this._logger=t}connect(t=1e4){return this.connectionPromise?this.connectionPromise:(this.connectionPromise=new Promise((e,n)=>{let s=!1,o=!1,i=null;const a=h=>{o||(o=!0,i&&clearTimeout(i),h())},c=()=>{if(this.ws){try{this.ws.onopen=null,this.ws.onerror=null,this.ws.onmessage=null,this.ws.onclose=null}catch{}try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling()}},l=h=>{this.connectionPromise=void 0,c();const d=h instanceof Error?h:new Error(String(h));this.failPendingRpc(d),a(()=>n(d))};try{this.ws=new this._WS(this.url.toString())}catch(h){l(h);return}i=setTimeout(()=>{l(new Error(`WebSocket connect timeout after ${t}ms`))},t),this.ws.onopen=()=>{s=!0,a(e)},this.ws.onerror=h=>{if(!s){l(new Error("Failed to open WebSocket"));return}this._logger.error("WebSocket error after open",{ev:h})},this.ws.onmessage=h=>{this.messageQueue.enqueue(h.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=h=>{if(this.connectionPromise=void 0,!s){const p=h?.reason?`, ${h.reason}`:"";l(new Error(`WebSocket closed before open (code ${h?.code??0}${p})`));return}this.stopMessageHandling();const d=h?.reason?`, ${h.reason}`:"",g=h?.code??0;!(typeof h.wasClean!="boolean"||h.wasClean)||g!==1e3&&g!==1001?this.failPendingRpc(new Error(`WebSocket closed (code ${g}${d})`)):this.rpcListeners={},this.onCloseCallbacks.forEach(p=>p(h))}}),this.connectionPromise)}sendRequest(t,e){if(this.ws?.readyState!==this._WS.OPEN){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const n=this.rpcId;this.rpcId++,this.sendRpcMessage(t,e,n)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}stopMessageHandling(){for(this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);this.messageQueue.size>0;)this.messageQueue.dequeue()}failPendingRpc(t){const e=this.rpcListeners;this.rpcListeners={};for(const n of Object.keys(e))try{e[n].errorCallback(t)}catch{}}sendRpcMessage(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw new Error("Socket not open");const s=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});try{this.ws.send(s)}catch(o){this._logger.error("WebSocket send failed",{e:o}),this.connectionPromise=void 0;try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling();const i=o instanceof Error?o:new Error(String(o));throw this.failPendingRpc(i),i}}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(t){this.ws?.readyState!==this._WS.OPEN&&await this.connect(t)}handleNextMessage(){if(this.messageQueue.size===0){this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);return}const t=this.messageQueue.dequeue();try{const e=JSON.parse(t);if("result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params?.subId;if(!n)return;if(this.subListeners[n]?.length>0){const s=e;this.subListeners[n].forEach(o=>{try{o(s.params?.payload)}catch(i){this._logger.error("Subscription handler threw",{e:i})}})}}}catch(e){this._logger.error("Error doing handleNextMessage",{e})}}createSubscription(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const s=(Math.random()+1).toString(36).substring(7),o=this.rpcId;this.addRpcListener(()=>{this.addSubListener(s,e)},n,o);try{this.sendRequest("subscribe",{...t,subId:s})}catch(i){throw this.removeRpcListener(o),i}return s}cancelSubscription(t,e,n){if(this.removeListener(t,e),this.ws?.readyState!==this._WS.OPEN){this._logger.info("Socket not open, removed listener locally {subId}",{subId:t});return}const s=this.rpcId;this.rpcId++,this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},n||(o=>this._logger.error("Unsubscribe failed",{e:o})),s);try{this.sendRpcMessage("unsubscribe",{subId:t},s)}catch(o){throw this.removeRpcListener(s),o}}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){if(this.ws){try{this.ws.close()}catch{}this.ws=void 0}this.connectionPromise=void 0,this.stopMessageHandling()}onClose(t){this.onCloseCallbacks.push(t)}}const pn={UNPAID:"UNPAID",PAID:"PAID"},oe={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},gn={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"};function mn(r,t){return r.state||(t.warn("Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof r.paid=="boolean"&&(r.state=r.paid?oe.PAID:oe.UNPAID)),r}function Xr(r,t){return r.state||(t.warn("Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof r.paid=="boolean"&&(r.state=r.paid?pn.PAID:pn.UNPAID)),r}function Yi(r,t){return Array.isArray(r?.contact)&&r?.contact.length>0&&(r.contact=r.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),r}class yn{constructor(t){this._mintInfo=t;const e=this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);this._protected22=this.buildIndex(e);const n=this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);this._protected21=this.buildIndex(n)}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t,e){return this.matchesProtected(this._protected22,t,e)}requiresClearAuthToken(t,e){return this.matchesProtected(this._protected21,t,e)}matchesProtected(t,e,n){if(!t)return!1;const s=`${e} ${n}`,o=t.cache[s];if(typeof o=="boolean")return o;const i=t.exact.some(l=>l.method===e&&l.path===n),a=i?!1:t.prefix.some(l=>l.method===e&&n.startsWith(l.path)),c=i||a;return t.cache[s]=c,c}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e?.methods??[]}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}toEndpoints(t){if(!Array.isArray(t))return[];const e=[];for(const n of t)if(n&&typeof n=="object"){const s=n,o=s.method,i=s.path;if(typeof o=="string"&&typeof i=="string"){const a=o.toUpperCase();(a==="GET"||a==="POST")&&e.push({method:a,path:i})}}return e}buildIndex(t){if(!t||t.length===0)return;const e=[],n=[];for(const s of t){let o=s.path;o.startsWith("^")&&(o=o.slice(1)),o.endsWith("$")&&(o=o.slice(0,-1)),o.endsWith(".*")?n.push({method:s.method,path:o.slice(0,-2)}):e.push({method:s.method,path:o})}return{cache:{},exact:e,prefix:n}}get cache(){return this._mintInfo}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this.supportsNut04Description("bolt12")}supportsNut04Description(t,e){return this._mintInfo.nuts[4]?.methods.some(n=>n.method===t&&(e?n.unit===e:!0)&&(n.options?.description===!0||n.description===!0))}supportsAmountless(t="bolt11",e="sat"){const n=this._mintInfo?.nuts?.[5]?.methods??[];return Array.isArray(n)?n.some(s=>s.method===t&&s.unit===e&&s.options?.amountless===!0):!1}}class wn{constructor(t,e){this.tokenListeners=[],this.discoveryUrl=t,this.logger=e?.logger??ht,this.clientId=e?.clientId??"cashu-client",this.scope=e?.scope??"openid",this.onTokens=e?.onTokens}static fromMintInfo(t,e){const n=t?.nuts?.["21"];if(!n?.openid_discovery)throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");const s=e?.clientId??n.client_id??"cashu-client";return new wn(n.openid_discovery,{...e,clientId:s})}setClient(t){this.clientId=t}setScope(t){this.scope=t??"openid"}addTokenListener(t){this.tokenListeners.push(t)}async loadConfig(){if(this.config)return this.config;const t=await fetch(this.discoveryUrl,{method:"GET",headers:{Accept:"application/json"}}),e=await t.text();let n;try{n=e?JSON.parse(e):void 0}catch(o){this.logger.warn("OIDCAuth: bad discovery JSON",{err:o})}if(!t.ok||!n)throw new Error("OIDCAuth: invalid discovery document");const s=n;if(typeof s.token_endpoint!="string"||s.token_endpoint.length===0)throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");return this.config=s,s}generatePKCE(){const t=qt(48),e=rn(t),n=z.fromString(e),s=nt(n),o=rn(s);return{verifier:e,challenge:o}}async buildAuthCodeUrl(t){const e=await this.loadConfig(),n=t.scope??this.scope,s=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:t.redirectUri,scope:n,code_challenge_method:t.codeChallengeMethod??"S256",code_challenge:t.codeChallenge});if(t.state&&s.set("state",t.state),!e.authorization_endpoint)throw new Error("OIDCAuth: discovery lacks authorization_endpoint");return`${e.authorization_endpoint}?${s.toString()}`}async exchangeAuthCode(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"authorization_code",code:t.code,redirect_uri:t.redirectUri,client_id:this.clientId,code_verifier:t.codeVerifier}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async deviceStart(){const t=(await this.loadConfig()).device_authorization_endpoint;if(!t)throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");const e=this.toForm({client_id:this.clientId,scope:this.scope});return this.postFormStrict(t,e)}async devicePoll(t,e=5){const n=await this.loadConfig();let s=Math.max(1,e);for(;;){await this.sleep(s*1e3);const o=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:t,client_id:this.clientId}),i=await this.postFormLoose(n.token_endpoint,o);if(i.access_token)return this.handleTokens(i),i;const a=(i.error??"").toString();if(a==="authorization_pending")continue;if(a==="slow_down"){s=Math.max(s+5,s*2);continue}const c=i.error_description||a||"device authorization failed";throw new Error(`OIDCAuth: ${c}`)}}async startDeviceAuth(t=5){const e=await this.deviceStart(),n=Math.max(e.interval??1,t);let s=!1;return{...e,poll:async()=>{const o=await this.loadConfig();let i=Math.max(1,n);for(;;){if(s)throw new Error("OIDCAuth: device polling cancelled");await this.sleep(i*1e3);const a=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:e.device_code,client_id:this.clientId}),c=await this.postFormLoose(o.token_endpoint,a);if(c.access_token)return this.handleTokens(c),c;const l=(c.error??"").toString();if(l==="authorization_pending")continue;if(l==="slow_down"){i=Math.max(i+5,i*2);continue}const h=c.error_description||l||"device authorization failed";throw new Error(`OIDCAuth: ${h}`)}},cancel:()=>{s=!0}}}async refresh(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"refresh_token",refresh_token:t,client_id:this.clientId}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async passwordGrant(t,e){const n=await this.loadConfig(),s=this.toForm({grant_type:"password",client_id:this.clientId,username:t,password:e,scope:this.scope}),o=await this.postFormStrict(n.token_endpoint,s);return this.handleTokens(o),o}handleTokens(t){if(!t.access_token){const e=t.error_description||t.error||"token response missing access_token";throw new Error(`OIDCAuth: ${e}`)}queueMicrotask(()=>se(this.onTokens,t,this.logger,{where:"OIDCAuth.handleTokens"}));for(const e of this.tokenListeners)queueMicrotask(()=>se(e,t,this.logger,{where:"OIDCAuth.handleTokens.listener"}))}toForm(t){const e=n=>encodeURIComponent(n).replace(/%20/g,"+");return Object.entries(t).map(([n,s])=>`${e(n)}=${e(s)}`).join("&")}async postFormStrict(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e}),s=await n.text();let o;try{o=s?JSON.parse(s):void 0}catch(i){this.logger.warn("OIDCAuth: bad JSON (strict)",{err:i})}if(!n.ok){const i=o??{},a=i.error_description||i.error||`HTTP ${n.status}`;throw new Error(`OIDCAuth: ${a}`)}return this.logger.debug("OIDCAuth Response",{json:o}),o??{}}catch(n){throw this.logger.error("OIDCAuth: postFormStrict failed",{err:n}),n}}async postFormLoose(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await(await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e})).text();let s;try{s=n?JSON.parse(n):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (loose)",{err:o})}return this.logger.debug("OIDCAuth Response",{json:s}),s??{}}catch(n){return this.logger.error("OIDCAuth: postFormLoose network error",{err:n}),{error:"network_error",error_description:String(n)}}}sleep(t){return new Promise(e=>setTimeout(e,t))}}class ts{constructor(t,e){this._mintUrl=Gr(t),this._request=e?.customRequest??qo,this._authProvider=e?.authProvider,this._logger=e?.logger??ht,Po(this._logger)}get mintUrl(){return this._mintUrl}async oidcAuth(t){const e=(await this.getLazyMintInfo()).nuts[21];if(!e?.openid_discovery)throw new Error("Mint: no NUT-21 openid_discovery");return new wn(e.openid_discovery,{...t,clientId:t?.clientId??e.client_id??"cashu-client"})}async getInfo(t){const e=await(t??this._request)({endpoint:Gt(this._mintUrl,"/v1/info")});return Yi(e,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await this.getInfo();return this._mintInfo=new yn(t),this._mintInfo}async swap(t,e){const n=await this.requestWithAuth("POST","/v1/swap",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"swap"}),new Error("Invalid response from mint");return n}async createMintQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/quote/bolt11",{requestBody:t},e);return Xr(n,this._logger)}async createMintQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/mint/quote/bolt12",{requestBody:t},e)}async checkMintQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/mint/quote/bolt11/${t}`,{},e);return Xr(n,this._logger)}async checkMintQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/mint/quote/bolt12/${t}`,{},e)}async mintBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt11",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt11"}),new Error("Invalid response from mint");return n}async mintBolt12(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt12",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt12"}),new Error("Invalid response from mint");return n}async createMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/melt/quote/bolt11",{requestBody:t},e),s=mn(n,this._logger);if(!yt(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string")throw this._logger.error("Invalid response from mint...",{data:s,op:"createMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async createMeltQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/melt/quote/bolt12",{requestBody:t},e)}async checkMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/melt/quote/bolt11/${t}`,{},e),s=mn(n,this._logger);if(!yt(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string"||typeof s?.state!="string"||!Object.values(oe).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"checkMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async checkMeltQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/melt/quote/bolt12/${t}`,{},e)}async melt(t,e,n){const s={...n?.preferAsync?{Prefer:"respond-async"}:{}};en(!this.isValidMethodString(t),`Invalid melt method: ${t}`,this._logger);const o=await this.requestWithAuth("POST",`/v1/melt/${t}`,{requestBody:e,headers:s},n?.customRequest);if(!yt(o))throw this._logger.error("Invalid response from mint...",{data:o,op:"melt"}),new Error("Invalid response from mint");return o}async meltBolt11(t,e){const n=await this.melt("bolt11",t,e),s=mn(n,this._logger);if(!yt(s)||typeof s?.state!="string"||!Object.values(oe).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"meltBolt11"}),new Error("Invalid response from mint");return s}async meltBolt12(t,e){return this.melt("bolt12",t,e)}async check(t,e){const n=await this.requestWithAuth("POST","/v1/checkstate",{requestBody:t},e);if(!yt(n)||!Array.isArray(n?.states))throw this._logger.error("Invalid response from mint...",{data:n,op:"check"}),new Error("Invalid response from mint");return n}async getKeys(t,e,n){const s=e||this._mintUrl;t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n??this._request)({endpoint:t?Gt(s,"/v1/keys",t):Gt(s,"/v1/keys")});if(!yt(o)||!Array.isArray(o.keysets))throw this._logger.error("Invalid response from mint...",{data:o,op:"getKeys"}),new Error("Invalid response from mint");return o}async getKeySets(t){return(t??this._request)({endpoint:Gt(this._mintUrl,"/v1/keysets")})}async restore(t,e){const n=await(e??this._request)({endpoint:Gt(this._mintUrl,"/v1/restore"),method:"POST",requestBody:t});if(!yt(n)||!Array.isArray(n?.outputs)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"restore"}),new Error("Invalid response from mint");return n}async connectWebSocket(){try{const t=new URL(this._mintUrl),e="v1/ws";t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e,t.protocol=t.protocol==="https:"?"wss:":"ws:";const n=t.toString();this.ws||(this.ws=Yt.getInstance().getConnection(n,this._logger)),await this.ws.ensureConnection()}catch(t){this._logger.error("Failed to connect to WebSocket...",{e:t});try{this.ws?.close()}catch{}throw this.ws=void 0,new Error("Failed to connect to WebSocket...")}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleClearAuth(t,e){if(!(!this._authProvider||!(await this.getLazyMintInfo()).requiresClearAuthToken(t,e)))return this._logger.error("Clear Authentication Token...",{cat:this._authProvider.getCAT()}),this._authProvider.getCAT()}async handleBlindAuth(t,e){if(!this._authProvider||!(await this.getLazyMintInfo()).requiresBlindAuthToken(t,e))return;const n=await this._authProvider.getBlindAuthToken({method:t,path:e});return this._logger.error("Blind Authentication Token...",{bat:n}),n}async requestWithAuth(t,e,n={},s){const o=s??this._request,i=await this.handleBlindAuth(t,e),a=await this.handleClearAuth(t,e),c={...n.headers??{},...i?{"Blind-auth":i}:{},...a?{"Clear-auth":a}:{}};return o({...n,endpoint:Gt(this._mintUrl,e),method:t,headers:c})}isValidMethodString(t){return!!(typeof t=="string"&&/^[a-z0-9_-]+$/.test(t))}}class ie{constructor(t,e,n,s,o){this._keys={},this._id=t,this._unit=e,this._active=n,this._input_fee_ppk=s,this._final_expiry=o}get id(){return this._id}get unit(){return this._unit}get isActive(){return this._active}get fee(){return this._input_fee_ppk??0}get expiry(){return this._final_expiry}get hasKeys(){return Object.keys(this._keys).length>0}get hasHexId(){return Zt(this._id)}get keys(){return this._keys}set keys(t){this._keys=t}get active(){return this.isActive}get input_fee_ppk(){return this.fee}get final_expiry(){return this.expiry}toMintKeyset(){return{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry}}toMintKeys(){return this.hasKeys?{id:this._id,unit:this._unit,keys:this._keys}:null}verify(){return this.hasKeys?ie.verifyKeysetId({id:this._id,unit:this._unit,final_expiry:this._final_expiry,keys:this._keys}):!1}static verifyKeysetId(t){if(!t.keys||Object.keys(t.keys).length===0)return!1;const e=sn(t.id)&&!Zt(t.id),n=Zt(t.id)?G(t.id)[0]:0;return ji(t.keys,t.unit,t.final_expiry,n,e)===t.id}static fromMintApi(t,e){const n=new ie(t.id,t.unit,t.active,t.input_fee_ppk,t.final_expiry);if(e){if(e.id!==t.id)throw new Error(`Mismatched keyset ids: meta=${t.id}, keys=${e.id}`);if(e.unit!==t.unit)throw new Error(`Mismatched keyset units: meta=${t.unit}, keys=${e.unit}`);if(e.final_expiry!==void 0&&t.final_expiry!==void 0&&e.final_expiry!==t.final_expiry)throw new Error(`Mismatched keyset expiry for id=${t.id}`);n.keys=e.keys}return n}}class Lt{constructor(t,e,n,s){if(this.keysets={},this.mint=typeof t=="string"?new ts(t):t,this.unit=e,n&&s){const o=Array.isArray(s)?s:[s];this.buildKeychain(n,o),this.getCheapestKeyset()}}static fromCache(t,e){const n=new Lt(t,e.unit);return n.loadFromCache(e),n}static mintToCacheDTO(t,e,n,s){const o=new Map(s.map(i=>[i.id,i]));return{keysets:n.map(i=>{const a=o.get(i.id),c={...i};return a&&(c.keys=a.keys),c}),unit:t,mintUrl:e}}static cacheToMintDTO(t){const e=t.keysets.map(s=>({id:s.id,unit:s.unit,active:s.active,input_fee_ppk:s.input_fee_ppk,final_expiry:s.final_expiry})),n=t.keysets.filter(s=>!!s.keys).map(s=>({id:s.id,unit:s.unit,keys:s.keys,final_expiry:s.final_expiry}));return{keysets:e,keys:n}}async init(t){if(Object.keys(this.keysets).length>0&&!t)return;const[e,n]=await Promise.all([this.mint.getKeySets(),this.mint.getKeys()]);this.buildKeychain(e.keysets,n.keysets),this.getCheapestKeyset()}loadFromCache(t){if(t.unit!==this.unit)throw new Error(`KeyChain unit mismatch in cache, expected '${this.unit}', got '${t.unit}' from ${t.mintUrl}`);const{keysets:e,keys:n}=Lt.cacheToMintDTO(t);this.buildKeychain(e,n),this.getCheapestKeyset()}buildKeychain(t,e){this.keysets={};const n=t.filter(o=>o.unit===this.unit);if(!n.length)throw new Error(`No Keysets found for unit: ${this.unit}`);const s=new Map(e.filter(o=>o.unit===this.unit).map(o=>[o.id,o]));for(const o of n){let i;if(o.active&&Zt(o.id)){const a=s.get(o.id);i=ie.fromMintApi(o,a)}else i=ie.fromMintApi(o);if(i.hasKeys&&!i.verify())throw new Error(`Keyset verification failed for ID ${i.id}`);this.keysets[i.id]=i}}getKeyset(t){const e=t?this.keysets[t]:this.getCheapestKeyset();if(!e)throw new Error(`Keyset '${t}' not found`);return e}getCheapestKeyset(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");const t=Object.values(this.keysets).filter(e=>e.isActive&&e.hasHexId&&e.hasKeys);if(t.length===0)throw new Error("No active keyset found");return t.sort((e,n)=>e.fee-n.fee)[0]}getKeysets(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");return Object.values(this.keysets)}getAllKeys(){return this.getKeysets().map(t=>t.toMintKeys()).filter(t=>t!==null)}getAllKeysetIds(){return this.getKeysets().map(t=>t.id)}get cache(){const t=this.getKeysets(),e=t.map(s=>s.toMintKeyset()),n=t.map(s=>s.toMintKeys()).filter(s=>s!==null);return Lt.mintToCacheDTO(this.unit,this.mint.mintUrl,e,n)}getCache(){const t=this.cache,{keysets:e,keys:n}=Lt.cacheToMintDTO(t);return{keysets:e,keys:n,unit:t.unit,mintUrl:t.mintUrl}}}class bn{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const Ji=new Set(["locktime","pubkeys","n_sigs","refund","n_sigs_refund"]);function Xi(r){if(!r||typeof r!="string")throw new Error("tag key must be a non empty string");if(Ji.has(r))throw new Error(`additionalTags must not use reserved key "${r}"`)}const es=1024,vn=new WeakMap;function ta(r,t){t&&vn.set(r,t)}function ea(r){const t=vn.get(r);if(t)return vn.delete(r),t}class ft{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:G(t.dleq.s),e:G(t.dleq.e),r:this.blindingFactor});const s={id:t.id,amount:t.amount,C_:Vt(t.C_)},o=Vt(e.keys[t.amount]),i=ai(s,this.blindingFactor,this.secret,o),a={...ci(i),...n&&{dleq:{s:tt(n.s),e:tt(n.e),r:hn(n.r??BigInt(0))}}},c=ea(this);return c&&(a.p2pk_e=c),a}static createP2PKData(t,e,n,s){return Ct(e,n.keys,s).map(o=>this.createSingleP2PKData(t,o,n.id))}static createSingleP2PKData(t,e,n){const s=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],o=t.refundKeys??[],i=Math.max(1,Math.min(t.requiredSignatures??1,s.length)),a=Math.max(1,Math.min(t.requiredRefundSignatures??1,o.length||1));if(s.length===0)throw new Error("P2PK requires at least one pubkey");const c=typeof t.hashlock=="string"&&t.hashlock.length>0;let l=c?t.hashlock:s[0],h=c?s:s.slice(1),d=o,g;if(t.blindKeys){const Y=[...s,...o],{blinded:N,Ehex:C}=mi(Y,n);c?h=N.slice(0,s.length):(l=N[0],h=N.slice(1,s.length)),d=N.slice(s.length),g=C}const p=[],y=t.locktime??NaN;if(Number.isSafeInteger(y)&&y>=0&&p.push(["locktime",String(y)]),h.length>0&&(p.push(["pubkeys",...h]),i>1&&p.push(["n_sigs",String(i)])),d.length>0&&(p.push(["refund",...d]),a>1&&p.push(["n_sigs_refund",String(a)])),t.sigFlag=="SIG_ALL"&&p.push(["sigflag","SIG_ALL"]),t.additionalTags?.length){const Y=t.additionalTags.map(([N,...C])=>(Xi(N),[N,...C.map(String)]));p.push(...Y)}const I=[c?"HTLC":"P2PK",{nonce:tt(qt(32)),data:l,tags:p}],k=JSON.stringify(I),O=[...k].length;if(O>es)throw new Error(`Secret too long (${O} characters), maximum is ${es}`);const $=new TextEncoder().encode(k),{r:U,B_:R}=an($),j=new ft(new bn(e,R,n).getSerializedBlindedMessage(),U,$);return t.blindKeys&&g&&ta(j,g),j}static createRandomData(t,e,n){return Ct(t,e.keys,n).map(s=>this.createSingleRandomData(s,e.id))}static createSingleRandomData(t,e){const n=tt(qt(32)),s=new TextEncoder().encode(n),{r:o,B_:i}=an(s);return new ft(new bn(t,i,e).getSerializedBlindedMessage(),o,s)}static createDeterministicData(t,e,n,s,o){return Ct(t,s.keys,o).map((i,a)=>this.createSingleDeterministicData(i,e,n+a,s.id))}static createSingleDeterministicData(t,e,n,s){const o=Oi(e,s,n),i=tt(o),a=new TextEncoder().encode(i),c=z.toBigInt(qi(e,s,n)),{r:l,B_:h}=an(a,c);return new ft(new bn(t,h,s).getSerializedBlindedMessage(),l,a)}static sumOutputAmounts(t){return t.reduce((e,n)=>e+n.blindedMessage.amount,0)}}const na=(r,t,e,n=!1,s=!1,o=ht)=>{const i=Co();let a=null,c=1/0,l=0,h=0;const d=N=>{try{return e.getKeyset(N.id).fee}catch(C){_e(`Could not get fee. No keyset found for keyset id: ${N.id}`,o,{error:C,keychain:e.getKeysets()})}},g=(N,C)=>N-(n?Math.ceil(C/1e3):0),p=N=>{const C=[...N];for(let M=C.length-1;M>0;M--){const K=Math.floor(Math.random()*(M+1));[C[M],C[K]]=[C[K],C[M]]}return C},y=(N,C,M)=>{let K=0,J=N.length-1,L=null;for(;K<=J;){const E=Math.floor((K+J)/2),x=N[E].exFee;(M?x<=C:x>=C)?(L=E,M?K=E+1:J=E-1):M?J=E-1:K=E+1}return M?L:K<N.length?K:null},I=(N,C)=>{const M=C.exFee;let K=0,J=N.length;for(;K<J;){const L=Math.floor((K+J)/2);N[L].exFee<M?K=L+1:J=L}N.splice(K,0,C)},k=(N,C)=>g(N,C)<t?1/0:N+C/1e3-t;let O=0,$=0;const U=r.map(N=>{const C=d(N),M=n?N.amount-C/1e3:N.amount,K={proof:N,exFee:M,ppkfee:C};return(!n||M>0)&&(O+=N.amount,$+=C),K});let R=n?U.filter(N=>N.exFee>0):U;if(R.sort((N,C)=>N.exFee-C.exFee),R.length>0){let N;if(s){const C=y(R,t,!0);N=C!==null?C+1:0}else{const C=y(R,t,!1);if(C!==null){const M=R[C].exFee,K=y(R,M,!0);Mr(K,"Unexpected null rightIndex in binary search",o),N=K+1}else N=R.length}for(let C=N;C<R.length;C++)O-=R[C].proof.amount,$-=R[C].ppkfee;R=R.slice(0,N)}const j=g(O,$);if(t<=0||t>j)return{keep:r,send:[]};const Y=Math.min(Math.ceil(t*(1+0/100)),t+0,j);for(let N=0;N<60;N++){const C=[];let M=0,K=0;for(const w of p(R)){const m=M+w.proof.amount,b=K+w.ppkfee,_=g(m,b);if(s&&_>t||(C.push(w),M=m,K=b,_>=t))break}const J=new Set(C),L=R.filter(w=>!J.has(w)),E=p(Array.from({length:C.length},(w,m)=>m)).slice(0,5e3);for(const w of E){const m=g(M,K);if(m===t||!s&&m>=t&&m<=Y)break;const b=C[w],_=M-b.proof.amount,A=K-b.ppkfee,f=g(_,A),u=t-f,v=y(L,u,s);if(v!==null){const S=L[v];(!s||S.exFee>b.exFee)&&(u>=0||S.exFee<=b.exFee)&&(C[w]=S,M=_+S.proof.amount,K=A+S.ppkfee,L.splice(v,1),I(L,b))}}const x=k(M,K);if(x<c){o.debug(`selectProofsToSend: best solution found in trial #${N} - amount: ${M}, delta: ${x}`),a=[...C].sort((m,b)=>b.exFee-m.exFee),c=x,l=M,h=K;const w=[...a];for(;w.length>1&&c>0;){const m=w.pop(),b=M-m.proof.amount,_=K-m.ppkfee,A=k(b,_);if(A==1/0)break;A<c&&(a=[...w],c=A,l=b,h=_,M=b,K=_)}}if(a&&c<1/0){const w=g(l,h);if(w===t||!s&&w>=t&&w<=Y)break}if(i.elapsed()>1e3){en(s,"Proof selection took too long. Try again with a smaller proof set.",o),o.warn("Proof selection took too long. Returning best selection so far.");break}}if(a&&c<1/0){const N=a.map(K=>K.proof),C=new Set(N),M=r.filter(K=>!C.has(K));return o.info(`Proof selection took ${i.elapsed()}ms`),{keep:M,send:N}}return{keep:r,send:[]}};class ra{constructor(t){if(this.next=new Map,this.locks=new Map,t)for(const[e,n]of Object.entries(t))this.next.set(e,n)}async withLock(t,e){const n=this.locks.get(t)??Promise.resolve();let s;const o=new Promise(a=>s=a),i=n.then(()=>o);this.locks.set(t,i);try{return await n,await e()}finally{s(),this.locks.get(t)===i&&this.locks.delete(t)}}async reserve(t,e){if(e<0)throw new Error("reserve called with negative count");return this.withLock(t,()=>{const n=this.next.get(t)??0;return e===0?{start:n,count:0}:(this.next.set(t,n+e),{start:n,count:e})})}async advanceToAtLeast(t,e){await this.withLock(t,()=>{const n=this.next.get(t)??0;e>n&&this.next.set(t,e)})}async setNext(t,e){await this.withLock(t,()=>{if(e<0)throw new Error("setNext: negative next not allowed");this.next.set(t,e)})}snapshot(){return Promise.resolve(Object.fromEntries(this.next.entries()))}}class sa{constructor(t){this.wallet=t}send(t,e){return new oa(this.wallet,t,e)}receive(t){return new ia(this.wallet,t)}mintBolt11(t,e){return new ns(this.wallet,"bolt11",t,e)}mintBolt12(t,e){return new ns(this.wallet,"bolt12",t,e)}meltBolt11(t,e){return new rs(this.wallet,"bolt11",t,e)}meltBolt12(t,e){return new rs(this.wallet,"bolt12",t,e)}}class oa{constructor(t,e,n){this.wallet=t,this.amount=e,this.proofs=n,this.config={}}asRandom(t){return this.sendOT={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.sendOT={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.sendOT={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.sendOT={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.sendOT={type:"custom",data:t},this}keepAsRandom(t){return this.keepOT={type:"random",denominations:t},this}keepAsDeterministic(t=0,e){return this.keepOT={type:"deterministic",counter:t,denominations:e},this}keepAsP2PK(t,e){return this.keepOT={type:"p2pk",options:t,denominations:e},this}keepAsFactory(t,e){return this.keepOT={type:"factory",factory:t,denominations:e},this}keepAsCustom(t){return this.keepOT={type:"custom",data:t},this}includeFees(t=!0){return this.config.includeFees=t,this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}offlineExactOnly(t=!1){return this.offlineExact={requireDleq:t},this}offlineCloseMatch(t=!1){return this.offlineClose={requireDleq:t},this}async prepare(){const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.prepareSwapToSend(this.amount,this.proofs,this.config,t)}async run(){if((this.offlineExact||this.offlineClose)&&(this.sendOT||this.keepOT))throw new Error("Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.");if(this.offlineExact)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!0,requireDleq:this.offlineExact.requireDleq});if(this.offlineClose)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!1,requireDleq:this.offlineClose.requireDleq});const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.send(this.amount,this.proofs,this.config,t)}}class ia{constructor(t,e){this.wallet=t,this.token=e,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}requireDleq(t=!0){return this.config.requireDleq=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async prepare(){return this.wallet.prepareSwapToReceive(this.token,this.config,this.outputType)}async run(){return this.wallet.receive(this.token,this.config,this.outputType)}}class ns{constructor(t,e,n,s){this.wallet=t,this.method=e,this.amount=n,this.quote=s,this.config={},this._hasPrivkey}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){if(this.method==="bolt11"){const e=this.quote;if(typeof e!="string"&&e.pubkey&&!this.config.privkey)throw new Error("privkey is required for locked BOLT11 mint quotes");return this.wallet.mintProofsBolt11(this.amount,e,this.config,this.outputType)}const t=this.quote;if(!this.config.privkey)throw new Error("privkey is required for BOLT12 mint quotes");return this.wallet.mintProofsBolt12(this.amount,t,this.config.privkey,this.config,this.outputType)}}class rs{constructor(t,e,n,s){this.wallet=t,this.method=e,this.quote=n,this.proofs=s,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}onChangeOutputsCreated(t){return this.config.onChangeOutputsCreated=t,this}async prepare(){return await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType)}async run(){const t=await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType);return this.wallet.completeMelt(t,this.config.privkey)}}function aa(r){const t=new WeakSet;try{return JSON.stringify(r,(e,n)=>{if(typeof n=="object"&&n!==null){if(t.has(n))return"[Circular]";t.add(n)}return n})}catch{return Object.prototype.toString.call(r)}}function ss(r){if(r instanceof Error)return r;const t=typeof r=="string"?r:aa(r),e=new Error(t);return e.cause=r,e}function os(){const r=new Error("Aborted");return Object.defineProperty(r,"name",{value:"AbortError"}),r}function Ft(r){r&&Promise.resolve(r).then(t=>{try{t()}catch{}}).catch(()=>{})}class ca{constructor(t){this.wallet=t,this.countersReservedHandlers=new Set,this.meltBlanksHandlers=new Set}withAbort(t,e){if(!t)return e;if(t.aborted)return e(),()=>{};const n=()=>e();return t.addEventListener("abort",n,{once:!0}),()=>{t.removeEventListener("abort",n),e()}}waitUntilPaid(t,e,n,s="Timeout waiting for paid"){return new Promise((o,i)=>{let a=null,c=null,l=!1;const h=g=>{l||(l=!0,Ft(a),c&&(clearTimeout(c),c=null),n?.signal&&n.signal.removeEventListener("abort",d),g&&i(ss(g)))},d=()=>h(os());if(n?.signal){if(n.signal.aborted)return d();n.signal.addEventListener("abort",d,{once:!0})}n?.timeoutMs&&n.timeoutMs>0&&(c=setTimeout(()=>h(new Error(s)),n.timeoutMs)),a=t(e,g=>{h(),o(g)},g=>h(g),{signal:n?.signal}),a.catch(g=>h(g))})}countersReserved(t,e){this.countersReservedHandlers.add(t);const n=()=>this.countersReservedHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitCountersReserved(t){for(const e of this.countersReservedHandlers)se(e,t,this.wallet.logger,{event:"countersReserved"})}meltBlanksCreated(t,e){this.meltBlanksHandlers.add(t);const n=()=>this.meltBlanksHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitMeltBlanksCreated(t){for(const e of this.meltBlanksHandlers)se(e,t,this.wallet.logger,{event:"meltBlanksCreated"})}async mintQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const o=this.wallet.mint.webSocketConnection;if(!o)throw new Error("Failed to establish WebSocket connection.");const i=Array.from(new Set(t)),a=o.createSubscription({kind:"bolt11_mint_quote",filters:i},e,n),c=()=>o.cancelSubscription(a,e);return this.withAbort(s?.signal,c)}async mintQuotePaid(t,e,n,s){return this.mintQuoteUpdates([t],o=>{o.state===pn.PAID&&e(o)},n,s)}async meltQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const o=this.wallet.mint.webSocketConnection;if(!o)throw new Error("Failed to establish WebSocket connection.");const i=Array.from(new Set(t)),a=o.createSubscription({kind:"bolt11_melt_quote",filters:i},e,n),c=()=>o.cancelSubscription(a,e);return this.withAbort(s?.signal,c)}async meltQuotePaid(t,e,n,s){return this.meltQuoteUpdates([t],o=>{o.state===oe.PAID&&e(o)},n,s)}async proofStateUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const o=this.wallet.mint.webSocketConnection;if(!o)throw new Error("Failed to establish WebSocket connection.");const i=new TextEncoder,a={};for(const g of t){const p=Ae(i.encode(g.secret)).toHex(!0);a[p]=g}const c=Object.keys(a),l=g=>{e({...g,proof:a[g.Y]})},h=o.createSubscription({kind:"proof_state",filters:c},l,n),d=()=>o.cancelSubscription(h,l);return this.withAbort(s?.signal,d)}onceMintPaid(t,e){return this.waitUntilPaid(this.mintQuotePaid.bind(this),t,e,"Timeout waiting for mint paid")}onceAnyMintPaid(t,e){return new Promise((n,s)=>{const o=Array.from(new Set(t)),i=new Map;let a=null,c=null,l=!1,h=!1;const d=p=>{if(!h){h=!0;for(const y of i.values())Ft(y);i.clear(),a&&(clearTimeout(a),a=null),e?.signal&&e.signal.removeEventListener("abort",g),p&&s(ss(p))}},g=()=>d(os());if(e?.signal){if(e.signal.aborted)return g();e.signal.addEventListener("abort",g,{once:!0})}if(e?.timeoutMs&&e.timeoutMs>0&&(a=setTimeout(()=>d(new Error("Timeout waiting for any mint paid")),e.timeoutMs)),o.length===0)return d(new Error("No quote ids provided"));for(const p of o){const y=this.mintQuotePaid(p,I=>{d(),n({id:p,quote:I})},I=>{if(e?.failOnError){d(I);return}c=I;const k=i.get(p);k&&(Ft(k),i.delete(p)),l&&i.size===0&&d(c??new Error("No subscriptions remaining"))});i.set(p,y),y.catch(I=>{if(e?.failOnError){d(I);return}c=I;const k=i.get(p);k&&(Ft(k),i.delete(p)),l&&i.size===0&&d(c??new Error("No subscriptions remaining"))})}l=!0})}onceMeltPaid(t,e){return this.waitUntilPaid(this.meltQuotePaid.bind(this),t,e,"Timeout waiting for melt paid")}proofStatesStream(t,e){return(async function*(){const n=[];let s=!1,o=null;const i=e?.maxBuffer&&e.maxBuffer>0?e.maxBuffer:1/0,a=e?.drop??"oldest",c=()=>{const g=o;o=null,g&&g()},l=g=>{if(n.length>=i)if(a==="oldest"){const p=n.shift();if(p!==void 0)try{e?.onDrop?.(p)}catch{}n.push(g)}else{try{e?.onDrop?.(g)}catch{}return}else n.push(g);c()},h=this.proofStateUpdates(t,g=>{l(g)},()=>{s=!0,c()},{signal:e?.signal}),d=()=>{s=!0,c()};try{for(e?.signal&&(e.signal.aborted?d():e.signal.addEventListener("abort",d,{once:!0}));!s||n.length;){for(;n.length;)yield n.shift();if(s)break;await new Promise(g=>o=g)}}finally{Ft(h),e?.signal&&e.signal.removeEventListener("abort",d)}}).call(this)}group(){const t=[];let e=!1;const n=(()=>{if(!e)for(e=!0;t.length;)Ft(t.pop())});return n.add=s=>e?(Ft(s),s):(t.push(s),s),Object.defineProperty(n,"cancelled",{get:()=>e,enumerable:!0}),n}}class ua{constructor(t){this.src=t}async peekNext(t){return(await this.src.reserve(t,0)).start}async advanceToAtLeast(t,e){await this.src.advanceToAtLeast(t,e)}async setNext(t,e){if(typeof this.src.setNext=="function"){await this.src.setNext(t,e);return}throw new Error("CounterSource does not support setNext()")}async snapshot(){if(typeof this.src.snapshot=="function")return await this.src.snapshot();throw new Error("CounterSource does not support snapshot()")}}const kn="__PENDING__";class En{constructor(t,e){if(this._seed=void 0,this._unit="sat",this._mintInfo=void 0,this._denominationTarget=3,this._secretsPolicy="auto",this._boundKeysetId=kn,this.swap=this.send.bind(this),this.ops=new sa(this),this.on=new ca(this),this._logger=e?.logger??ht,this._selectProofs=e?.selectProofs??na,this.mint=typeof t=="string"?new ts(t,{authProvider:e?.authProvider,logger:this._logger}):t,this._unit=e?.unit??this._unit,this._boundKeysetId=e?.keysetId??this._boundKeysetId,e?.bip39seed&&(this.failIf(!(e.bip39seed instanceof Uint8Array),"bip39seed must be a valid Uint8Array",{bip39seed:e.bip39seed}),this._seed=e.bip39seed),this._secretsPolicy=e?.secretsPolicy??this._secretsPolicy,e?.counterSource?this._counterSource=e.counterSource:this._counterSource=new ra(e?.counterInit),this.counters=new ua(this._counterSource),this._keyChain=new Lt(this.mint,this._unit),this._denominationTarget=e?.denominationTarget??this._denominationTarget,e?.keysets&&e?.keys&&e?.mintInfo){const n=Array.isArray(e.keys)?e.keys:[e.keys],s=Lt.mintToCacheDTO(this._unit,this.mint.mintUrl,e.keysets,n);this.loadMintFromCache(e.mintInfo,s)}}fail(t,e){return _e(t,this._logger,e)}failIf(t,e,n){return en(t,e,this._logger,n)}failIfNullish(t,e,n){return Mr(t,e,this._logger,n)}safeCallback(t,e,n){se(t,e,this._logger,n)}assertAmount(t,e){try{fn(t,!1)}catch(n){this.fail(n.message,{op:e,amount:t})}}async loadMint(t){const e=[];(!this._mintInfo||t)&&e.push(this.mint.getInfo().then(n=>(this._mintInfo=new yn(n),null))),e.push(this._keyChain.init(t).then(()=>null)),await Promise.all(e),this.finishInit()}loadMintFromCache(t,e){this._mintInfo=new yn(t),this._keyChain.loadFromCache(e),this.finishInit()}finishInit(){const t=this._keyChain.getCheapestKeyset().id;if(this._logger.debug("KeyChain",{keychain:this._keyChain.cache}),this._boundKeysetId===kn)this._boundKeysetId=t;else{const e=this._keyChain.getKeyset(this._boundKeysetId);this.failIf(!e.hasKeys,"Wallet keyset has no keys",{keyset:e.id})}this.getMintInfo()}get keyChain(){return this._keyChain}get unit(){return this._unit}getMintInfo(){return this.failIfNullish(this._mintInfo,"Mint info not initialized; call loadMint or loadMintFromCache first"),this._mintInfo}get keysetId(){return this.failIf(this._boundKeysetId===kn,"Wallet not initialised, call loadMint or loadMintFromCache first"),this._boundKeysetId}getKeyset(t){const e=this._keyChain.getKeyset(t??this.keysetId);return this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),e}get logger(){return this._logger}async reserveFor(t,e){return e<=0?{start:0,count:0}:this._counterSource.reserve(t,e)}countersNeeded(t){return t.type!=="deterministic"||t.counter!==0?0:(t.denominations??[]).length}async addCountersToOutputTypes(t,...e){const n=e.filter(l=>l.type==="deterministic"&&l.counter>0&&(l.denominations?.length??0)>0);if(n.length>1){const l=n.map(h=>({start:h.counter,end:h.counter+h.denominations.length})).sort((h,d)=>h.start-d.start);for(let h=1;h<l.length;h++)this.failIf(l[h].start<l[h-1].end,"Manual counter ranges overlap",{keysetId:t,prev:l[h-1],cur:l[h]})}if(n.length>0){const l=Math.max(...n.map(h=>h.counter+h.denominations.length));await this._counterSource.advanceToAtLeast(t,l),this._logger.debug("Counter source advanced to respect manual deterministic counters",{keysetId:t,maxManualEnd:l})}const s=e.reduce((l,h)=>l+this.countersNeeded(h),0);if(s===0)return{outputTypes:e};const o=await this.reserveFor(t,s);let i=o.start;const a=e.map(l=>{if(l.type==="deterministic"&&l.counter===0){const h=l.denominations?.length??0;if(h>0){const d={...l,counter:i};return i+=h,d}}return l}),c={keysetId:t,start:o.start,count:o.count,next:o.start+o.count};return this.on._emitCountersReserved(c),{outputTypes:a,used:c}}bindKeyset(t){const e=this._keyChain.getKeyset(t);this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),this._boundKeysetId=e.id,this._logger.debug("Wallet bound to keyset",{keysetId:e.id,unit:e.unit,feePPK:e.fee})}withKeyset(t,e){const n=new En(this.mint,{keysetId:t,bip39seed:this._seed,secretsPolicy:this._secretsPolicy,logger:this._logger,counterSource:e?.counterSource??this._counterSource});return n.loadMintFromCache(this.getMintInfo().cache,this._keyChain.cache),n}defaultOutputType(){return this._secretsPolicy==="random"?{type:"random"}:this._secretsPolicy==="deterministic"?(this.failIfNullish(this._seed,"Deterministic policy requires a seed"),{type:"deterministic",counter:0}):this._seed?{type:"deterministic",counter:0}:{type:"random"}}configureOutputs(t,e,n,s=!1,o=[]){let i=t;if(n.type==="custom"){this.failIf(s,"The custom OutputType does not support automatic fee inclusion");const c=ft.sumOutputAmounts(n.data);return this.failIf(c!==t,`Custom output data total (${c}) does not match amount (${t})`),n}let a=n.denominations??[];if(a.length===0&&o.length>0&&(a=Di(o,i,e.keys,this._denominationTarget)),a=Ct(i,e.keys,a),s){let c=this.getFeesForKeyset(a.length,e.id),l=Ct(c,e.keys);for(;this.getFeesForKeyset(a.length+l.length,e.id)>c;)c++,l=Ct(c,e.keys);i+=c,a=[...a,...l]}return{...n,denominations:a}}preparedTotal(t){return t.type==="custom"?ft.sumOutputAmounts(t.data):(t.denominations??[]).reduce((e,n)=>e+n,0)}createOutputData(t,e,n){if(this.failIf(t<0,"Amount was negative",{amount:t}),n.type!="custom"&&n.denominations&&n.denominations.length>0){const o=n.denominations.reduce((i,a)=>i+a,0);this.failIf(o!==t,"Denominations do not sum to the expected amount",{splitSum:o,expected:t})}let s;switch(n.type){case"random":s=ft.createRandomData(t,e,n.denominations);break;case"deterministic":this.failIfNullish(this._seed,"Deterministic outputs require a seed configured in the wallet"),s=ft.createDeterministicData(t,this._seed,n.counter,e,n.denominations);break;case"p2pk":s=ft.createP2PKData(n.options,t,e,n.denominations);break;case"factory":{s=Ct(t,e.keys,n.denominations).map(o=>n.factory(o,e));break}case"custom":{s=n.data;const o=ft.sumOutputAmounts(s);this.failIf(o!==t,`Custom output data total (${o}) does not match amount (${t})`);break}default:this.fail("Invalid OutputType")}return s}createSwapTransaction(t,e,n=[]){t=this._prepareInputsForMint(t);const s=[...e,...n],o=s.map((h,d)=>d);$r(t)||o.sort((h,d)=>s[h].blindedMessage.amount-s[d].blindedMessage.amount);const i=[...Array.from({length:e.length},()=>!0),...Array.from({length:n.length},()=>!1)],a=o.map(h=>s[h]),c=o.map(h=>i[h]),l=a.map(h=>h.blindedMessage);return this._logger.debug("createSwapTransaction:",{indices:o,sortedKeepVector:c}),{payload:{inputs:t,outputs:l},outputData:a,keepVector:c,sortedIndices:o}}async receive(t,e,n){const s=await this.prepareSwapToReceive(t,e,n),{keep:o}=await this.completeSwap(s,e?.privkey);return o}async prepareSwapToReceive(t,e,n){const{keysetId:s,requireDleq:o,proofsWeHave:i,onCountersReserved:a}=e||{};n=n??this.defaultOutputType();const c=typeof t=="string"?this.decodeToken(t):t,l=Gr(c.mint);this.failIf(l!==this.mint.mintUrl,"Token belongs to a different mint",{token:l,wallet:this.mint.mintUrl}),this.failIf(c.unit!==this._unit,"Token is not in wallet unit",{token:c.unit,wallet:this._unit});let h=[];({proofs:h}=c);const d=Tt(h);this.failIf(d===0,"Token contains no proofs",{proofs:h}),this.assertAmount(d,"prepareSwapToReceive");const g=this.getKeyset(s);if(o)for(const $ of h){const U=this._keyChain.getKeyset($.id);Vi($,U)||this.fail("Token contains proofs with invalid or missing DLEQ")}const p=this.getFeesForProofs(h),y=d-p;let I=this.configureOutputs(y,g,n,!1,i);const k=await this.addCountersToOutputTypes(g.id,I);[I]=k.outputTypes,k.used&&this.safeCallback(a,k.used,{op:"receive"}),this._logger.debug("receive counter",{counter:k.used,receiveOT:I});const O=this.createOutputData(this.preparedTotal(I),g,I);return{amount:y,fees:p,keysetId:g.id,inputs:h,keepOutputs:O}}sendOffline(t,e,n){this.assertAmount(t,"sendOffline");const{requireDleq:s=!1,includeFees:o=!1,exactMatch:i=!0}=n||{};s&&(e=e.filter(h=>h.dleq!=null)),this.failIf(Tt(e)<t,"Not enough funds available to send");const{keep:a,send:c}=this.selectProofsToSend(e,t,o,i),l=this._prepareInputsForMint(c,s);return{keep:a,send:l}}async send(t,e,n,s){this.assertAmount(t,"send");const{keysetId:o,includeFees:i=!1}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};try{const c=this.defaultOutputType().type==="deterministic",l=p=>!p||p.type==="random"&&(!p.denominations||p.denominations.length===0);if(o||c||!l(s.send)||s.keep&&!l(s.keep)){const p=[];throw o&&p.push("keysetId override"),c&&p.push("wallet default is deterministic"),l(s.send)||p.push("non-default send output type"),s.keep&&!l(s.keep)&&p.push("non-default keep output type"),new Error(`Options require a swap: ${p.join(", ")}`)}const{keep:h,send:d}=this.sendOffline(t,e,{includeFees:i,exactMatch:!0,requireDleq:!1}),g=i?this.getFeesForProofs(d):0;if(Tt(d)===t+g)return this._logger.info("Successful exactMatch offline selection!"),{keep:h,send:d}}catch(c){const l=c instanceof Error?c.message:"Unknown error";this._logger.debug("ExactMatch offline selection failed.",{e:l})}const a=await this.prepareSwapToSend(t,e,n,s);return await this.completeSwap(a,n?.privkey)}async prepareSwapToSend(t,e,n,s){const{keysetId:o,includeFees:i=!1,onCountersReserved:a}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};const c=this.getKeyset(o);let l=this.configureOutputs(t,c,s.send??this.defaultOutputType(),i);const h=this.preparedTotal(l),{keep:d,send:g}=this.selectProofsToSend(e,h,!0);if(g.length===0)throw new Error("Not enough funds available to send");const p=Tt(g),y=this.getFeesForProofs(g),I=p-y-h;this.failIf(I<0,"Not enough funds available for swap",{selectedSum:p,swapFee:y,sendAmount:h,changeAmount:I});let k=this.configureOutputs(I,c,s.keep??this.defaultOutputType(),!1,n?.proofsWeHave);const O=this.preparedTotal(k),$=await this.addCountersToOutputTypes(c.id,l,k);[l,k]=$.outputTypes,$.used&&this.safeCallback(a,$.used,{op:"send"}),this._logger.debug("send counters",{counter:$.used,sendOT:l,keepOT:k});const U=this.createOutputData(h,c,l),R=this.createOutputData(O,c,k);return{amount:t,fees:y,keysetId:c.id,inputs:g,sendOutputs:U,keepOutputs:R,unselectedProofs:d}}async completeSwap(t,e){const n=t?.keepOutputs?t.keepOutputs:[],s=t.sendOutputs?t.sendOutputs:[],o=t.unselectedProofs?t.unselectedProofs:[];e&&(t.inputs=this.signP2PKProofs(t.inputs,e,[...n,...s]));const i=this.createSwapTransaction(t.inputs,n,s),{signatures:a}=await this.mint.swap(i.payload);this.failIf(a.length<i.outputData.length,`Mint returned ${a.length} signatures, expected ${i.outputData.length}`);const c=this.getKeyset(t.keysetId),l=i.outputData.map((y,I)=>y.toProof(a[I],c)),h=Array(l.length),d=Array(i.keepVector.length);i.sortedIndices.forEach((y,I)=>{d[y]=i.keepVector[I],h[y]=l[I]});const g=[],p=[];return h.forEach((y,I)=>{d[I]?g.push(y):p.push(y)}),this._logger.debug("SEND COMPLETED",{unselectedProofs:o.map(y=>y.amount),keepProofs:g.map(y=>y.amount),sendProofs:p.map(y=>y.amount)}),{keep:[...g,...o],send:p}}selectProofsToSend(t,e,n=!1,s=!1){this.assertAmount(e,"selectProofsToSend");const{keep:o,send:i}=this._selectProofs(t,e,this._keyChain,n,s);return{keep:o,send:i}}signP2PKProofs(t,e,n,s){if(!$r(t))return Kr(t,e,this._logger);this.failIfNullish(n,"OutputData is required for SIG_ALL proof signing."),Ii(t);const[o,...i]=t;let a=o;const c=[Bi(t,n,s),Si(t,n,s),Ai(t,n,s)];for(const l of c)a=Kr([a],e,this._logger,l)[0];return[a,...i]}getFeesForProofs(t){const e=t.reduce((n,s)=>n+this.getProofFeePPK(s),0);return Math.ceil(e/1e3)}getProofFeePPK(t){try{return this._keyChain.getKeyset(t.id).fee}catch(e){this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`,{e,keychain:this._keyChain.getKeysets()})}}getFeesForKeyset(t,e){try{const n=this._keyChain.getKeyset(e).fee;return Math.floor(Math.max((t*n+999)/1e3,0))}catch(n){this.fail(`No keyset found with ID ${e}`,{e:n})}}_prepareInputsForMint(t,e=!1){return t.map(n=>{const s=n.witness&&typeof n.witness!="string"?JSON.stringify(n.witness):n.witness,{dleq:o,p2pk_e:i,...a}=n;return e&&o?{...a,dleq:o,witness:s}:{...a,witness:s}})}decodeToken(t){const e=this._keyChain.getAllKeysetIds();return $i(t,e)}async batchRestore(t=300,e=100,n=0,s){const o=Math.ceil(t/e),i=[];let a,c=0;for(;c<o;){const l=await this.restore(n,e,{keysetId:s});l.proofs.length>0?(c=0,i.push(...l.proofs),a=l.lastCounterWithSignature):c++,n+=e}return{proofs:i,lastCounterWithSignature:a}}async restore(t,e,n){const{keysetId:s}=n||{},o=this.getKeyset(s);this.failIfNullish(this._seed,"Cashu Wallet must be initialized with a seed to use restore");const i=Array(e).fill(0),a=ft.createDeterministicData(0,this._seed,t,o,i),{outputs:c,signatures:l}=await this.mint.restore({outputs:a.map(p=>p.blindedMessage)}),h={};c.forEach((p,y)=>h[p.B_]=l[y]);const d=[];let g;for(let p=0;p<a.length;p++){const y=h[a[p].blindedMessage.B_];y&&(g=t+p,a[p].blindedMessage.amount=y.amount,d.push(a[p].toProof(y,o)))}return{proofs:d,lastCounterWithSignature:g}}async createMintQuote(t,e){return this.createMintQuoteBolt11(t,e)}async createMintQuoteBolt11(t,e){this.assertAmount(t,"createMintQuoteBolt11"),e&&(this.getMintInfo().supportsNut04Description("bolt11",this._unit)||this.fail("Mint does not support description for bolt11"));const n={unit:this._unit,amount:t,description:e},s=await this.mint.createMintQuoteBolt11(n);return{...s,amount:s.amount||t,unit:s.unit||this._unit}}async createLockedMintQuote(t,e,n){this.assertAmount(t,"createLockedMintQuote");const{supported:s}=this.getMintInfo().isSupported(20);this.failIf(!s,"Mint does not support NUT-20");const o={unit:this._unit,amount:t,description:n,pubkey:e},i=await this.mint.createMintQuoteBolt11(o);this.failIf(typeof i.pubkey!="string","Mint returned unlocked mint quote");const a=i.pubkey;return{...i,pubkey:a,amount:i.amount||t,unit:i.unit||this._unit}}async createMintQuoteBolt12(t,e){const n=this.getMintInfo();e?.description&&!n.supportsNut04Description("bolt12",this._unit)&&this.fail("Mint does not support description for bolt12");const s={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(s)}async checkMintQuote(t){return this.checkMintQuoteBolt11(t)}async checkMintQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuoteBolt11(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt11(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt12(t,e,n,s,o){return this._mintProofs("bolt12",t,e,{...s,privkey:n},o)}async _mintProofs(t,e,n,s,o){this.assertAmount(e,`_mintProofs: ${t}`),o=o??this.defaultOutputType();const{privkey:i,keysetId:a,proofsWeHave:c,onCountersReserved:l}=s??{},h=this.getKeyset(a);let d=this.configureOutputs(e,h,o,!1,c);const g=this.preparedTotal(d),p=await this.addCountersToOutputTypes(h.id,d);[d]=p.outputTypes,p.used&&this.safeCallback(l,p.used,{op:"mintProofs"}),this._logger.debug("mint counter",{counter:p.used,mintOT:d});const y=this.createOutputData(g,h,d),I=y.map($=>$.blindedMessage),k={outputs:I,quote:typeof n=="string"?n:n.quote};if(typeof n!="string"&&n.pubkey){this.failIf(!i,"Can not sign locked quote without private key");const $=Ui(i,n.quote,I);k.signature=$}let O;return t==="bolt12"?{signatures:O}=await this.mint.mintBolt12(k):{signatures:O}=await this.mint.mintBolt11(k),this.failIf(O.length!==y.length,`Mint returned ${O.length} signatures, expected ${y.length}`),this._logger.debug("MINT COMPLETED",{amounts:y.map($=>$.blindedMessage.amount)}),y.map(($,U)=>$.toProof(O[U],h))}async createMeltQuote(t,e){return this.createMeltQuoteBolt11(t,e)}async createMeltQuoteBolt11(t,e){e!==void 0&&(this.failIf(Zi(t),"amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices."),this.assertAmount(e,"createMeltQuoteBolt11"));const n=this._mintInfo?.supportsAmountless?.("bolt11",this._unit)??!1,s={unit:this._unit,request:t,...n&&e!==void 0?{options:{amountless:{amount_msat:e}}}:{}},o=await this.mint.createMeltQuoteBolt11(s);return{...o,unit:o.unit||this._unit,request:o.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){this.assertAmount(e,"createMultiPathMeltQuote");const{supported:n,params:s}=this.getMintInfo().isSupported(15);this.failIf(!n,"Mint does not support NUT-15"),this.failIf(!s?.some(i=>i.method==="bolt11"&&i.unit===this._unit),`Mint does not support MPP for bolt11 and ${this._unit}`);const o={unit:this._unit,request:t,options:{mpp:{amount:e}}};return{...await this.mint.createMeltQuoteBolt11(o),request:t,unit:this._unit}}async checkMeltQuote(t){return this.checkMeltQuoteBolt11(t)}async checkMeltQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuoteBolt11(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,n,s){return this.meltProofsBolt11(t,e,n,s)}async meltProofsBolt11(t,e,n,s){const o=await this.prepareMelt("bolt11",t,e,n,s),i=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(o,n?.privkey,i)}async meltProofsBolt12(t,e,n,s){const o=await this.prepareMelt("bolt12",t,e,n,s),i=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(o,n?.privkey,i)}async prepareMelt(t,e,n,s,o){o=o??this.defaultOutputType();const{keysetId:i,onChangeOutputsCreated:a,onCountersReserved:c}=s||{},l=this.getKeyset(i),h=Tt(n),d=h-e.amount;let g=[];if(this.failIf(d<0,"Not enough proofs to cover amount + fee reserve",{sendAmount:h,quoteAmount:e.amount}),d>0){let y=Math.ceil(Math.log2(d))||1;y<0&&(y=0);const I=y?new Array(y).fill(0):[];this._logger.debug("Creating NUT-08 blanks for fee reserve",{feeReserve:d,denominations:I}),o.type==="custom"&&this.fail("Custom OutputType not supported for melt change (must be 0-sat blanks)");let k={...o,denominations:I};const O=await this.addCountersToOutputTypes(l.id,k);[k]=O.outputTypes,O.used&&this.safeCallback(c,O.used,{op:"meltProofs"}),this._logger.debug("melt counter",{counter:O.used,meltOT:k}),g=this.createOutputData(0,l,k)}const p={method:t,inputs:n,outputData:g,keysetId:l.id,quote:e};if(g.length>0){const y={method:t,payload:{quote:e.quote,inputs:n,outputs:g.map(I=>I.blindedMessage)},outputData:g,keyset:l,quote:e};this.safeCallback(a,y,{op:"meltProofs"}),this.on._emitMeltBlanksCreated(y)}return p}async completeMelt(t,e,n){this._logger.debug("meltPreview",{meltPreview:t}),t=this.maybeConvertMeltBlanks(t),this._logger.debug("meltPreview post covert",{meltPreview:t});let s=t.inputs;this._logger.debug("inputs",{inputs:s});const o=t.outputData.map(d=>d.blindedMessage),i=t.quote.quote,a=this.getKeyset(t.keysetId);e&&(s=this.signP2PKProofs(s,e,t.outputData,i)),s=this._prepareInputsForMint(s),this._logger.debug("inputs post prepare",{inputs:s});const c={quote:i,inputs:s,outputs:o},l=t.method==="bolt11"?await this.mint.meltBolt11(c,{preferAsync:n}):await this.mint.melt(t.method,c,{preferAsync:n});this.failIf((l.change?.length??0)>t.outputData.length,`Mint returned ${l.change?.length??0} signatures, but only ${t.outputData.length} blanks were provided`);const h=l.change?.map((d,g)=>t.outputData[g].toProof(d,a))??[];return n?this._logger.debug("ASYNC MELT REQUESTED",l):this._logger.debug("MELT COMPLETED",{changeAmounts:h.map(d=>d.amount)}),{quote:{...t.quote,...l},change:h}}maybeConvertMeltBlanks(t){if(!("payload"in t))return t;this._logger.warn("MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.");const{method:e,payload:n,outputData:s,keyset:o,quote:i}=t;return{method:e,inputs:n.inputs,outputData:s,keysetId:o.id,quote:i}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(i=>Ae(e.encode(i.secret)).toHex(!0)),s=100,o=[];for(let i=0;i<n.length;i+=s){const a=n.slice(i,i+s),{states:c}=await this.mint.check({Ys:a}),l={};c.forEach(h=>{l[h.Y]=h});for(let h=0;h<a.length;h++){const d=l[a[h]];this.failIfNullish(d,"Could not find state for proof with Y: "+a[h]),o.push(d)}}return o}async groupProofsByState(t){const e=await this.checkProofsStates(t),n={unspent:[],pending:[],spent:[]};for(let s=0;s<e.length;s++){const o=t[s];switch(e[s].state){case gn.UNSPENT:n.unspent.push(o);break;case gn.PENDING:n.pending.push(o);break;case gn.SPENT:n.spent.push(o);break}}return n}}var xn={};(function r(t,e,n,s){var o=!!(t.Worker&&t.Blob&&t.Promise&&t.OffscreenCanvas&&t.OffscreenCanvasRenderingContext2D&&t.HTMLCanvasElement&&t.HTMLCanvasElement.prototype.transferControlToOffscreen&&t.URL&&t.URL.createObjectURL),i=typeof Path2D=="function"&&typeof DOMMatrix=="function",a=(function(){if(!t.OffscreenCanvas)return!1;try{var f=new OffscreenCanvas(1,1),u=f.getContext("2d");u.fillRect(0,0,1,1);var v=f.transferToImageBitmap();u.createPattern(v,"no-repeat")}catch{return!1}return!0})();function c(){}function l(f){var u=e.exports.Promise,v=u!==void 0?u:t.Promise;return typeof v=="function"?new v(f):(f(c,c),null)}var h=(function(f,u){return{transform:function(v){if(f)return v;if(u.has(v))return u.get(v);var S=new OffscreenCanvas(v.width,v.height),P=S.getContext("2d");return P.drawImage(v,0,0),u.set(v,S),S},clear:function(){u.clear()}}})(a,new Map),d=(function(){var f=Math.floor(16.666666666666668),u,v,S={},P=0;return typeof requestAnimationFrame=="function"&&typeof cancelAnimationFrame=="function"?(u=function(B){var q=Math.random();return S[q]=requestAnimationFrame(function T(F){P===F||P+f-1<F?(P=F,delete S[q],B()):S[q]=requestAnimationFrame(T)}),q},v=function(B){S[B]&&cancelAnimationFrame(S[B])}):(u=function(B){return setTimeout(B,f)},v=function(B){return clearTimeout(B)}),{frame:u,cancel:v}})(),g=(function(){var f,u,v={};function S(P){function B(q,T){P.postMessage({options:q||{},callback:T})}P.init=function(T){var F=T.transferControlToOffscreen();P.postMessage({canvas:F},[F])},P.fire=function(T,F,D){if(u)return B(T,null),u;var H=Math.random().toString(36).slice(2);return u=l(function(W){function X(et){et.data.callback===H&&(delete v[H],P.removeEventListener("message",X),u=null,h.clear(),D(),W())}P.addEventListener("message",X),B(T,H),v[H]=X.bind(null,{data:{callback:H}})}),u},P.reset=function(){P.postMessage({reset:!0});for(var T in v)v[T](),delete v[T]}}return function(){if(f)return f;if(!n&&o){var P=["var CONFETTI, SIZE = {}, module = {};","("+r.toString()+")(this, module, true, SIZE);","onmessage = function(msg) {","  if (msg.data.options) {","    CONFETTI(msg.data.options).then(function () {","      if (msg.data.callback) {","        postMessage({ callback: msg.data.callback });","      }","    });","  } else if (msg.data.reset) {","    CONFETTI && CONFETTI.reset();","  } else if (msg.data.resize) {","    SIZE.width = msg.data.resize.width;","    SIZE.height = msg.data.resize.height;","  } else if (msg.data.canvas) {","    SIZE.width = msg.data.canvas.width;","    SIZE.height = msg.data.canvas.height;","    CONFETTI = module.exports.create(msg.data.canvas);","  }","}"].join(`
`);try{f=new Worker(URL.createObjectURL(new Blob([P])))}catch(B){return typeof console<"u"&&typeof console.warn=="function"&&console.warn("ðŸŽŠ Could not load worker",B),null}S(f)}return f}})(),p={particleCount:50,angle:90,spread:45,startVelocity:45,decay:.9,gravity:1,drift:0,ticks:200,x:.5,y:.5,shapes:["square","circle"],zIndex:100,colors:["#26ccff","#a25afd","#ff5e7e","#88ff5a","#fcff42","#ffa62d","#ff36ff"],disableForReducedMotion:!1,scalar:1};function y(f,u){return u?u(f):f}function I(f){return f!=null}function k(f,u,v){return y(f&&I(f[u])?f[u]:p[u],v)}function O(f){return f<0?0:Math.floor(f)}function $(f,u){return Math.floor(Math.random()*(u-f))+f}function U(f){return parseInt(f,16)}function R(f){return f.map(j)}function j(f){var u=String(f).replace(/[^0-9a-f]/gi,"");return u.length<6&&(u=u[0]+u[0]+u[1]+u[1]+u[2]+u[2]),{r:U(u.substring(0,2)),g:U(u.substring(2,4)),b:U(u.substring(4,6))}}function Y(f){var u=k(f,"origin",Object);return u.x=k(u,"x",Number),u.y=k(u,"y",Number),u}function N(f){f.width=document.documentElement.clientWidth,f.height=document.documentElement.clientHeight}function C(f){var u=f.getBoundingClientRect();f.width=u.width,f.height=u.height}function M(f){var u=document.createElement("canvas");return u.style.position="fixed",u.style.top="0px",u.style.left="0px",u.style.pointerEvents="none",u.style.zIndex=f,u}function K(f,u,v,S,P,B,q,T,F){f.save(),f.translate(u,v),f.rotate(B),f.scale(S,P),f.arc(0,0,1,q,T,F),f.restore()}function J(f){var u=f.angle*(Math.PI/180),v=f.spread*(Math.PI/180);return{x:f.x,y:f.y,wobble:Math.random()*10,wobbleSpeed:Math.min(.11,Math.random()*.1+.05),velocity:f.startVelocity*.5+Math.random()*f.startVelocity,angle2D:-u+(.5*v-Math.random()*v),tiltAngle:(Math.random()*(.75-.25)+.25)*Math.PI,color:f.color,shape:f.shape,tick:0,totalTicks:f.ticks,decay:f.decay,drift:f.drift,random:Math.random()+2,tiltSin:0,tiltCos:0,wobbleX:0,wobbleY:0,gravity:f.gravity*3,ovalScalar:.6,scalar:f.scalar,flat:f.flat}}function L(f,u){u.x+=Math.cos(u.angle2D)*u.velocity+u.drift,u.y+=Math.sin(u.angle2D)*u.velocity+u.gravity,u.velocity*=u.decay,u.flat?(u.wobble=0,u.wobbleX=u.x+10*u.scalar,u.wobbleY=u.y+10*u.scalar,u.tiltSin=0,u.tiltCos=0,u.random=1):(u.wobble+=u.wobbleSpeed,u.wobbleX=u.x+10*u.scalar*Math.cos(u.wobble),u.wobbleY=u.y+10*u.scalar*Math.sin(u.wobble),u.tiltAngle+=.1,u.tiltSin=Math.sin(u.tiltAngle),u.tiltCos=Math.cos(u.tiltAngle),u.random=Math.random()+2);var v=u.tick++/u.totalTicks,S=u.x+u.random*u.tiltCos,P=u.y+u.random*u.tiltSin,B=u.wobbleX+u.random*u.tiltCos,q=u.wobbleY+u.random*u.tiltSin;if(f.fillStyle="rgba("+u.color.r+", "+u.color.g+", "+u.color.b+", "+(1-v)+")",f.beginPath(),i&&u.shape.type==="path"&&typeof u.shape.path=="string"&&Array.isArray(u.shape.matrix))f.fill(b(u.shape.path,u.shape.matrix,u.x,u.y,Math.abs(B-S)*.1,Math.abs(q-P)*.1,Math.PI/10*u.wobble));else if(u.shape.type==="bitmap"){var T=Math.PI/10*u.wobble,F=Math.abs(B-S)*.1,D=Math.abs(q-P)*.1,H=u.shape.bitmap.width*u.scalar,W=u.shape.bitmap.height*u.scalar,X=new DOMMatrix([Math.cos(T)*F,Math.sin(T)*F,-Math.sin(T)*D,Math.cos(T)*D,u.x,u.y]);X.multiplySelf(new DOMMatrix(u.shape.matrix));var et=f.createPattern(h.transform(u.shape.bitmap),"no-repeat");et.setTransform(X),f.globalAlpha=1-v,f.fillStyle=et,f.fillRect(u.x-H/2,u.y-W/2,H,W),f.globalAlpha=1}else if(u.shape==="circle")f.ellipse?f.ellipse(u.x,u.y,Math.abs(B-S)*u.ovalScalar,Math.abs(q-P)*u.ovalScalar,Math.PI/10*u.wobble,0,2*Math.PI):K(f,u.x,u.y,Math.abs(B-S)*u.ovalScalar,Math.abs(q-P)*u.ovalScalar,Math.PI/10*u.wobble,0,2*Math.PI);else if(u.shape==="star")for(var Q=Math.PI/2*3,at=4*u.scalar,dt=8*u.scalar,pt=u.x,Et=u.y,Kt=5,wt=Math.PI/Kt;Kt--;)pt=u.x+Math.cos(Q)*dt,Et=u.y+Math.sin(Q)*dt,f.lineTo(pt,Et),Q+=wt,pt=u.x+Math.cos(Q)*at,Et=u.y+Math.sin(Q)*at,f.lineTo(pt,Et),Q+=wt;else f.moveTo(Math.floor(u.x),Math.floor(u.y)),f.lineTo(Math.floor(u.wobbleX),Math.floor(P)),f.lineTo(Math.floor(B),Math.floor(q)),f.lineTo(Math.floor(S),Math.floor(u.wobbleY));return f.closePath(),f.fill(),u.tick<u.totalTicks}function E(f,u,v,S,P){var B=u.slice(),q=f.getContext("2d"),T,F,D=l(function(H){function W(){T=F=null,q.clearRect(0,0,S.width,S.height),h.clear(),P(),H()}function X(){n&&!(S.width===s.width&&S.height===s.height)&&(S.width=f.width=s.width,S.height=f.height=s.height),!S.width&&!S.height&&(v(f),S.width=f.width,S.height=f.height),q.clearRect(0,0,S.width,S.height),B=B.filter(function(et){return L(q,et)}),B.length?T=d.frame(X):W()}T=d.frame(X),F=W});return{addFettis:function(H){return B=B.concat(H),D},canvas:f,promise:D,reset:function(){T&&d.cancel(T),F&&F()}}}function x(f,u){var v=!f,S=!!k(u||{},"resize"),P=!1,B=k(u,"disableForReducedMotion",Boolean),q=o&&!!k(u||{},"useWorker"),T=q?g():null,F=v?N:C,D=f&&T?!!f.__confetti_initialized:!1,H=typeof matchMedia=="function"&&matchMedia("(prefers-reduced-motion)").matches,W;function X(Q,at,dt){for(var pt=k(Q,"particleCount",O),Et=k(Q,"angle",Number),Kt=k(Q,"spread",Number),wt=k(Q,"startVelocity",Number),pa=k(Q,"decay",Number),ga=k(Q,"gravity",Number),ma=k(Q,"drift",Number),hs=k(Q,"colors",R),ya=k(Q,"ticks",Number),fs=k(Q,"shapes"),wa=k(Q,"scalar"),ba=!!k(Q,"flat"),ds=Y(Q),ps=pt,Sn=[],va=f.width*ds.x,ka=f.height*ds.y;ps--;)Sn.push(J({x:va,y:ka,angle:Et,spread:Kt,startVelocity:wt,color:hs[ps%hs.length],shape:fs[$(0,fs.length)],ticks:ya,decay:pa,gravity:ga,drift:ma,scalar:wa,flat:ba}));return W?W.addFettis(Sn):(W=E(f,Sn,F,at,dt),W.promise)}function et(Q){var at=B||k(Q,"disableForReducedMotion",Boolean),dt=k(Q,"zIndex",Number);if(at&&H)return l(function(wt){wt()});v&&W?f=W.canvas:v&&!f&&(f=M(dt),document.body.appendChild(f)),S&&!D&&F(f);var pt={width:f.width,height:f.height};T&&!D&&T.init(f),D=!0,T&&(f.__confetti_initialized=!0);function Et(){if(T){var wt={getBoundingClientRect:function(){if(!v)return f.getBoundingClientRect()}};F(wt),T.postMessage({resize:{width:wt.width,height:wt.height}});return}pt.width=pt.height=null}function Kt(){W=null,S&&(P=!1,t.removeEventListener("resize",Et)),v&&f&&(document.body.contains(f)&&document.body.removeChild(f),f=null,D=!1)}return S&&!P&&(P=!0,t.addEventListener("resize",Et,!1)),T?T.fire(Q,pt,Kt):X(Q,pt,Kt)}return et.reset=function(){T&&T.reset(),W&&W.reset()},et}var w;function m(){return w||(w=x(null,{useWorker:!0,resize:!0})),w}function b(f,u,v,S,P,B,q){var T=new Path2D(f),F=new Path2D;F.addPath(T,new DOMMatrix(u));var D=new Path2D;return D.addPath(F,new DOMMatrix([Math.cos(q)*P,Math.sin(q)*P,-Math.sin(q)*B,Math.cos(q)*B,v,S])),D}function _(f){if(!i)throw new Error("path confetti are not supported in this browser");var u,v;typeof f=="string"?u=f:(u=f.path,v=f.matrix);var S=new Path2D(u),P=document.createElement("canvas"),B=P.getContext("2d");if(!v){for(var q=1e3,T=q,F=q,D=0,H=0,W,X,et=0;et<q;et+=2)for(var Q=0;Q<q;Q+=2)B.isPointInPath(S,et,Q,"nonzero")&&(T=Math.min(T,et),F=Math.min(F,Q),D=Math.max(D,et),H=Math.max(H,Q));W=D-T,X=H-F;var at=10,dt=Math.min(at/W,at/X);v=[dt,0,0,dt,-Math.round(W/2+T)*dt,-Math.round(X/2+F)*dt]}return{type:"path",path:u,matrix:v}}function A(f){var u,v=1,S="#000000",P='"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';typeof f=="string"?u=f:(u=f.text,v="scalar"in f?f.scalar:v,P="fontFamily"in f?f.fontFamily:P,S="color"in f?f.color:S);var B=10*v,q=""+B+"px "+P,T=new OffscreenCanvas(B,B),F=T.getContext("2d");F.font=q;var D=F.measureText(u),H=Math.ceil(D.actualBoundingBoxRight+D.actualBoundingBoxLeft),W=Math.ceil(D.actualBoundingBoxAscent+D.actualBoundingBoxDescent),X=2,et=D.actualBoundingBoxLeft+X,Q=D.actualBoundingBoxAscent+X;H+=X+X,W+=X+X,T=new OffscreenCanvas(H,W),F=T.getContext("2d"),F.font=q,F.fillStyle=S,F.fillText(u,et,Q);var at=1/v;return{type:"bitmap",bitmap:T.transferToImageBitmap(),matrix:[at,0,0,at,-H*at/2,-W*at/2]}}e.exports=function(){return m().apply(this,arguments)},e.exports.reset=function(){m().reset()},e.exports.create=x,e.exports.shapeFromPath=_,e.exports.shapeFromText=A})((function(){return typeof window<"u"?window:typeof self<"u"?self:this||{}})(),xn,!1);const _n=xn.exports;xn.exports.create;async function la(r){if(!r)return Promise.resolve(!1);if(navigator.clipboard&&navigator.clipboard.writeText)return navigator.clipboard.writeText(r).then(()=>!0).catch(()=>!1);try{const t=document.createElement("textarea");t.value=r,t.style.top="0",t.style.left="0",t.style.position="fixed",document.body.appendChild(t),t.focus(),t.select();const e=document.execCommand("copy");return document.body.removeChild(t),Promise.resolve(!!e)}catch{return Promise.resolve(!1)}}function ha(){var r=250,t=Date.now()+r;(function e(){_n({particleCount:7,angle:60,spread:55,origin:{x:0}}),_n({particleCount:7,angle:120,spread:55,origin:{x:1}}),Date.now()<t&&requestAnimationFrame(e)})(),_n.reset()}const ut=r=>new Promise(t=>setTimeout(t,r));function is(r,t="Unknown error"){return r instanceof Error?r.message:typeof r=="string"?r:r&&typeof r=="object"&&"message"in r?String(r.message):t}const Pt=new AbortController;window.addEventListener("pagehide",()=>Pt.abort(),{once:!0}),window.addEventListener("beforeunload",()=>Pt.abort(),{once:!0});const In=new Map;function as(r,t="sat"){const e=`${String(r).replace(/\/+$/,"")}|${t}`,n=In.get(e);if(n)return n;const s=(async()=>{const o=new En(r,{unit:t,logger:new Mo("debug")});return await o.loadMint(),o})();return s.catch(()=>In.delete(e)),In.set(e,s),s}function fa(r){const t=Number(r.data("order-id")),e=String(r.data("order-key")??""),n=String(r.data("return-url")??""),s=Number(r.data("pay-amount-sats")??0),o=String(r.data("melt-quote-id")??""),i=Number(r.data("spot-quote-expiry")??0)*1e3,a=String(r.data("trusted-mint")??"");if(!Number.isFinite(t)||t<=0||!e||!n||!a||!Number.isFinite(s)||s<=0||!o)throw new Error("Bad order data");return{orderId:t,orderKey:e,returnUrl:n,expectedPaySats:s,quoteId:o,quoteExpiryMs:i,trustedMint:a}}function An(r,t){try{const e=new URL(r),n=new URL(t),s=e.origin+e.pathname.replace(/\/+$/,""),o=n.origin+n.pathname.replace(/\/+$/,"");return s===o}catch{return r.replace(/\/+$/,"")===t.replace(/\/+$/,"")}}function cs(r){try{const t=localStorage.getItem(r);return t?JSON.parse(t):null}catch{return null}}function us(r,t){try{localStorage.setItem(r,JSON.stringify(t))}catch{}}function ls(r){try{localStorage.removeItem(r)}catch{}}function da(r){try{const t=cs(r);return!t||!Array.isArray(t.items)||Date.now()-t.created>3600*1e3?{v:1,created:Date.now(),items:[]}:t}catch{return{v:1,created:Date.now(),items:[]}}}jQuery(function(r){const t=r("#cashu-pay-root");if(!t.length)return;const e=t.next("section.cashu-checkout");if(!e.length)return;const n=e.find("form.cashu-token"),s=e.find("[data-cashu-token-input]"),o=n.find('button[type="submit"]'),i=e.find(".cashu-status"),a=e.find("[data-cashu-qr]"),c=(m,b=!1)=>{const _=b?"var(--cashu-warning)":"var(--cashu-status)";i.text(m).css("background-color",_)},l=m=>{o.prop("disabled",m),s.prop("disabled",m)};l(!1),n.off("submit").on("submit",m=>{m.preventDefault();const b=k();if(!b){c("Paste a Cashu token first...",!0);return}R(()=>N(b),{user:!0})});let h;try{h=fa(t)}catch{i.text("Payment data incomplete, please refresh and try again.");return}let d=null,g=Promise.resolve(),p=null,y=0;const I=as(h.trustedMint,"sat"),k=()=>String(s.val()??"").trim(),O={mq:"cashu_wc_mq",change:"cashu_wc_change",recovery:"cashu_wc_recovery"};try{ls(O.change)}catch{}$().catch(()=>{c("Could not prepare the invoice, please refresh and try again",!0)});async function $(){U(),x(),K();const m=localStorage.getItem(O.recovery);m&&N(m).catch(b=>{console.error(b),c("Payment failed. Please copy the new token from the form input below.",!0),s.val(m),localStorage.removeItem(O.recovery)})}async function U(){const m=await C(),b=a.get(0);if(!b||typeof QRCode>"u")return;b.innerHTML="",new QRCode(b,{text:"lightning:"+m.request,width:360,height:360,colorDark:"#000000",colorLight:"#ffffff",correctLevel:QRCode.CorrectLevel.Q}),a.parent().off("click").on("click",async()=>{la(m.request),c("Copied!"),await ut(500),c("Waiting for payment...")})}async function R(m,b={}){const _=!!b.user;if(_&&y>0)return c("Payment already in progress",!0),Promise.resolve(void 0);_&&(y++,y===1&&l(!0));const A=g.then(m).catch(f=>{const u=is(f);c(u,!0)});g=A.then(()=>{});try{return await A}finally{_&&(y--,y===0&&l(!1))}}async function j(m,b){if(m.length<1)return;const _=Tt(m),A=b.getFeesForProofs(m),f=Vr({mint:b.mint.mintUrl,proofs:m,unit:"sat"}),u=An(b.mint.mintUrl,h.trustedMint)?"Change From Network Fee Reserve":"Change From Your Token";Y({mint:b.mint.mintUrl,token:f,amount:_,kind:u,dust:_<=A})}function Y(m){const b=da(O.change);b.items.some(A=>A.token===m.token)||b.items.push(m),b.items=b.items.slice(-5),us(O.change,b)}async function N(m){c("Checking token..."),await ut(500);let b;try{b=Hi(m)}catch(W){console.error(is(W)),c("That token does not look valid",!0);return}const _=String(b.mint??"").trim(),A=String(b.unit??"sat");if(!_||b.amount===0){c("Token has no spendable proofs",!0);return}if(A!=="sat"){c("This checkout expects sat denominated tokens",!0);return}c("Connecting to mint..."),await ut(500);const f=await as(_,"sat");let v=f.decodeToken(m).proofs;if(!Array.isArray(v)||v.length===0){c("Token has no usable proofs",!0);return}if(An(_,h.trustedMint)){const W=await I;await L(v,W);return}const S=await C(),P=Tt(v),B=f.getFeesForProofs(v);c("Calculating your mintâ€™s fees..."),await ut(500);const q=await f.createMeltQuoteBolt11(S.request),T=q.amount+q.fee_reserve+B,F=q.fee_reserve+B;if(P<T){c(`Token amount (â‚¿${P}) is too small. At least â‚¿${T} is required to cover your mint's fees (â‚¿${F})`,!0);return}c("Sending payment to our mint..."),await ut(500);const D=await f.meltProofsBolt11(q,v),H=Array.isArray(D?.change)?D.change:[];j(H,f),c("Waiting for payment confirmation...")}async function C(){return d||(d=(async()=>{const m=cs(O.mq);if(M(m))return m;const _=await(await I).createMintQuoteBolt11(h.expectedPaySats),A={mint:h.trustedMint,amount:h.expectedPaySats,quote:_.quote,request:_.request,expiry:_.expiry??null};return us(O.mq,A),A})(),d.catch(()=>{d=null}),d)}function M(m){if(!m||!m.quote||!m.request||!m.mint||m.amount!==h.expectedPaySats||!An(m.mint,h.trustedMint))return!1;const b=typeof m.expiry=="number"?m.expiry:0,_=Math.floor(Date.now()/1e3);return!(b>0&&b<=_)}async function K(){const m=await C(),b=await I,_=async()=>{const u=h.quoteExpiryMs-Date.now();if(u<=0||Pt.signal.aborted)return!1;const v=Math.max(1e4,u);try{return await Promise.race([b.on.onceMintPaid(m.quote,{signal:Pt.signal,timeoutMs:v}),ut(u).then(()=>{throw new Error("Quote expired")})]),!0}catch{return!1}},A=async()=>{try{for(;!Pt.signal.aborted&&Date.now()<h.quoteExpiryMs;){if((await b.checkMintQuoteBolt11(m.quote)).state==="PAID")return!0;await ut(3e3)}return!1}catch{return!1}};(await _()||!Pt.signal.aborted&&await A())&&R(()=>J(m))}async function J(m){if(p)return p;p=(async()=>{c("Payment received by our mint..."),await ut(500);const b=await I,_=await b.mintProofsBolt11(h.expectedPaySats,m.quote);ls(O.mq),d=null,await L(_,b)})();try{await p}catch(b){throw p=null,b}}async function L(m,b){const _=Vr({mint:h.trustedMint,proofs:m,unit:"sat"});let A;c("Paying invoice...");try{localStorage.setItem(O.recovery,_);const u=await b.checkMeltQuoteBolt11(h.quoteId);A=await b.meltProofsBolt11(u,m)}catch(u){s.val(_),c(u,!0);return}finally{localStorage.removeItem(O.recovery)}const f=Array.isArray(A?.change)?A.change:[];j(f,b),c("Confirming payment...")}async function E(){const m=String(window.cashu_wc?.rest_root??""),b=String(window.cashu_wc?.confirm_route??"");if(!m||!b)return null;const _=m.replace(/\/?$/,"/")+b.replace(/^\//,""),A={order_id:h.orderId,order_key:h.orderKey,quote_id:h.quoteId};try{const u=await(await fetch(_,{method:"POST",headers:{"Content-Type":"application/json"},credentials:"same-origin",body:JSON.stringify(A)})).json();if(u?.state==="PAID")return ha(),await ut(2e3),window.location.assign(String(u.redirect??h.returnUrl)),u;if(u?.state==="EXPIRED")return c("Invoice has expired",!0),await ut(2e3),window.location.assign(String(h.returnUrl)),u;if(u?.expiry){const v="Invoice expires in: "+w(u.expiry),S=u.expiry-Date.now()/1e3;S<60?c(v,!0):S<300&&c(v)}return u??null}catch{return null}}async function x(){if(Pt.signal.aborted||Date.now()>h.quoteExpiryMs){window.location.assign(String(h.returnUrl));return}for(;!Pt.signal.aborted&&Date.now()<=h.quoteExpiryMs;){await ut(3e3);const m=await R(()=>E());if(m?.state==="PAID"||m?.state==="EXPIRED")return}await ut(500),await R(()=>E())}function w(m,b=Date.now()){const _=m*1e3-b,A=Math.max(0,Math.floor(_/1e3)),f=Math.floor(A/60),u=A%60,v=String(f).padStart(2,"0"),S=String(u).padStart(2,"0");return`${v}:${S}`}})})();
