(function(){"use strict";function Me(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Cn(r,t){return Array.isArray(t)?t.length===0?!0:r?t.every(e=>typeof e=="string"):t.every(e=>Number.isSafeInteger(e)):!1}function ms(r){if(typeof r!="function")throw new Error("function expected");return!0}function Ce(r,t){if(typeof t!="string")throw new Error(`${r}: string expected`);return!0}function Te(r){if(!Number.isSafeInteger(r))throw new Error(`invalid integer: ${r}`)}function Pe(r){if(!Array.isArray(r))throw new Error("array expected")}function Tn(r,t){if(!Cn(!0,t))throw new Error(`${r}: array of strings expected`)}function ys(r,t){if(!Cn(!1,t))throw new Error(`${r}: array of numbers expected`)}function Pn(...r){const t=i=>i,e=(i,o)=>a=>i(o(a)),n=r.map(i=>i.encode).reduceRight(e,t),s=r.map(i=>i.decode).reduce(e,t);return{encode:n,decode:s}}function ws(r){const t=typeof r=="string"?r.split(""):r,e=t.length;Tn("alphabet",t);const n=new Map(t.map((s,i)=>[s,i]));return{encode:s=>(Pe(s),s.map(i=>{if(!Number.isSafeInteger(i)||i<0||i>=e)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${r}`);return t[i]})),decode:s=>(Pe(s),s.map(i=>{Ce("alphabet.decode",i);const o=n.get(i);if(o===void 0)throw new Error(`Unknown letter: "${i}". Allowed: ${r}`);return o}))}}function bs(r=""){return Ce("join",r),{encode:t=>(Tn("join.decode",t),t.join(r)),decode:t=>(Ce("join.decode",t),t.split(r))}}function On(r,t,e){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(e<2)throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);if(Pe(r),!r.length)return[];let n=0;const s=[],i=Array.from(r,a=>{if(Te(a),a<0||a>=t)throw new Error(`invalid integer: ${a}`);return a}),o=i.length;for(;;){let a=0,c=!0;for(let l=n;l<o;l++){const h=i[l],d=t*a,g=d+h;if(!Number.isSafeInteger(g)||d/t!==a||g-h!==d)throw new Error("convertRadix: carry overflow");const p=g/e;a=g%e;const y=Math.floor(p);if(i[l]=y,!Number.isSafeInteger(y)||y*e+a!==g)throw new Error("convertRadix: carry overflow");if(c)y?c=!1:n=l;else continue}if(s.push(a),c)break}for(let a=0;a<r.length-1&&r[a]===0;a++)s.push(0);return s.reverse()}function vs(r){Te(r);const t=2**8;return{encode:e=>{if(!Me(e))throw new Error("radix.encode input should be Uint8Array");return On(Array.from(e),t,r)},decode:e=>(ys("radix.decode",e),Uint8Array.from(On(e,r,t)))}}function ks(r,t){return Te(r),ms(t),{encode(e){if(!Me(e))throw new Error("checksum.encode: input should be Uint8Array");const n=t(e).slice(0,r),s=new Uint8Array(e.length+r);return s.set(e),s.set(n,e.length),s},decode(e){if(!Me(e))throw new Error("checksum.decode: input should be Uint8Array");const n=e.slice(0,-r),s=e.slice(-r),i=t(n).slice(0,r);for(let o=0;o<r;o++)if(i[o]!==s[o])throw new Error("Invalid checksum");return n}}}const Es=(r=>Pn(vs(58),ws(r),bs("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),_s=r=>Pn(ks(4,t=>r(r(t))),Es);function Oe(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function qt(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function V(r,t,e=""){const n=Oe(r),s=r?.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function qn(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");qt(r.outputLen),qt(r.blockLen)}function ce(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function xs(r,t){V(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function xt(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function Ht(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function mt(r,t){return r<<32-t|r>>>t}function ue(r,t){return r<<t|r>>>32-t>>>0}const Nn=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Is=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function et(r){if(V(r),Nn)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=Is[r[e]];return t}const vt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Un(r){if(r>=vt._0&&r<=vt._9)return r-vt._0;if(r>=vt.A&&r<=vt.F)return r-(vt.A-10);if(r>=vt.a&&r<=vt.f)return r-(vt.a-10)}function G(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Nn)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=Un(r.charCodeAt(i)),a=Un(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function Dn(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function ot(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];V(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const i=r[n];e.set(i,s),s+=i.length}return e}function qe(r,t={}){const e=(s,i)=>r(i).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function Nt(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const Rn=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function As(r,t,e){return r&t^~r&e}function Ss(r,t,e){return r&t^r&e^t&e}class Ne{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,e,n,s){this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=Ht(this.buffer)}update(t){ce(this),V(t);const{view:e,buffer:n,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Ht(t);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ce(this),xs(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,xt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let d=o;d<s;d++)e[d]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=Ht(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,h=this.get();if(l>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,h[d],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const It=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),st=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),le=BigInt(2**32-1),Ln=BigInt(32);function Bs(r,t=!1){return t?{h:Number(r&le),l:Number(r>>Ln&le)}:{h:Number(r>>Ln&le)|0,l:Number(r&le)|0}}function Ms(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:a}=Bs(r[i],t);[n[i],s[i]]=[o,a]}return[n,s]}const Fn=(r,t,e)=>r>>>e,Kn=(r,t,e)=>r<<32-e|t>>>e,jt=(r,t,e)=>r>>>e|t<<32-e,Wt=(r,t,e)=>r<<32-e|t>>>e,he=(r,t,e)=>r<<64-e|t>>>e-32,fe=(r,t,e)=>r>>>e-32|t<<64-e;function kt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Cs=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Ts=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Ps=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Os=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,qs=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),Ns=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0,Us=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),At=new Uint32Array(64);class Ds extends Ne{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,n,s,i,o,a,c]}set(t,e,n,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let d=0;d<16;d++,e+=4)At[d]=t.getUint32(e,!1);for(let d=16;d<64;d++){const g=At[d-15],p=At[d-2],y=mt(g,7)^mt(g,18)^g>>>3,I=mt(p,17)^mt(p,19)^p>>>10;At[d]=I+At[d-7]+y+At[d-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:l,H:h}=this;for(let d=0;d<64;d++){const g=mt(a,6)^mt(a,11)^mt(a,25),p=h+g+As(a,c,l)+Us[d]+At[d]|0,I=(mt(n,2)^mt(n,13)^mt(n,22))+Ss(n,s,i)|0;h=l,l=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+I|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,h=h+this.H|0,this.set(n,s,i,o,a,c,l,h)}roundClean(){xt(At)}destroy(){this.set(0,0,0,0,0,0,0,0),xt(this.buffer)}}class Rs extends Ds{A=It[0]|0;B=It[1]|0;C=It[2]|0;D=It[3]|0;E=It[4]|0;F=It[5]|0;G=It[6]|0;H=It[7]|0;constructor(){super(32)}}const $n=Ms(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Ls=$n[0],Fs=$n[1],St=new Uint32Array(80),Bt=new Uint32Array(80);class Ks extends Ne{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:h,Fh:d,Fl:g,Gh:p,Gl:y,Hh:I,Hl:k}=this;return[t,e,n,s,i,o,a,c,l,h,d,g,p,y,I,k]}set(t,e,n,s,i,o,a,c,l,h,d,g,p,y,I,k){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=h|0,this.Fh=d|0,this.Fl=g|0,this.Gh=p|0,this.Gl=y|0,this.Hh=I|0,this.Hl=k|0}process(t,e){for(let U=0;U<16;U++,e+=4)St[U]=t.getUint32(e),Bt[U]=t.getUint32(e+=4);for(let U=16;U<80;U++){const R=St[U-15]|0,j=Bt[U-15]|0,Y=jt(R,j,1)^jt(R,j,8)^Fn(R,j,7),N=Wt(R,j,1)^Wt(R,j,8)^Kn(R,j,7),C=St[U-2]|0,M=Bt[U-2]|0,K=jt(C,M,19)^he(C,M,61)^Fn(C,M,6),J=Wt(C,M,19)^fe(C,M,61)^Kn(C,M,6),L=Ps(N,J,Bt[U-7],Bt[U-16]),E=Os(L,Y,K,St[U-7],St[U-16]);St[U]=E|0,Bt[U]=L|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:h,Eh:d,El:g,Fh:p,Fl:y,Gh:I,Gl:k,Hh:O,Hl:$}=this;for(let U=0;U<80;U++){const R=jt(d,g,14)^jt(d,g,18)^he(d,g,41),j=Wt(d,g,14)^Wt(d,g,18)^fe(d,g,41),Y=d&p^~d&I,N=g&y^~g&k,C=qs($,j,N,Fs[U],Bt[U]),M=Ns(C,O,R,Y,Ls[U],St[U]),K=C|0,J=jt(n,s,28)^he(n,s,34)^he(n,s,39),L=Wt(n,s,28)^fe(n,s,34)^fe(n,s,39),E=n&i^n&a^i&a,_=s&o^s&c^o&c;O=I|0,$=k|0,I=p|0,k=y|0,p=d|0,y=g|0,{h:d,l:g}=kt(l|0,h|0,M|0,K|0),l=a|0,h=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const w=Cs(K,L,_);n=Ts(w,M,J,E),s=w|0}({h:n,l:s}=kt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=kt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=kt(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:h}=kt(this.Dh|0,this.Dl|0,l|0,h|0),{h:d,l:g}=kt(this.Eh|0,this.El|0,d|0,g|0),{h:p,l:y}=kt(this.Fh|0,this.Fl|0,p|0,y|0),{h:I,l:k}=kt(this.Gh|0,this.Gl|0,I|0,k|0),{h:O,l:$}=kt(this.Hh|0,this.Hl|0,O|0,$|0),this.set(n,s,i,o,a,c,l,h,d,g,p,y,I,k,O,$)}roundClean(){xt(St,Bt)}destroy(){xt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $s extends Ks{Ah=st[0]|0;Al=st[1]|0;Bh=st[2]|0;Bl=st[3]|0;Ch=st[4]|0;Cl=st[5]|0;Dh=st[6]|0;Dl=st[7]|0;Eh=st[8]|0;El=st[9]|0;Fh=st[10]|0;Fl=st[11]|0;Gh=st[12]|0;Gl=st[13]|0;Hh=st[14]|0;Hl=st[15]|0;constructor(){super(64)}}const rt=qe(()=>new Rs,Rn(1)),Hn=qe(()=>new $s,Rn(3));const Ue=BigInt(0),De=BigInt(1);function de(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function jn(r){if(typeof r=="bigint"){if(!ge(r))throw new Error("positive bigint expected, got "+r)}else qt(r);return r}function pe(r){const t=jn(r).toString(16);return t.length&1?"0"+t:t}function Wn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ue:BigInt("0x"+r)}function Xt(r){return Wn(et(r))}function zn(r){return Wn(et(Hs(V(r)).reverse()))}function Re(r,t){qt(t),r=jn(r);const e=G(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function Qn(r,t){return Re(r,t).reverse()}function Hs(r){return Uint8Array.from(r)}function js(r){return Uint8Array.from(r,(t,e)=>{const n=t.charCodeAt(0);if(t.length!==1||n>127)throw new Error(`string contains non-ASCII character "${r[e]}" with code ${n} at position ${e}`);return n})}const ge=r=>typeof r=="bigint"&&Ue<=r;function Ws(r,t,e){return ge(r)&&ge(t)&&ge(e)&&t<=r&&r<e}function zs(r,t,e,n){if(!Ws(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Qs(r){let t;for(t=0;r>Ue;r>>=De,t+=1);return t}const Le=r=>(De<<BigInt(r))-De;function Vs(r,t,e){if(qt(r,"hashLen"),qt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=k=>new Uint8Array(k),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),l=n(r),h=0;const d=()=>{c.fill(1),l.fill(0),h=0},g=(...k)=>e(l,ot(c,...k)),p=(k=s)=>{l=g(i,k),c=g(),k.length!==0&&(l=g(o,k),c=g())},y=()=>{if(h++>=a)throw new Error("drbg: tried max amount of iterations");let k=0;const O=[];for(;k<t;){c=g();const $=c.slice();O.push($),k+=c.length}return ot(...O)};return(k,O)=>{d(),p(k);let $;for(;!($=O(y()));)p();return d(),$}}function Fe(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${l}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(t,!1),s(e,!0)}function Vn(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const i=r(e,...n);return t.set(e,i),i}}const at=BigInt(0),it=BigInt(1),Ut=BigInt(2),Zn=BigInt(3),Gn=BigInt(4),Yn=BigInt(5),Zs=BigInt(7),Jn=BigInt(8),Gs=BigInt(9),Xn=BigInt(16);function ht(r,t){const e=r%t;return e>=at?e:t+e}function ut(r,t,e){let n=r;for(;t-- >at;)n*=n,n%=e;return n}function tr(r,t){if(r===at)throw new Error("invert: expected non-zero number");if(t<=at)throw new Error("invert: expected positive modulus, got "+t);let e=ht(r,t),n=t,s=at,i=it;for(;e!==at;){const a=n/e,c=n%e,l=s-i*a;n=e,e=c,s=i,i=l}if(n!==it)throw new Error("invert: does not exist");return ht(s,t)}function Ke(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function er(r,t){const e=(r.ORDER+it)/Gn,n=r.pow(t,e);return Ke(r,n,t),n}function Ys(r,t){const e=(r.ORDER-Yn)/Jn,n=r.mul(t,Ut),s=r.pow(n,e),i=r.mul(t,s),o=r.mul(r.mul(i,Ut),s),a=r.mul(i,r.sub(o,r.ONE));return Ke(r,a,t),a}function Js(r){const t=me(r),e=nr(r),n=e(t,t.neg(t.ONE)),s=e(t,n),i=e(t,t.neg(n)),o=(r+Zs)/Xn;return(a,c)=>{let l=a.pow(c,o),h=a.mul(l,n);const d=a.mul(l,s),g=a.mul(l,i),p=a.eql(a.sqr(h),c),y=a.eql(a.sqr(d),c);l=a.cmov(l,h,p),h=a.cmov(g,d,y);const I=a.eql(a.sqr(h),c),k=a.cmov(l,h,I);return Ke(a,k,c),k}}function nr(r){if(r<Zn)throw new Error("sqrt is not defined for small field");let t=r-it,e=0;for(;t%Ut===at;)t/=Ut,e++;let n=Ut;const s=me(r);for(;sr(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return er;let i=s.pow(n,t);const o=(t+it)/Ut;return function(c,l){if(c.is0(l))return l;if(sr(c,l)!==1)throw new Error("Cannot find square root");let h=e,d=c.mul(c.ONE,i),g=c.pow(l,t),p=c.pow(l,o);for(;!c.eql(g,c.ONE);){if(c.is0(g))return c.ZERO;let y=1,I=c.sqr(g);for(;!c.eql(I,c.ONE);)if(y++,I=c.sqr(I),y===h)throw new Error("Cannot find square root");const k=it<<BigInt(h-y-1),O=c.pow(d,k);h=y,d=c.sqr(O),g=c.mul(g,d),p=c.mul(p,O)}return p}}function Xs(r){return r%Gn===Zn?er:r%Jn===Yn?Ys:r%Xn===Gs?Js(r):nr(r)}const ti=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ei(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=ti.reduce((n,s)=>(n[s]="function",n),t);return Fe(r,e),r}function ni(r,t,e){if(e<at)throw new Error("invalid exponent, negatives unsupported");if(e===at)return r.ONE;if(e===it)return t;let n=r.ONE,s=t;for(;e>at;)e&it&&(n=r.mul(n,s)),s=r.sqr(s),e>>=it;return n}function rr(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return t.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function sr(r,t){const e=(r.ORDER-it)/Ut,n=r.pow(t,e),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function ri(r,t){t!==void 0&&qt(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class si{ORDER;BITS;BYTES;isLE;ZERO=at;ONE=it;_lengths;_sqrt;_mod;constructor(t,e={}){if(t<=at)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=e.allowedLengths?.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:i}=ri(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return ht(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return at<=t&&t<this.ORDER}is0(t){return t===at}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&it)===it}neg(t){return ht(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return ht(t*t,this.ORDER)}add(t,e){return ht(t+e,this.ORDER)}sub(t,e){return ht(t-e,this.ORDER)}mul(t,e){return ht(t*e,this.ORDER)}pow(t,e){return ni(this,t,e)}div(t,e){return ht(t*tr(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return tr(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Xs(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Qn(t,this.BYTES):Re(t,this.BYTES)}fromBytes(t,e=!1){V(t);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const l=new Uint8Array(s);l.set(t,i?0:l.length-t.length),t=l}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=i?zn(t):Xt(t);if(a&&(c=ht(c,o)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return rr(this,t)}cmov(t,e,n){return n?e:t}}function me(r,t={}){return new si(r,t)}function ir(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function or(r){const t=ir(r);return t+Math.ceil(t/2)}function ar(r,t,e=!1){V(r);const n=r.length,s=ir(t),i=or(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?zn(r):Xt(r),a=ht(o,t-it)+it;return e?Qn(a,s):Re(a,s)}const zt=BigInt(0),Dt=BigInt(1);function ye(r,t){const e=t.negate();return r?e:t}function cr(r,t){const e=rr(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function ur(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function $e(r,t){ur(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,i=Le(r),o=BigInt(r);return{windows:e,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function lr(r,t,e){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=e;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Dt);const l=t*n,h=l+Math.abs(a)-1,d=a===0,g=a<0,p=t%2!==0;return{nextN:c,offset:h,isZero:d,isNeg:g,isNegF:p,offsetF:l}}const He=new WeakMap,hr=new WeakMap;function je(r){return hr.get(r)||1}function fr(r){if(r!==zt)throw new Error("invalid wNAF")}class ii{BASE;ZERO;Fn;bits;constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>zt;)e&Dt&&(n=n.add(s)),s=s.double(),e>>=Dt;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=$e(e,this.bits),i=[];let o=t,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let l=1;l<s;l++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=$e(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:l,isZero:h,isNeg:d,isNegF:g,offsetF:p}=lr(n,a,o);n=c,h?i=i.add(ye(g,e[p])):s=s.add(ye(d,e[l]))}return fr(n),{p:s,f:i}}wNAFUnsafe(t,e,n,s=this.ZERO){const i=$e(t,this.bits);for(let o=0;o<i.windows&&n!==zt;o++){const{nextN:a,offset:c,isZero:l,isNeg:h}=lr(n,o,i);if(n=a,!l){const d=e[c];s=s.add(h?d.negate():d)}}return fr(n),s}getPrecomputes(t,e,n){let s=He.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),He.set(e,s))),s}cached(t,e,n){const s=je(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const i=je(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,s)}createCache(t,e){ur(e,this.bits),hr.set(t,e),He.delete(t)}hasCache(t){return je(t)!==1}}function oi(r,t,e,n){let s=t,i=r.ZERO,o=r.ZERO;for(;e>zt||n>zt;)e&Dt&&(i=i.add(s)),n&Dt&&(o=o.add(s)),s=s.double(),e>>=Dt,n>>=Dt;return{p1:i,p2:o}}function dr(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return ei(t),t}else return me(r,{isLE:e})}function ai(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const l=t[c];if(!(typeof l=="bigint"&&l>zt))throw new Error(`CURVE.${c} must be positive bigint`)}const s=dr(t.p,e.Fp,n),i=dr(t.n,e.Fn,n),a=["Gx","Gy","a","b"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function pr(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}class gr{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,e){if(qn(t),V(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),xt(s)}update(t){return ce(this),this.iHash.update(t),this}digestInto(t){ce(this),V(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:e,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const te=(r,t,e)=>new gr(r,t).update(e).digest();te.create=(r,t)=>new gr(r,t);const mr=(r,t)=>(r+(r>=0?t:-t)/yr)/t;function ci(r,t,e){const[[n,s],[i,o]]=t,a=mr(o*r,e),c=mr(-s*r,e);let l=r-a*n-c*i,h=-a*s-c*o;const d=l<Et,g=h<Et;d&&(l=-l),g&&(h=-h);const p=Le(Math.ceil(Qs(e)/2))+Qt;if(l<Et||l>=p||h<Et||h>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:d,k1:l,k2neg:g,k2:h}}function We(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function ze(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return de(e.lowS,"lowS"),de(e.prehash,"prehash"),e.format!==void 0&&We(e.format),e}class ui extends Error{constructor(t=""){super(t)}}const Mt={Err:ui,_tlv:{encode:(r,t)=>{const{Err:e}=Mt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=pe(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?pe(s.length/2|128):"";return pe(r)+i+s+t},decode(r,t){const{Err:e}=Mt;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const l=t.subarray(n,n+c);if(l.length!==c)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const h of l)o=o<<8|h;if(n+=c,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+o)}}},_int:{encode(r){const{Err:t}=Mt;if(r<Et)throw new t("integer: negative integers are not allowed");let e=pe(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=Mt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Xt(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=Mt,s=V(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:h}=n.decode(2,c);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(l)}},hexFromSig(r){const{_tlv:t,_int:e}=Mt,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),i=n+s;return t.encode(48,i)}},Et=BigInt(0),Qt=BigInt(1),yr=BigInt(2),we=BigInt(3),li=BigInt(4);function hi(r,t={}){const e=ai("weierstrass",r,t),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o,n:a}=i;Fe(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=br(n,s);function h(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(L,E,_){const{x:w,y:m}=E.toAffine(),b=n.toBytes(w);if(de(_,"isCompressed"),_){h();const x=!n.isOdd(m);return ot(wr(x),b)}else return ot(Uint8Array.of(4),b,n.toBytes(m))}function g(L){V(L,void 0,"Point");const{publicKey:E,publicKeyUncompressed:_}=l,w=L.length,m=L[0],b=L.subarray(1);if(w===E&&(m===2||m===3)){const x=n.fromBytes(b);if(!n.isValid(x))throw new Error("bad point: is not on curve, wrong x");const A=I(x);let f;try{f=n.sqrt(A)}catch(S){const P=S instanceof Error?": "+S.message:"";throw new Error("bad point: is not on curve, sqrt error"+P)}h();const u=n.isOdd(f);return(m&1)===1!==u&&(f=n.neg(f)),{x,y:f}}else if(w===_&&m===4){const x=n.BYTES,A=n.fromBytes(b.subarray(0,x)),f=n.fromBytes(b.subarray(x,x*2));if(!k(A,f))throw new Error("bad point: is not on curve");return{x:A,y:f}}else throw new Error(`bad point: got length ${w}, expected compressed=${E} or uncompressed=${_}`)}const p=t.toBytes||d,y=t.fromBytes||g;function I(L){const E=n.sqr(L),_=n.mul(E,L);return n.add(n.add(_,n.mul(L,i.a)),i.b)}function k(L,E){const _=n.sqr(E),w=I(L);return n.eql(_,w)}if(!k(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const O=n.mul(n.pow(i.a,we),li),$=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(O,$)))throw new Error("bad curve params: a or b");function U(L,E,_=!1){if(!n.isValid(E)||_&&n.is0(E))throw new Error(`bad point coordinate ${L}`);return E}function R(L){if(!(L instanceof M))throw new Error("Weierstrass Point expected")}function j(L){if(!c||!c.basises)throw new Error("no endo");return ci(L,c.basises,s.ORDER)}const Y=Vn((L,E)=>{const{X:_,Y:w,Z:m}=L;if(n.eql(m,n.ONE))return{x:_,y:w};const b=L.is0();E==null&&(E=b?n.ONE:n.inv(m));const x=n.mul(_,E),A=n.mul(w,E),f=n.mul(m,E);if(b)return{x:n.ZERO,y:n.ZERO};if(!n.eql(f,n.ONE))throw new Error("invZ was invalid");return{x,y:A}}),N=Vn(L=>{if(L.is0()){if(t.allowInfinityPoint&&!n.is0(L.Y))return;throw new Error("bad point: ZERO")}const{x:E,y:_}=L.toAffine();if(!n.isValid(E)||!n.isValid(_))throw new Error("bad point: x or y not field elements");if(!k(E,_))throw new Error("bad point: equation left != right");if(!L.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function C(L,E,_,w,m){return _=new M(n.mul(_.X,L),_.Y,_.Z),E=ye(w,E),_=ye(m,_),E.add(_)}class M{static BASE=new M(i.Gx,i.Gy,n.ONE);static ZERO=new M(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=s;X;Y;Z;constructor(E,_,w){this.X=U("x",E),this.Y=U("y",_,!0),this.Z=U("z",w),Object.freeze(this)}static CURVE(){return i}static fromAffine(E){const{x:_,y:w}=E||{};if(!E||!n.isValid(_)||!n.isValid(w))throw new Error("invalid affine point");if(E instanceof M)throw new Error("projective point not allowed");return n.is0(_)&&n.is0(w)?M.ZERO:new M(_,w,n.ONE)}static fromBytes(E){const _=M.fromAffine(y(V(E,void 0,"point")));return _.assertValidity(),_}static fromHex(E){return M.fromBytes(G(E))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(E=8,_=!0){return J.createCache(this,E),_||this.multiply(we),this}assertValidity(){N(this)}hasEvenY(){const{y:E}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(E)}equals(E){R(E);const{X:_,Y:w,Z:m}=this,{X:b,Y:x,Z:A}=E,f=n.eql(n.mul(_,A),n.mul(b,m)),u=n.eql(n.mul(w,A),n.mul(x,m));return f&&u}negate(){return new M(this.X,n.neg(this.Y),this.Z)}double(){const{a:E,b:_}=i,w=n.mul(_,we),{X:m,Y:b,Z:x}=this;let A=n.ZERO,f=n.ZERO,u=n.ZERO,v=n.mul(m,m),S=n.mul(b,b),P=n.mul(x,x),B=n.mul(m,b);return B=n.add(B,B),u=n.mul(m,x),u=n.add(u,u),A=n.mul(E,u),f=n.mul(w,P),f=n.add(A,f),A=n.sub(S,f),f=n.add(S,f),f=n.mul(A,f),A=n.mul(B,A),u=n.mul(w,u),P=n.mul(E,P),B=n.sub(v,P),B=n.mul(E,B),B=n.add(B,u),u=n.add(v,v),v=n.add(u,v),v=n.add(v,P),v=n.mul(v,B),f=n.add(f,v),P=n.mul(b,x),P=n.add(P,P),v=n.mul(P,B),A=n.sub(A,v),u=n.mul(P,S),u=n.add(u,u),u=n.add(u,u),new M(A,f,u)}add(E){R(E);const{X:_,Y:w,Z:m}=this,{X:b,Y:x,Z:A}=E;let f=n.ZERO,u=n.ZERO,v=n.ZERO;const S=i.a,P=n.mul(i.b,we);let B=n.mul(_,b),q=n.mul(w,x),T=n.mul(m,A),F=n.add(_,w),D=n.add(b,x);F=n.mul(F,D),D=n.add(B,q),F=n.sub(F,D),D=n.add(_,m);let H=n.add(b,A);return D=n.mul(D,H),H=n.add(B,T),D=n.sub(D,H),H=n.add(w,m),f=n.add(x,A),H=n.mul(H,f),f=n.add(q,T),H=n.sub(H,f),v=n.mul(S,D),f=n.mul(P,T),v=n.add(f,v),f=n.sub(q,v),v=n.add(q,v),u=n.mul(f,v),q=n.add(B,B),q=n.add(q,B),T=n.mul(S,T),D=n.mul(P,D),q=n.add(q,T),T=n.sub(B,T),T=n.mul(S,T),D=n.add(D,T),B=n.mul(q,D),u=n.add(u,B),B=n.mul(H,D),f=n.mul(F,f),f=n.sub(f,B),B=n.mul(F,q),v=n.mul(H,v),v=n.add(v,B),new M(f,u,v)}subtract(E){return this.add(E.negate())}is0(){return this.equals(M.ZERO)}multiply(E){const{endo:_}=t;if(!s.isValidNot0(E))throw new Error("invalid scalar: out of range");let w,m;const b=x=>J.cached(this,x,A=>cr(M,A));if(_){const{k1neg:x,k1:A,k2neg:f,k2:u}=j(E),{p:v,f:S}=b(A),{p:P,f:B}=b(u);m=S.add(B),w=C(_.beta,v,P,x,f)}else{const{p:x,f:A}=b(E);w=x,m=A}return cr(M,[w,m])[0]}multiplyUnsafe(E){const{endo:_}=t,w=this;if(!s.isValid(E))throw new Error("invalid scalar: out of range");if(E===Et||w.is0())return M.ZERO;if(E===Qt)return w;if(J.hasCache(this))return this.multiply(E);if(_){const{k1neg:m,k1:b,k2neg:x,k2:A}=j(E),{p1:f,p2:u}=oi(M,w,b,A);return C(_.beta,f,u,m,x)}else return J.unsafe(w,E)}toAffine(E){return Y(this,E)}isTorsionFree(){const{isTorsionFree:E}=t;return o===Qt?!0:E?E(M,this):J.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:E}=t;return o===Qt?this:E?E(M,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(E=!0){return de(E,"isCompressed"),this.assertValidity(),p(M,this,E)}toHex(E=!0){return et(this.toBytes(E))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const K=s.BITS,J=new ii(M,t.endo?Math.ceil(K/2):K);return M.BASE.precompute(8),M}function wr(r){return Uint8Array.of(r?2:3)}function br(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function fi(r,t={}){const{Fn:e}=r,n=t.randomBytes||Nt,s=Object.assign(br(r.Fp,e),{seed:or(e.ORDER)});function i(p){try{const y=e.fromBytes(p);return e.isValidNot0(y)}catch{return!1}}function o(p,y){const{publicKey:I,publicKeyUncompressed:k}=s;try{const O=p.length;return y===!0&&O!==I||y===!1&&O!==k?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return ar(V(p,s.seed,"seed"),e.ORDER)}function c(p,y=!0){return r.BASE.multiply(e.fromBytes(p)).toBytes(y)}function l(p){const{secretKey:y,publicKey:I,publicKeyUncompressed:k}=s;if(!Oe(p)||"_lengths"in e&&e._lengths||y===I)return;const O=V(p,void 0,"key").length;return O===I||O===k}function h(p,y,I=!0){if(l(p)===!0)throw new Error("first arg must be private key");if(l(y)===!1)throw new Error("second arg must be public key");const k=e.fromBytes(p);return r.fromBytes(y).multiply(k).toBytes(I)}const d={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},g=pr(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:h,keygen:g,Point:r,utils:d,lengths:s})}function di(r,t,e={}){qn(t),Fe(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||Nt,s=e.hmac||((_,w)=>te(t,_,w)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:h,getSharedSecret:d,utils:g,lengths:p}=fi(r,e),y={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},I=a*yr<i.ORDER;function k(_){const w=a>>Qt;return _>w}function O(_,w){if(!o.isValidNot0(w))throw new Error(`invalid signature ${_}: out of range 1..Point.Fn.ORDER`);return w}function $(){if(I)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function U(_,w){We(w);const m=p.signature,b=w==="compact"?m:w==="recovered"?m+1:void 0;return V(_,b)}class R{r;s;recovery;constructor(w,m,b){if(this.r=O("r",w),this.s=O("s",m),b!=null){if($(),![0,1,2,3].includes(b))throw new Error("invalid recovery id");this.recovery=b}Object.freeze(this)}static fromBytes(w,m=y.format){U(w,m);let b;if(m==="der"){const{r:u,s:v}=Mt.toSig(V(w));return new R(u,v)}m==="recovered"&&(b=w[0],m="compact",w=w.subarray(1));const x=p.signature/2,A=w.subarray(0,x),f=w.subarray(x,x*2);return new R(o.fromBytes(A),o.fromBytes(f),b)}static fromHex(w,m){return this.fromBytes(G(w),m)}assertRecovery(){const{recovery:w}=this;if(w==null)throw new Error("invalid recovery id: must be present");return w}addRecoveryBit(w){return new R(this.r,this.s,w)}recoverPublicKey(w){const{r:m,s:b}=this,x=this.assertRecovery(),A=x===2||x===3?m+a:m;if(!i.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const f=i.toBytes(A),u=r.fromBytes(ot(wr((x&1)===0),f)),v=o.inv(A),S=Y(V(w,void 0,"msgHash")),P=o.create(-S*v),B=o.create(b*v),q=r.BASE.multiplyUnsafe(P).add(u.multiplyUnsafe(B));if(q.is0())throw new Error("invalid recovery: point at infinify");return q.assertValidity(),q}hasHighS(){return k(this.s)}toBytes(w=y.format){if(We(w),w==="der")return G(Mt.hexFromSig(this));const{r:m,s:b}=this,x=o.toBytes(m),A=o.toBytes(b);return w==="recovered"?($(),ot(Uint8Array.of(this.assertRecovery()),x,A)):ot(x,A)}toHex(w){return et(this.toBytes(w))}}const j=e.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const m=Xt(w),b=w.length*8-c;return b>0?m>>BigInt(b):m},Y=e.bits2int_modN||function(w){return o.create(j(w))},N=Le(c);function C(_){return zs("num < 2^"+c,_,Et,N),o.toBytes(_)}function M(_,w){return V(_,void 0,"message"),w?V(t(_),void 0,"prehashed message"):_}function K(_,w,m){const{lowS:b,prehash:x,extraEntropy:A}=ze(m,y);_=M(_,x);const f=Y(_),u=o.fromBytes(w);if(!o.isValidNot0(u))throw new Error("invalid private key");const v=[C(u),C(f)];if(A!=null&&A!==!1){const q=A===!0?n(p.secretKey):A;v.push(V(q,void 0,"extraEntropy"))}const S=ot(...v),P=f;function B(q){const T=j(q);if(!o.isValidNot0(T))return;const F=o.inv(T),D=r.BASE.multiply(T).toAffine(),H=o.create(D.x);if(H===Et)return;const W=o.create(F*o.create(P+H*u));if(W===Et)return;let X=(D.x===H?0:2)|Number(D.y&Qt),nt=W;return b&&k(W)&&(nt=o.neg(W),X^=1),new R(H,nt,I?void 0:X)}return{seed:S,k2sig:B}}function J(_,w,m={}){const{seed:b,k2sig:x}=K(_,w,m);return Vs(t.outputLen,o.BYTES,s)(b,x).toBytes(m.format)}function L(_,w,m,b={}){const{lowS:x,prehash:A,format:f}=ze(b,y);if(m=V(m,void 0,"publicKey"),w=M(w,A),!Oe(_)){const u=_ instanceof R?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+u)}U(_,f);try{const u=R.fromBytes(_,f),v=r.fromBytes(m);if(x&&u.hasHighS())return!1;const{r:S,s:P}=u,B=Y(w),q=o.inv(P),T=o.create(B*q),F=o.create(S*q),D=r.BASE.multiplyUnsafe(T).add(v.multiplyUnsafe(F));return D.is0()?!1:o.create(D.x)===S}catch{return!1}}function E(_,w,m={}){const{prehash:b}=ze(m,y);return w=M(w,b),R.fromBytes(_,"recovered").recoverPublicKey(w).toBytes()}return Object.freeze({keygen:l,getPublicKey:h,getSharedSecret:d,utils:g,lengths:p,Point:r,sign:J,verify:L,recoverPublicKey:E,Signature:R,hash:t})}const be={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},pi={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},gi=BigInt(0),Qe=BigInt(2);function mi(r){const t=be.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%t,h=l*l*r%t,d=ut(h,e,t)*h%t,g=ut(d,e,t)*h%t,p=ut(g,Qe,t)*l%t,y=ut(p,s,t)*p%t,I=ut(y,i,t)*y%t,k=ut(I,a,t)*I%t,O=ut(k,c,t)*k%t,$=ut(O,a,t)*I%t,U=ut($,e,t)*h%t,R=ut(U,o,t)*y%t,j=ut(R,n,t)*l%t,Y=ut(j,Qe,t);if(!ve.eql(ve.sqr(Y),r))throw new Error("Cannot find square root");return Y}const ve=me(be.p,{sqrt:mi}),Rt=hi(be,{Fp:ve,endo:pi}),Z=di(Rt,rt),vr={};function ke(r,...t){let e=vr[r];if(e===void 0){const n=rt(js(r));e=ot(n,n),vr[r]=e}return rt(ot(e,...t))}const Ve=r=>r.toBytes(!0).slice(1),Ze=r=>r%Qe===gi;function Ge(r){const{Fn:t,BASE:e}=Rt,n=t.fromBytes(r),s=e.multiply(n);return{scalar:Ze(s.y)?n:t.neg(n),bytes:Ve(s)}}function kr(r){const t=ve;if(!t.isValidNot0(r))throw new Error("invalid x: Fail if x â‰¥ p");const e=t.create(r*r),n=t.create(e*r+BigInt(7));let s=t.sqrt(n);Ze(s)||(s=t.neg(s));const i=Rt.fromAffine({x:r,y:s});return i.assertValidity(),i}const ee=Xt;function Er(...r){return Rt.Fn.create(ee(ke("BIP0340/challenge",...r)))}function _r(r){return Ge(r).bytes}function yi(r,t,e=Nt(32)){const{Fn:n}=Rt,s=V(r,void 0,"message"),{bytes:i,scalar:o}=Ge(t),a=V(e,32,"auxRand"),c=n.toBytes(o^ee(ke("BIP0340/aux",a))),l=ke("BIP0340/nonce",c,i,s),{bytes:h,scalar:d}=Ge(l),g=Er(h,i,s),p=new Uint8Array(64);if(p.set(h,0),p.set(n.toBytes(n.create(d+g*o)),32),!xr(p,s,i))throw new Error("sign: Invalid signature produced");return p}function xr(r,t,e){const{Fp:n,Fn:s,BASE:i}=Rt,o=V(r,64,"signature"),a=V(t,void 0,"message"),c=V(e,32,"publicKey");try{const l=kr(ee(c)),h=ee(o.subarray(0,32));if(!n.isValidNot0(h))return!1;const d=ee(o.subarray(32,64));if(!s.isValidNot0(d))return!1;const g=Er(s.toBytes(h),Ve(l),a),p=i.multiplyUnsafe(d).add(l.multiplyUnsafe(s.neg(g))),{x:y,y:I}=p.toAffine();return!(p.is0()||!Ze(I)||y!==h)}catch{return!1}}const Ee=(()=>{const e=(n=Nt(48))=>ar(n,be.n);return{keygen:pr(e,_r),getPublicKey:_r,sign:yi,verify:xr,Point:Rt,utils:{randomSecretKey:e,taggedHash:ke,lift_x:kr,pointToBytes:Ve},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),wi=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Ir=Uint8Array.from(new Array(16).fill(0).map((r,t)=>t)),bi=Ir.map(r=>(9*r+5)%16),Ar=(()=>{const e=[[Ir],[bi]];for(let n=0;n<4;n++)for(let s of e)s.push(s[n].map(i=>wi[i]));return e})(),Sr=Ar[0],Br=Ar[1],Mr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(r=>Uint8Array.from(r)),vi=Sr.map((r,t)=>r.map(e=>Mr[t][e])),ki=Br.map((r,t)=>r.map(e=>Mr[t][e])),Ei=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),_i=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Cr(r,t,e,n){return r===0?t^e^n:r===1?t&e|~t&n:r===2?(t|~e)^n:r===3?t&n|e&~n:t^(e|~n)}const _e=new Uint32Array(16);class xi extends Ne{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){const{h0:t,h1:e,h2:n,h3:s,h4:i}=this;return[t,e,n,s,i]}set(t,e,n,s,i){this.h0=t|0,this.h1=e|0,this.h2=n|0,this.h3=s|0,this.h4=i|0}process(t,e){for(let p=0;p<16;p++,e+=4)_e[p]=t.getUint32(e,!0);let n=this.h0|0,s=n,i=this.h1|0,o=i,a=this.h2|0,c=a,l=this.h3|0,h=l,d=this.h4|0,g=d;for(let p=0;p<5;p++){const y=4-p,I=Ei[p],k=_i[p],O=Sr[p],$=Br[p],U=vi[p],R=ki[p];for(let j=0;j<16;j++){const Y=ue(n+Cr(p,i,a,l)+_e[O[j]]+I,U[j])+d|0;n=d,d=l,l=ue(a,10)|0,a=i,i=Y}for(let j=0;j<16;j++){const Y=ue(s+Cr(y,o,c,h)+_e[$[j]]+k,R[j])+g|0;s=g,g=h,h=ue(c,10)|0,c=o,o=Y}}this.set(this.h1+a+h|0,this.h2+l+g|0,this.h3+d+s|0,this.h4+n+o|0,this.h0+i+c|0)}roundClean(){xt(_e)}destroy(){this.destroyed=!0,xt(this.buffer),this.set(0,0,0,0,0)}}const Ii=qe(()=>new xi);const ne=Z.Point,{Fn:re}=ne,Ye=_s(rt),Ai=Uint8Array.from("Bitcoin seed".split(""),r=>r.charCodeAt(0)),Je={private:76066276,public:76067358},Xe=2147483648,Si=r=>Ii(rt(r)),Bi=r=>Ht(r).getUint32(0,!1),xe=r=>{if(!Number.isSafeInteger(r)||r<0||r>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+r);const t=new Uint8Array(4);return Ht(t).setUint32(0,r,!1),t};class Lt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Bi(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return Ye.encode(this.serialize(this.versions.private,ot(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Ye.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,e=Je){if(V(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=te(Hn,Ai,t),s=n.slice(0,32),i=n.slice(32);return new Lt({versions:e,chainCode:i,privateKey:s})}static fromExtendedKey(t,e=Je){const n=Ye.decode(t),s=Ht(n),i=s.getUint32(0,!1),o={versions:e,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(i!==e[c?"private":"public"])throw new Error("Version mismatch");return c?new Lt({...o,privateKey:a.slice(1)}):new Lt({...o,publicKey:a})}static fromJSON(t){return Lt.fromExtendedKey(t.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(t){if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||Je,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!Z.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=Z.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=ne.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Si(this._publicKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of e){const i=/^(\d+)('?)$/.exec(s),o=i&&i[1];if(!i||i.length!==3||typeof o!="string")throw new Error("invalid child index: "+s);let a=+o;if(!Number.isSafeInteger(a)||a>=Xe)throw new Error("Invalid index");i[2]==="'"&&(a+=Xe),n=n.deriveChild(a)}return n}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=xe(t);if(t>=Xe){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");e=ot(Uint8Array.of(0),c,e)}else e=ot(this._publicKey,e);const n=te(Hn,this.chainCode,e),s=n.slice(0,32),i=n.slice(32);if(!Z.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:i,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},a=re.fromBytes(s);try{if(this._privateKey){const c=re.create(re.fromBytes(this._privateKey)+a);if(!re.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=re.toBytes(c)}else{const c=ne.fromBytes(this._publicKey).add(ne.BASE.multiply(a));if(c.equals(ne.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=c.toBytes(!0)}return new Lt(o)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return V(t,32),Z.sign(t,this._privateKey,{prehash:!1})}verify(t,e){if(V(t,32),V(e,64),!this._publicKey)throw new Error("No publicKey set!");return Z.verify(e,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return V(e,33),ot(xe(t),new Uint8Array([this.depth]),xe(this.parentFingerprint),xe(this.index),this.chainCode,e)}}class se extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,se.prototype)}}class tn extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,tn.prototype)}}class en extends se{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,en.prototype)}}const ft={error(){},warn(){},info(){},debug(){},trace(){},log(){}};function Ie(r,t=ft,e){throw t.error(r,e),new Error(r)}function nn(r,t,e=ft,n){r&&Ie(t,e,n)}function Tr(r,t,e=ft,n){r==null&&Ie(t,e,n)}function ie(r,t,e=ft,n){if(r)try{const s=r(t);s&&typeof s.then=="function"&&s.catch(i=>{try{e.warn("callback failed",{...n??{},error:i,cb:r.name??""})}catch{}})}catch(s){try{e.warn("callback failed",{...n??{},error:s,cb:r.name??""})}catch{}}}const Pr={error:0,warn:1,info:2,debug:3,trace:4};class Mi{constructor(t="info"){this.minLevel=t}should(t){return Pr[t]<=Pr[this.minLevel]}method(t){switch(t){case"error":return console.error;case"warn":return console.warn;case"info":return console.info;case"debug":return console.debug;case"trace":return console.trace;default:return console.log}}header(t,e){return`[${t.toUpperCase()}] ${e}`}flattenContext(t){if(!t)return;const e={};for(const[n,s]of Object.entries(t))e[n]=s instanceof Error?{message:s.message,stack:s.stack}:s;return e}emit(t,e,n){if(!this.should(t))return;const s=this.header(t,e),i=this.flattenContext(n),o=this.method(t);i&&Object.keys(i).length?o(s,i):o(s)}error(t,e){this.emit("error",t,e)}warn(t,e){this.emit("warn",t,e)}info(t,e){this.emit("info",t,e)}debug(t,e){this.emit("debug",t,e)}trace(t,e){this.emit("trace",t,e)}log(t,e,n){this.emit(t,e,n)}}function Ci(){const r=Date.now();return{elapsed:()=>Date.now()-r}}let Ti={},Or=ft;function Pi(r){Or=r}async function Oi({endpoint:r,requestBody:t,headers:e,...n}){const s=t?JSON.stringify(t):void 0,i={Accept:"application/json, text/plain, */*",...s?{"Content-Type":"application/json"}:void 0,...e};let o;try{o=await fetch(r,{body:s,headers:i,...n})}catch(a){throw new tn(a instanceof Error?a.message:"Network request failed")}if(!o.ok){let a;try{a=await o.json()}catch{a={error:"bad response"}}if(o.status===400&&"code"in a&&typeof a.code=="number"&&"detail"in a&&typeof a.detail=="string")throw new en(a.code,a.detail);let c="HTTP request failed";throw"error"in a&&typeof a.error=="string"?c=a.error:"detail"in a&&typeof a.detail=="string"&&(c=a.detail),new se(c,o.status)}try{return await o.json()}catch(a){throw Or.error("Failed to parse HTTP response",{err:a}),new se("bad response",o.status)}}async function qi(r){return await Oi({...r,...Ti})}let rn;typeof WebSocket<"u"&&(rn=WebSocket);function Ni(){if(rn===void 0)throw new Error("WebSocket implementation not initialized");return rn}class z{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const e=t.match(/.{1,2}/g);if(!e)throw new Error("Invalid hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((i,o)=>i+o.length,0),n=new Uint8Array(e);let s=0;for(const i of t)n.set(i,s),s+=i.length;return n}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Buffer<"u")return Buffer.from(t).toString("base64");if(t.length>32768){let e="";for(let n=0;n<t.length;n+=32768){const s=t.slice(n,n+32768);e+=btoa(String.fromCharCode(...s))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){t=t.trim();let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return typeof Buffer<"u"?new Uint8Array(Buffer.from(e,"base64")):new Uint8Array([...atob(e)].map(n=>n.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let n=0;for(let s=0;s<t.length;s++)n|=t[s]^e[s];return n===0}static compare(t,e){const n=Math.min(t.length,e.length);for(let s=0;s<n;s++){if(t[s]<e[s])return-1;if(t[s]>e[s])return 1}return t.length-e.length}static toBigInt(t){let e=0n;for(const n of t)e=e<<8n|BigInt(n);return e}static fromBigInt(t){if(t<0n)throw new RangeError("value must be non-negative");if(t===0n)return new Uint8Array([0]);let e=t,n=0;for(;e>0n;)n++,e>>=8n;const s=new Uint8Array(n);e=t;for(let i=n-1;i>=0;i--)s[i]=Number(e&0xffn),e>>=8n;return s}}function sn(r){return z.toBase64(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function qr(r){return z.fromBase64(r)}function Ui(r){const t=z.toString(z.fromBase64(Di(r)));return JSON.parse(t)}function Di(r){return r.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function on(r){if(typeof r!="string"||r.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(r)&&!e.test(r))return!1;const n=r.replace(/-/g,"+").replace(/_/g,"/"),s=(4-n.length%4)%4;if(s>2)return!1;const i=n+"=".repeat(s);try{const o=z.fromBase64(i),a=z.toBase64(o),c=a.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),l=n.replace(/=+$/,"");return a.replace(/=+$/,"")===l||c===l}catch{return!1}}function Ri(r){return typeof r=="number"||typeof r=="string"}function Li(r){const t=[];return an(r,t),new Uint8Array(t)}function an(r,t){if(r===null)t.push(246);else if(r===void 0)t.push(247);else if(typeof r=="boolean")t.push(r?245:244);else if(typeof r=="number")Hi(r,t);else if(typeof r=="string")Nr(r,t);else if(Array.isArray(r))Wi(r,t);else if(r instanceof Uint8Array)ji(r,t);else if(typeof r=="object"&&r!==null&&!Array.isArray(r))zi(r,t);else throw new Error("Unsupported type")}function Fi(r,t){if(r<24)t.push(r);else if(r<256)t.push(24,r);else if(r<65536)t.push(25,r>>>8&255,r&255);else if(r<4294967296)t.push(26,r>>>24&255,r>>>16&255,r>>>8&255,r&255);else throw new Error("Unsupported integer size")}function Ki(r,t){const e=-1-r;if(e<24)t.push(32|e);else if(e<256)t.push(56,e&255);else if(e<65536)t.push(57,e>>>8&255,e&255);else if(e<4294967296)t.push(58,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Unsupported integer size")}function $i(r,t){const e=new ArrayBuffer(8),n=new DataView(e);n.setFloat64(0,r,!1),t.push(251);for(let s=0;s<8;s++)t.push(n.getUint8(s))}function Hi(r,t){Number.isInteger(r)?r>=0?Fi(r,t):Ki(r,t):$i(r,t)}function ji(r,t){const e=r.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<r.length;n++)t.push(r[n])}function Nr(r,t){const e=new TextEncoder().encode(r),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>>8&255,n&255);else if(n<4294967296)t.push(122,n>>>24&255,n>>>16&255,n>>>8&255,n&255);else throw new Error("String too long to encode");for(let s=0;s<e.length;s++)t.push(e[s])}function Wi(r,t){const e=r.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>>8&255,e&255);else throw new Error("Unsupported array length");for(const n of r)an(n,t)}function zi(r,t){const e=Object.keys(r),n=e.length;if(n>=4294967296)throw new Error("Object has too many keys to encode");n<24?t.push(160|n):n<256?t.push(184,n):n<65536?t.push(185,n>>8&255,n&255):t.push(186,n>>24&255,n>>16&255,n>>8&255,n&255);for(const s of e)Nr(s,t),an(r[s],t)}function Qi(r){const t=new DataView(r.buffer,r.byteOffset,r.byteLength);return Ae(t,0).value}function Ae(r,t){if(t>=r.byteLength)throw new Error("Unexpected end of data");const e=r.getUint8(t++),n=e>>5,s=e&31;switch(n){case 0:return Vi(r,t,s);case 1:return Zi(r,t,s);case 2:return Gi(r,t,s);case 3:return Yi(r,t,s);case 4:return Ji(r,t,s);case 5:return Xi(r,t,s);case 7:return eo(r,t,s);default:throw new Error(`Unsupported major type: ${n}`)}}function Ct(r,t,e){if(t+e>r.byteLength)throw new Error("Unexpected end of data")}function Vt(r,t,e){if(e<24)return{value:e,offset:t};if(e===24)return Ct(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){Ct(r,t,2);const n=r.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){Ct(r,t,4);const n=r.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Ct(r,t,8);const n=r.getUint32(t,!1),s=r.getUint32(t+4,!1);return t+=8,{value:n*2**32+s,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Vi(r,t,e){const{value:n,offset:s}=Vt(r,t,e);return{value:n,offset:s}}function Zi(r,t,e){const{value:n,offset:s}=Vt(r,t,e);return{value:-1-n,offset:s}}function Gi(r,t,e){const{value:n,offset:s}=Vt(r,t,e);if(s+n>r.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(r.buffer,r.byteOffset+s,n),offset:s+n}}function Yi(r,t,e){const{value:n,offset:s}=Vt(r,t,e);if(s+n>r.byteLength)throw new Error("String length exceeds data length");const i=new Uint8Array(r.buffer,r.byteOffset+s,n);return{value:new TextDecoder().decode(i),offset:s+n}}function Ji(r,t,e){const{value:n,offset:s}=Vt(r,t,e),i=[];let o=s;for(let a=0;a<n;a++){const c=Ae(r,o);i.push(c.value),o=c.offset}return{value:i,offset:o}}function Xi(r,t,e){const{value:n,offset:s}=Vt(r,t,e),i={};let o=s;for(let a=0;a<n;a++){const c=Ae(r,o);if(!Ri(c.value))throw new Error("Invalid key type");const l=Ae(r,c.offset);i[c.value]=l.value,o=l.offset}return{value:i,offset:o}}function to(r){const t=(r&31744)>>10,e=r&1023,n=r&32768?-1:1;return t===0?n*2**-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function eo(r,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return Ct(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){Ct(r,t,2);const n=to(r.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){Ct(r,t,4);const n=r.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Ct(r,t,8);const n=r.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}const no=Dn("Secp256k1_HashToCurve_Cashu_");function Se(r){const t=rt(z.concat(no,r)),e=new Uint32Array(1),n=2**16;for(let s=0;s<n;s++){const i=new Uint8Array(e.buffer),o=rt(z.concat(t,i));try{return Zt(et(z.concat(new Uint8Array([2]),o)))}catch{e[0]++}}throw new Error("No valid point found")}function ro(r){const t=r.map(e=>e.toHex(!1)).join("");return rt(new TextEncoder().encode(t))}function Zt(r){return Z.Point.fromHex(r)}const so=r=>{let t;return/^[a-fA-F0-9]+$/.test(r)?t=Be(r)%BigInt(2**31-1):t=z.toBigInt(qr(r))%BigInt(2**31-1),t};function io(){return Z.utils.randomSecretKey()}function cn(r,t){const e=Se(r);t||(t=Z.Point.Fn.fromBytes(io()));const n=Z.Point.BASE.multiply(t);return{B_:e.add(n),r:t,secret:r}}function oo(r,t,e){return r.subtract(e.multiply(t))}function ao(r,t,e,n){const s=n,i=oo(r.C_,t,s);return{id:r.id,amount:r.amount,secret:e,C:i}}const co=r=>({amount:r.amount,C:r.C.toHex(!0),id:r.id,secret:new TextDecoder().decode(r.secret),witness:JSON.stringify(r.witness)}),uo=(r,t)=>{const e=rt(new TextEncoder().encode(r)),n=typeof t=="string"?G(t):t,s=Ee.sign(e,n);return et(s)},lo=(r,t,e,n=!1)=>{try{const s=rt(new TextEncoder().encode(t)),i=e.length===66?e.slice(2):e;return Ee.verify(G(r),s,G(i))}catch(s){if(n)throw s}return!1};function un(r){let t;try{typeof r=="string"?t=JSON.parse(r):t=r}catch{throw new Error("Can't parse secret")}if(!Array.isArray(t)||t.length!==2||typeof t[0]!="string"||typeof t[1]!="object"||t[0].trim().length===0||t[1]===null)throw new Error("Invalid NUT-10 secret");const[e,n]=t;if(typeof n.nonce!="string"||typeof n.data!="string")throw new Error("Invalid NUT-10 secret nonce / data");if(n.tags){if(!Array.isArray(n.tags))throw new Error("Invalid NUT-10 secret tags");if(n.tags.some(s=>!Array.isArray(s)||s.length===0||s.some(i=>typeof i!="string"||!i.length)))throw new Error("Invalid NUT-10 tag(s)")}return[e,{nonce:n.nonce,data:n.data,tags:n.tags}]}function ho(r,t){const e=Array.isArray(r)?r:[r],n=un(t),s=n[0];if(!e.includes(s))throw new Error(`Invalid secret kind: ${s} Allowed: ${e.join(", ")}`);return n}function fo(r){return un(r)[0]}function Ur(r){return un(r)[1]}function po(r){const{data:t}=Ur(r);return t}function go(r){const{tags:t}=Ur(r);return t??[]}function ln(r,t){const e=go(r).find(n=>n[0]===t);if(!(!e||e.length<=1))return e.slice(1)}function Dr(r,t){const e=ln(r,t);return e&&e.length>0?e[0]:void 0}function mo(r,t){const e=Dr(r,t);if(e===void 0)return;const n=Number.parseInt(e,10);return Number.isFinite(n)?n:void 0}const Rr=Dn("Cashu_P2BK_v1");function yo(r,t,e){if(!r.length)return{blinded:[],Ehex:""};e=e??Z.utils.randomSecretKey();const n=Z.Point.Fn.fromBytes(e),s=Z.getPublicKey(e,!0),i=G(t);return{blinded:r.map((o,a)=>{const c=Zt(o),l=Lr(c,n,i,a),h=c.add(Z.Point.BASE.multiply(l));if(h.equals(Z.Point.ZERO))throw new Error("Blinded key at infinity");return h.toHex(!0)}),Ehex:et(s)}}function wo(r,t,e,n){const s=Array.isArray(t)?t:[t],i=Array.isArray(e)?e:[e],o=new Set,a=Z.Point.fromHex(r),c=G(n);for(const l of s){const h=Z.Point.Fn.fromBytes(G(l)),d=Z.getPublicKey(G(l),!0);i.forEach((g,p)=>{const y=Lr(a,h,c,p),I=G(g),k=bo(l,y,I,d);k&&o.add(k)})}return Array.from(o)}function bo(r,t,e,n){const s=Z.Point.CURVE().n,i=typeof r=="string"?Be(r):r,o=typeof t=="string"?Be(t):t;if(i<=0n||i>=s)throw new Error("Invalid private key");if(o<=0n||o>=s)throw new Error("Invalid scalar r");if(n=n??Z.Point.BASE.multiply(i).toBytes(!0),n.length!==33)throw new Error("naturalPub must be 33 bytes");const a=(i+o)%s,c=(s-i+o)%s;if(!e){if(a===0n)throw new Error("Derived secret key is zero");return fn(a)}if(e.length!==33)throw new Error("blindPubkey must be 33 bytes");const l=Z.Point.fromHex(et(e)),h=Z.Point.BASE.multiply(o),d=l.subtract(h);if(d.equals(Z.Point.ZERO))return null;const g=d.toBytes(!0).slice(1),p=n.slice(1);if(!z.equals(g,p))return null;const y=d.toBytes(!0)[0]&1,I=n[0]&1,k=y===I?a:c;if(k===0n)throw new Error("Derived secret key is zero");return fn(k)}function Lr(r,t,e,n){const s=r.multiply(t).toBytes(!0).slice(1),i=new Uint8Array([n&255]);let o=z.toBigInt(rt(z.concat(Rr,s,e,i)));if((o===0n||o>=Z.Point.CURVE().n)&&(o=z.toBigInt(rt(z.concat(Rr,s,e,i,new Uint8Array([255])))),o===0n||o>=Z.Point.CURVE().n))throw new Error("P2BK: tweak derivation failed");return o}function yt(r){return r instanceof Uint8Array&&(r=new TextDecoder().decode(r)),ho(["P2PK","HTLC"],r)}function vo(r){try{const t=yt(r),e=Eo(t),n=Fr(t),s=Kr(t);if(e==="ACTIVE"||e==="PERMANENT")return n;if(e==="EXPIRED"&&s.length){const i=[...n,...s];return Array.from(new Set(i))}}catch{}return[]}function Fr(r){const t=yt(r);let e="";fo(t)==="P2PK"&&(e=po(t));const n=ln(t,"pubkeys")??[],s=[e,...n].filter(Boolean);return Array.from(new Set(s))}function Kr(r){const t=yt(r);return ln(t,"refund")??[]}function ko(r){const t=yt(r),e=mo(t,"locktime");return e===void 0||!Number.isFinite(e)||e<=0?1/0:e}function Eo(r,t=Math.floor(Date.now()/1e3)){const e=yt(r),n=ko(e);return Number.isFinite(n)?t<n?"ACTIVE":"EXPIRED":"PERMANENT"}function hn(r){const t=yt(r);return Dr(t,"sigflag")==="SIG_ALL"?"SIG_ALL":"SIG_INPUTS"}function _o(r){return $r(r)?.signatures??[]}function $r(r){if(!r)return;let t;try{t=typeof r=="string"?JSON.parse(r):r}catch(n){console.error("Failed to parse witness string:",n);return}const e={signatures:t.signatures??[]};return typeof t.preimage=="string"&&t.preimage.length>0&&(e.preimage=t.preimage),e}function Hr(r,t,e=ft,n){const s=o=>typeof o=="string"?o:et(o),i=Array.isArray(t)?t.map(s):s(t);return r.map((o,a)=>{const c=Io(i,o);let l=o;for(const h of c)try{l=xo(l,h,n)}catch(d){const g=d instanceof Error?d.message:"Unknown error";e.warn(`Proof #${a+1}: ${g}`)}return l})}function xo(r,t,e){const n=yt(r.secret);e=e??r.secret;const s=typeof t=="string"?G(t):t,i=et(Ee.getPublicKey(s)),o=vo(n);if(!o.length||!o.some(h=>h.includes(i)))throw new Error(`Signature not required from [02|03]${i}`);if(_o(r.witness).some(h=>lo(h,e,i)))throw new Error(`Proof already signed by [02|03]${i}`);const a=uo(e,t),c=$r(r.witness),l={...c&&c.preimage!==void 0?{preimage:c.preimage}:{},signatures:[...c?.signatures??[],a]};return{...r,witness:l}}function Io(r,t){const e=Array.isArray(r)?r:[r],n=t?.p2pk_e;if(!n)return Array.from(new Set(e));const s=yt(t.secret),i=[...Fr(s),...Kr(s)],o=t.id;return wo(n,e,i,o)}function Ao(r){if(r.length===0)throw new Error("No proofs");const t=yt(r[0].secret);if(hn(t)!=="SIG_ALL")throw new Error("First proof is not SIG_ALL");const e=t[1].data,n=JSON.stringify(t[1].tags??[]);for(let s=1;s<r.length;s++){const i=yt(r[s].secret);if(i[0]!==t[0])throw new Error(`Proof #${s+1} is not ${t[0]}`);if(hn(i)!=="SIG_ALL")throw new Error(`Proof #${s+1} is not SIG_ALL`);if(i[1].data!==e)throw new Error("SIG_ALL inputs must share identical Secret.data");if(JSON.stringify(i[1].tags??[])!==n)throw new Error("SIG_ALL inputs must share identical Secret.tags")}}function So(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.B_);return e&&n.push(e),n.join("")}function jr(r){return r.some(t=>{try{return hn(t.secret)==="SIG_ALL"}catch{return!1}})}function Bo(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.id,s.blindedMessage.B_);return e&&n.push(e),n.join("")}function Mo(r,t,e){const n=[];for(const s of r)n.push(s.secret);for(const s of t)n.push(s.blindedMessage.B_);return e&&n.push(e),n.join("")}function Co(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}const To=(r,t,e,n)=>{const s=Z.Point.Fn.fromBytes(r.s),i=Z.Point.Fn.fromBytes(r.e),o=Z.Point.BASE.multiply(s),a=n.multiply(i),c=t.multiply(s),l=e.multiply(i),h=o.subtract(a),d=c.subtract(l),g=ro([h,d,n,e]);return Co(g,r.e)},Po=(r,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const s=Se(r),i=e.add(n.multiply(t.r)),o=Z.Point.BASE.multiply(t.r),a=s.add(o);return To(t,a,i,n)},Oo="m/129372'/0'",Wr=BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),qo=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&on(t)||n&&t.startsWith("00"))return Qr(r,t,e,0);if(n&&t.startsWith("01"))return zr(r,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},No=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&on(t)||n&&t.startsWith("00"))return Qr(r,t,e,1);if(n&&t.startsWith("01"))return zr(r,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},zr=(r,t,e,n)=>{let s=z.concat(z.fromString("Cashu_KDF_HMAC_SHA256"),z.fromHex(t),z.writeBigUint64BE(BigInt(e)));switch(n){case 0:s=z.concat(s,z.fromHex("00"));break;case 1:s=z.concat(s,z.fromHex("01"))}const i=te(rt,r,s);if(n===1){const o=z.toBigInt(i);if(o>=Wr)return z.fromBigInt(o-Wr);if(o===0n)throw new Error("Derived invalid blinding scalar r == 0");return i}return i},Qr=(r,t,e,n)=>{const s=Lt.fromMasterSeed(r),i=so(t),o=`${Oo}/${i}'/${e}'/${n}`,a=s.derive(o);if(a.privateKey===null)throw new Error("Could not derive private key");return a.privateKey};function Uo(r,t){let e=r;for(const s of t)e+=s.B_;const n=new TextEncoder().encode(e);return rt(n)}function Do(r,t,e){const n=Uo(t,e),s=G(r),i=Ee.sign(n,s);return et(i)}function Tt(r,t,e,n){if(e){const i=Xr(e);if(r===0&&i===0)return e;const o=e.filter(c=>c>0),a=Xr(o);if(a>r)throw new Error(`Split is greater than total amount: ${a} > ${r}`);if(o.some(c=>!Zr(c,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(a===r)return o;e=o,r-=a}else e=[];const s=Vr(t,"desc");if(!s||s.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");for(const i of s){if(i<=0)continue;const o=Math.floor(r/i);if(e.push(...Array(o).fill(i)),r-=i*o,r===0)break}if(r!==0)throw new Error(`Unable to split remaining amount: ${r}`);return n?e.sort((i,o)=>i-o):e}function Ro(r,t,e,n){const s=[],i=r.map(a=>a.amount);Vr(e,"asc").forEach(a=>{const c=i.filter(h=>h===a).length,l=Math.max(n-c,0);for(let h=0;h<l&&!(s.reduce((d,g)=>d+g,0)+a>t);++h)s.push(a)});const o=t-s.reduce((a,c)=>a+c,0);return o&&Tt(o,e).forEach(a=>{s.push(a)}),s.sort((a,c)=>a-c)}function Vr(r,t="desc"){return t=="desc"?Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>e-n)}function Zr(r,t){return r in t}function Be(r){return BigInt(`0x${r}`)}function fn(r){return r.toString(16).padStart(64,"0")}function Gt(r){return/^[a-f0-9]*$/i.test(r)}function Lo(r){return Array.isArray(r)?r.some(t=>!Gt(t.id)):!Gt(r.id)}function Fo(r){return r.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function Gr(r,t){if(r.proofs.forEach(a=>{if(a.dleq&&a.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Lo(r.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");r.proofs=Fo(r.proofs);const e=Ko(r),n=Li(e),s="cashu",i="B",o=sn(n);return s+i+o}function Ko(r){const t={},e=r.mint;for(let s=0;s<r.proofs.length;s++){const i=r.proofs[s];t[i.id]?t[i.id].push(i):t[i.id]=[i]}const n={m:e,u:r.unit||"sat",t:Object.keys(t).map(s=>({i:G(s),p:t[s].map(i=>({a:i.amount,s:i.secret,c:G(i.C),...i.dleq&&{d:{e:G(i.dleq.e),s:G(i.dleq.s),r:G(i.dleq.r??"00")}},...i.p2pk_e&&{pe:G(i.p2pk_e)},...i.witness&&{w:JSON.stringify(i.witness)}}))}))};return r.memo&&(n.d=r.memo),n}function dn(r,t=!1){if(typeof r!="number"||!Number.isFinite(r)||!Number.isInteger(r))throw new Error(`Invalid amount: ${String(r)}`);if(!Number.isSafeInteger(r))throw new Error(`Amount must be a safe integer: ${r}`);if(t?r<0:r<=0)throw new Error(`Amount must be ${t?"non-negative":"positive"}: ${r}`)}function $o(r){const t=[];r.t.forEach(n=>n.p.forEach(s=>{dn(s.a,!0),t.push({secret:s.s,C:et(s.c),amount:s.a,id:et(n.i),...s.d&&{dleq:{r:et(s.d.r),s:et(s.d.s),e:et(s.d.e)}},...s.pe&&{p2pk_e:et(s.pe)},...s.w&&{witness:s.w}})}));const e={mint:r.m,proofs:t,unit:r.u||"sat"};return r.d&&(e.memo=r.d),e}function Ho(r,t){const e=(t??[]).map(i=>typeof i=="string"?i:i.id),n=ts(r),s=Yr(n);return s.proofs=Vo(s.proofs,e),s}function jo(r){r=ts(r);const t=Yr(r);return{unit:t.unit||"sat",mint:t.mint,amount:Pt(t.proofs),...t.memo&&{memo:t.memo},incompleteProofs:t.proofs.map(e=>({secret:e.secret,C:e.C,amount:e.amount,...e.dleq&&{dleq:e.dleq},...e.witness&&{witness:e.witness}}))}}function Yr(r){const t=r.slice(0,1),e=r.slice(1);if(t==="A"){const n=Ui(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const s=n.token[0];for(const o of s.proofs)dn(o.amount,!0);const i={mint:s.mint,proofs:s.proofs,unit:n.unit||"sat"};return n.memo&&(i.memo=n.memo),i}else if(t==="B"){const n=qr(e),s=Qi(n);return $o(s)}throw new Error("Token version is not supported")}function Wo(r,t,e,n=0,s=!1){if(s){const c=Object.entries(r).sort((h,d)=>+h[0]-+d[0]).map(([,h])=>h).reduce((h,d)=>h+d,""),l=rt(z.fromString(c));return z.toBase64(l).slice(0,12)}let i=Object.entries(r).sort((c,l)=>+c[0]-+l[0]).map(([,c])=>G(c)).reduce((c,l)=>pn(c,l),new Uint8Array),o,a;switch(n){case 0:return o=rt(i),a=z.toHex(o).slice(0,14),"00"+a;case 1:if(!t)throw new Error("Cannot compute keyset ID version 01: unit is required.");return i=pn(i,z.fromString("unit:"+t)),e&&(i=pn(i,z.fromString("final_expiry:"+e.toString()))),o=rt(i),a=z.toHex(o),"01"+a;default:throw new Error(`Unrecognized keyset ID version: ${n}`)}}function pn(r,t){const e=new Uint8Array(r.length+t.length);return e.set(r),e.set(t,r.length),e}function wt(r){return typeof r=="object"}function Yt(...r){return r.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function Jr(r){return r.replace(/\/$/,"")}function Pt(r){return r.reduce((t,e)=>t+e.amount,0)}class zo{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class Qo{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new zo(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function Vo(r,t){const e=(t??[]).map(s=>typeof s=="string"?s:s.id),n=[];for(const s of r){let i;try{i=G(s.id)}catch{n.push(s);continue}if(i[0]===0)n.push(s);else if(i[0]===1){if(!e)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let o=!1;for(const a of e)if(s.id===a.slice(0,s.id.length)){s.id=a,n.push(s),o=!0;break}if(!o)throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${i[0]}`)}return n}function Zo(r,t){if(r.dleq==null)return!1;const e={e:G(r.dleq.e),s:G(r.dleq.s),r:Be(r.dleq.r??"00")};if(!Zr(r.amount,t.keys))throw new Error(`Undefined key for amount ${r.amount} in keyset ${t.id}`);const n=t.keys[r.amount];return Po(new TextEncoder().encode(r.secret),e,Zt(r.C),Zt(n))}function Xr(r){return r.reduce((t,e)=>t+e,0)}function ts(r){return["web+cashu://","cashu://","cashu:","cashu"].forEach(t=>{r.startsWith(t)&&(r=r.slice(t.length))}),r}function Go(r){return/^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(r)}class Jt{constructor(){this.connectionMap=new Map}static getInstance(){return Jt.instance||(Jt.instance=new Jt),Jt.instance}getConnection(t,e){const n=this.connectionMap.get(t);if(n)return e&&n.setLogger(e),n;const s=new Yo(t,e);return this.connectionMap.set(t,s),s}}class Yo{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=Ni(),this.url=new URL(t),this.messageQueue=new Qo,this._logger=e??ft}setLogger(t){this._logger=t}connect(t=1e4){return this.connectionPromise?this.connectionPromise:(this.connectionPromise=new Promise((e,n)=>{let s=!1,i=!1,o=null;const a=h=>{i||(i=!0,o&&clearTimeout(o),h())},c=()=>{if(this.ws){try{this.ws.onopen=null,this.ws.onerror=null,this.ws.onmessage=null,this.ws.onclose=null}catch{}try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling()}},l=h=>{this.connectionPromise=void 0,c();const d=h instanceof Error?h:new Error(String(h));this.failPendingRpc(d),a(()=>n(d))};try{this.ws=new this._WS(this.url.toString())}catch(h){l(h);return}o=setTimeout(()=>{l(new Error(`WebSocket connect timeout after ${t}ms`))},t),this.ws.onopen=()=>{s=!0,a(e)},this.ws.onerror=h=>{if(!s){l(new Error("Failed to open WebSocket"));return}this._logger.error("WebSocket error after open",{ev:h})},this.ws.onmessage=h=>{this.messageQueue.enqueue(h.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=h=>{if(this.connectionPromise=void 0,!s){const p=h?.reason?`, ${h.reason}`:"";l(new Error(`WebSocket closed before open (code ${h?.code??0}${p})`));return}this.stopMessageHandling();const d=h?.reason?`, ${h.reason}`:"",g=h?.code??0;!(typeof h.wasClean!="boolean"||h.wasClean)||g!==1e3&&g!==1001?this.failPendingRpc(new Error(`WebSocket closed (code ${g}${d})`)):this.rpcListeners={},this.onCloseCallbacks.forEach(p=>p(h))}}),this.connectionPromise)}sendRequest(t,e){if(this.ws?.readyState!==this._WS.OPEN){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const n=this.rpcId;this.rpcId++,this.sendRpcMessage(t,e,n)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}stopMessageHandling(){for(this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);this.messageQueue.size>0;)this.messageQueue.dequeue()}failPendingRpc(t){const e=this.rpcListeners;this.rpcListeners={};for(const n of Object.keys(e))try{e[n].errorCallback(t)}catch{}}sendRpcMessage(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw new Error("Socket not open");const s=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});try{this.ws.send(s)}catch(i){this._logger.error("WebSocket send failed",{e:i}),this.connectionPromise=void 0;try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling();const o=i instanceof Error?i:new Error(String(i));throw this.failPendingRpc(o),o}}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(t){this.ws?.readyState!==this._WS.OPEN&&await this.connect(t)}handleNextMessage(){if(this.messageQueue.size===0){this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);return}const t=this.messageQueue.dequeue();try{const e=JSON.parse(t);if("result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params?.subId;if(!n)return;if(this.subListeners[n]?.length>0){const s=e;this.subListeners[n].forEach(i=>{try{i(s.params?.payload)}catch(o){this._logger.error("Subscription handler threw",{e:o})}})}}}catch(e){this._logger.error("Error doing handleNextMessage",{e})}}createSubscription(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const s=(Math.random()+1).toString(36).substring(7),i=this.rpcId;this.addRpcListener(()=>{this.addSubListener(s,e)},n,i);try{this.sendRequest("subscribe",{...t,subId:s})}catch(o){throw this.removeRpcListener(i),o}return s}cancelSubscription(t,e,n){if(this.removeListener(t,e),this.ws?.readyState!==this._WS.OPEN){this._logger.info("Socket not open, removed listener locally {subId}",{subId:t});return}const s=this.rpcId;this.rpcId++,this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},n||(i=>this._logger.error("Unsubscribe failed",{e:i})),s);try{this.sendRpcMessage("unsubscribe",{subId:t},s)}catch(i){throw this.removeRpcListener(s),i}}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){if(this.ws){try{this.ws.close()}catch{}this.ws=void 0}this.connectionPromise=void 0,this.stopMessageHandling()}onClose(t){this.onCloseCallbacks.push(t)}}const gn={UNPAID:"UNPAID",PAID:"PAID"},oe={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},mn={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"};function yn(r,t){return r.state||(t.warn("Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof r.paid=="boolean"&&(r.state=r.paid?oe.PAID:oe.UNPAID)),r}function es(r,t){return r.state||(t.warn("Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof r.paid=="boolean"&&(r.state=r.paid?gn.PAID:gn.UNPAID)),r}function Jo(r,t){return Array.isArray(r?.contact)&&r?.contact.length>0&&(r.contact=r.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),r}class wn{constructor(t){this._mintInfo=t;const e=this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);this._protected22=this.buildIndex(e);const n=this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);this._protected21=this.buildIndex(n)}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t,e){return this.matchesProtected(this._protected22,t,e)}requiresClearAuthToken(t,e){return this.matchesProtected(this._protected21,t,e)}matchesProtected(t,e,n){if(!t)return!1;const s=`${e} ${n}`,i=t.cache[s];if(typeof i=="boolean")return i;const o=t.exact.some(l=>l.method===e&&l.path===n),a=o?!1:t.prefix.some(l=>l.method===e&&n.startsWith(l.path)),c=o||a;return t.cache[s]=c,c}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e?.methods??[]}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}toEndpoints(t){if(!Array.isArray(t))return[];const e=[];for(const n of t)if(n&&typeof n=="object"){const s=n,i=s.method,o=s.path;if(typeof i=="string"&&typeof o=="string"){const a=i.toUpperCase();(a==="GET"||a==="POST")&&e.push({method:a,path:o})}}return e}buildIndex(t){if(!t||t.length===0)return;const e=[],n=[];for(const s of t){let i=s.path;i.startsWith("^")&&(i=i.slice(1)),i.endsWith("$")&&(i=i.slice(0,-1)),i.endsWith(".*")?n.push({method:s.method,path:i.slice(0,-2)}):e.push({method:s.method,path:i})}return{cache:{},exact:e,prefix:n}}get cache(){return this._mintInfo}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this.supportsNut04Description("bolt12")}supportsNut04Description(t,e){return this._mintInfo.nuts[4]?.methods.some(n=>n.method===t&&(e?n.unit===e:!0)&&(n.options?.description===!0||n.description===!0))}supportsAmountless(t="bolt11",e="sat"){const n=this._mintInfo?.nuts?.[5]?.methods??[];return Array.isArray(n)?n.some(s=>s.method===t&&s.unit===e&&s.options?.amountless===!0):!1}}class bn{constructor(t,e){this.tokenListeners=[],this.discoveryUrl=t,this.logger=e?.logger??ft,this.clientId=e?.clientId??"cashu-client",this.scope=e?.scope??"openid",this.onTokens=e?.onTokens}static fromMintInfo(t,e){const n=t?.nuts?.["21"];if(!n?.openid_discovery)throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");const s=e?.clientId??n.client_id??"cashu-client";return new bn(n.openid_discovery,{...e,clientId:s})}setClient(t){this.clientId=t}setScope(t){this.scope=t??"openid"}addTokenListener(t){this.tokenListeners.push(t)}async loadConfig(){if(this.config)return this.config;const t=await fetch(this.discoveryUrl,{method:"GET",headers:{Accept:"application/json"}}),e=await t.text();let n;try{n=e?JSON.parse(e):void 0}catch(i){this.logger.warn("OIDCAuth: bad discovery JSON",{err:i})}if(!t.ok||!n)throw new Error("OIDCAuth: invalid discovery document");const s=n;if(typeof s.token_endpoint!="string"||s.token_endpoint.length===0)throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");return this.config=s,s}generatePKCE(){const t=Nt(48),e=sn(t),n=z.fromString(e),s=rt(n),i=sn(s);return{verifier:e,challenge:i}}async buildAuthCodeUrl(t){const e=await this.loadConfig(),n=t.scope??this.scope,s=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:t.redirectUri,scope:n,code_challenge_method:t.codeChallengeMethod??"S256",code_challenge:t.codeChallenge});if(t.state&&s.set("state",t.state),!e.authorization_endpoint)throw new Error("OIDCAuth: discovery lacks authorization_endpoint");return`${e.authorization_endpoint}?${s.toString()}`}async exchangeAuthCode(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"authorization_code",code:t.code,redirect_uri:t.redirectUri,client_id:this.clientId,code_verifier:t.codeVerifier}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async deviceStart(){const t=(await this.loadConfig()).device_authorization_endpoint;if(!t)throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");const e=this.toForm({client_id:this.clientId,scope:this.scope});return this.postFormStrict(t,e)}async devicePoll(t,e=5){const n=await this.loadConfig();let s=Math.max(1,e);for(;;){await this.sleep(s*1e3);const i=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:t,client_id:this.clientId}),o=await this.postFormLoose(n.token_endpoint,i);if(o.access_token)return this.handleTokens(o),o;const a=(o.error??"").toString();if(a==="authorization_pending")continue;if(a==="slow_down"){s=Math.max(s+5,s*2);continue}const c=o.error_description||a||"device authorization failed";throw new Error(`OIDCAuth: ${c}`)}}async startDeviceAuth(t=5){const e=await this.deviceStart(),n=Math.max(e.interval??1,t);let s=!1;return{...e,poll:async()=>{const i=await this.loadConfig();let o=Math.max(1,n);for(;;){if(s)throw new Error("OIDCAuth: device polling cancelled");await this.sleep(o*1e3);const a=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:e.device_code,client_id:this.clientId}),c=await this.postFormLoose(i.token_endpoint,a);if(c.access_token)return this.handleTokens(c),c;const l=(c.error??"").toString();if(l==="authorization_pending")continue;if(l==="slow_down"){o=Math.max(o+5,o*2);continue}const h=c.error_description||l||"device authorization failed";throw new Error(`OIDCAuth: ${h}`)}},cancel:()=>{s=!0}}}async refresh(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"refresh_token",refresh_token:t,client_id:this.clientId}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async passwordGrant(t,e){const n=await this.loadConfig(),s=this.toForm({grant_type:"password",client_id:this.clientId,username:t,password:e,scope:this.scope}),i=await this.postFormStrict(n.token_endpoint,s);return this.handleTokens(i),i}handleTokens(t){if(!t.access_token){const e=t.error_description||t.error||"token response missing access_token";throw new Error(`OIDCAuth: ${e}`)}queueMicrotask(()=>ie(this.onTokens,t,this.logger,{where:"OIDCAuth.handleTokens"}));for(const e of this.tokenListeners)queueMicrotask(()=>ie(e,t,this.logger,{where:"OIDCAuth.handleTokens.listener"}))}toForm(t){const e=n=>encodeURIComponent(n).replace(/%20/g,"+");return Object.entries(t).map(([n,s])=>`${e(n)}=${e(s)}`).join("&")}async postFormStrict(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e}),s=await n.text();let i;try{i=s?JSON.parse(s):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (strict)",{err:o})}if(!n.ok){const o=i??{},a=o.error_description||o.error||`HTTP ${n.status}`;throw new Error(`OIDCAuth: ${a}`)}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){throw this.logger.error("OIDCAuth: postFormStrict failed",{err:n}),n}}async postFormLoose(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await(await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e})).text();let s;try{s=n?JSON.parse(n):void 0}catch(i){this.logger.warn("OIDCAuth: bad JSON (loose)",{err:i})}return this.logger.debug("OIDCAuth Response",{json:s}),s??{}}catch(n){return this.logger.error("OIDCAuth: postFormLoose network error",{err:n}),{error:"network_error",error_description:String(n)}}}sleep(t){return new Promise(e=>setTimeout(e,t))}}class ns{constructor(t,e){this._mintUrl=Jr(t),this._request=e?.customRequest??qi,this._authProvider=e?.authProvider,this._logger=e?.logger??ft,Pi(this._logger)}get mintUrl(){return this._mintUrl}async oidcAuth(t){const e=(await this.getLazyMintInfo()).nuts[21];if(!e?.openid_discovery)throw new Error("Mint: no NUT-21 openid_discovery");return new bn(e.openid_discovery,{...t,clientId:t?.clientId??e.client_id??"cashu-client"})}async getInfo(t){const e=await(t??this._request)({endpoint:Yt(this._mintUrl,"/v1/info")});return Jo(e,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await this.getInfo();return this._mintInfo=new wn(t),this._mintInfo}async swap(t,e){const n=await this.requestWithAuth("POST","/v1/swap",{requestBody:t},e);if(!wt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"swap"}),new Error("Invalid response from mint");return n}async createMintQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/quote/bolt11",{requestBody:t},e);return es(n,this._logger)}async createMintQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/mint/quote/bolt12",{requestBody:t},e)}async checkMintQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/mint/quote/bolt11/${t}`,{},e);return es(n,this._logger)}async checkMintQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/mint/quote/bolt12/${t}`,{},e)}async mintBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt11",{requestBody:t},e);if(!wt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt11"}),new Error("Invalid response from mint");return n}async mintBolt12(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt12",{requestBody:t},e);if(!wt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt12"}),new Error("Invalid response from mint");return n}async createMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/melt/quote/bolt11",{requestBody:t},e),s=yn(n,this._logger);if(!wt(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string")throw this._logger.error("Invalid response from mint...",{data:s,op:"createMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async createMeltQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/melt/quote/bolt12",{requestBody:t},e)}async checkMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/melt/quote/bolt11/${t}`,{},e),s=yn(n,this._logger);if(!wt(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string"||typeof s?.state!="string"||!Object.values(oe).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"checkMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async checkMeltQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/melt/quote/bolt12/${t}`,{},e)}async melt(t,e,n){const s={...n?.preferAsync?{Prefer:"respond-async"}:{}};nn(!this.isValidMethodString(t),`Invalid melt method: ${t}`,this._logger);const i=await this.requestWithAuth("POST",`/v1/melt/${t}`,{requestBody:e,headers:s},n?.customRequest);if(!wt(i))throw this._logger.error("Invalid response from mint...",{data:i,op:"melt"}),new Error("Invalid response from mint");return i}async meltBolt11(t,e){const n=await this.melt("bolt11",t,e),s=yn(n,this._logger);if(!wt(s)||typeof s?.state!="string"||!Object.values(oe).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"meltBolt11"}),new Error("Invalid response from mint");return s}async meltBolt12(t,e){return this.melt("bolt12",t,e)}async check(t,e){const n=await this.requestWithAuth("POST","/v1/checkstate",{requestBody:t},e);if(!wt(n)||!Array.isArray(n?.states))throw this._logger.error("Invalid response from mint...",{data:n,op:"check"}),new Error("Invalid response from mint");return n}async getKeys(t,e,n){const s=e||this._mintUrl;t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const i=await(n??this._request)({endpoint:t?Yt(s,"/v1/keys",t):Yt(s,"/v1/keys")});if(!wt(i)||!Array.isArray(i.keysets))throw this._logger.error("Invalid response from mint...",{data:i,op:"getKeys"}),new Error("Invalid response from mint");return i}async getKeySets(t){return(t??this._request)({endpoint:Yt(this._mintUrl,"/v1/keysets")})}async restore(t,e){const n=await(e??this._request)({endpoint:Yt(this._mintUrl,"/v1/restore"),method:"POST",requestBody:t});if(!wt(n)||!Array.isArray(n?.outputs)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"restore"}),new Error("Invalid response from mint");return n}async connectWebSocket(){try{const t=new URL(this._mintUrl),e="v1/ws";t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e,t.protocol=t.protocol==="https:"?"wss:":"ws:";const n=t.toString();this.ws||(this.ws=Jt.getInstance().getConnection(n,this._logger)),await this.ws.ensureConnection()}catch(t){this._logger.error("Failed to connect to WebSocket...",{e:t});try{this.ws?.close()}catch{}throw this.ws=void 0,new Error("Failed to connect to WebSocket...")}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleClearAuth(t,e){if(!(!this._authProvider||!(await this.getLazyMintInfo()).requiresClearAuthToken(t,e)))return this._logger.error("Clear Authentication Token...",{cat:this._authProvider.getCAT()}),this._authProvider.getCAT()}async handleBlindAuth(t,e){if(!this._authProvider||!(await this.getLazyMintInfo()).requiresBlindAuthToken(t,e))return;const n=await this._authProvider.getBlindAuthToken({method:t,path:e});return this._logger.error("Blind Authentication Token...",{bat:n}),n}async requestWithAuth(t,e,n={},s){const i=s??this._request,o=await this.handleBlindAuth(t,e),a=await this.handleClearAuth(t,e),c={...n.headers??{},...o?{"Blind-auth":o}:{},...a?{"Clear-auth":a}:{}};return i({...n,endpoint:Yt(this._mintUrl,e),method:t,headers:c})}isValidMethodString(t){return!!(typeof t=="string"&&/^[a-z0-9_-]+$/.test(t))}}class ae{constructor(t,e,n,s,i){this._keys={},this._id=t,this._unit=e,this._active=n,this._input_fee_ppk=s,this._final_expiry=i}get id(){return this._id}get unit(){return this._unit}get isActive(){return this._active}get fee(){return this._input_fee_ppk??0}get expiry(){return this._final_expiry}get hasKeys(){return Object.keys(this._keys).length>0}get hasHexId(){return Gt(this._id)}get keys(){return this._keys}set keys(t){this._keys=t}get active(){return this.isActive}get input_fee_ppk(){return this.fee}get final_expiry(){return this.expiry}toMintKeyset(){return{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry}}toMintKeys(){return this.hasKeys?{id:this._id,unit:this._unit,keys:this._keys}:null}verify(){return this.hasKeys?ae.verifyKeysetId({id:this._id,unit:this._unit,final_expiry:this._final_expiry,keys:this._keys}):!1}static verifyKeysetId(t){if(!t.keys||Object.keys(t.keys).length===0)return!1;const e=on(t.id)&&!Gt(t.id),n=Gt(t.id)?G(t.id)[0]:0;return Wo(t.keys,t.unit,t.final_expiry,n,e)===t.id}static fromMintApi(t,e){const n=new ae(t.id,t.unit,t.active,t.input_fee_ppk,t.final_expiry);if(e){if(e.id!==t.id)throw new Error(`Mismatched keyset ids: meta=${t.id}, keys=${e.id}`);if(e.unit!==t.unit)throw new Error(`Mismatched keyset units: meta=${t.unit}, keys=${e.unit}`);if(e.final_expiry!==void 0&&t.final_expiry!==void 0&&e.final_expiry!==t.final_expiry)throw new Error(`Mismatched keyset expiry for id=${t.id}`);n.keys=e.keys}return n}}class Ft{constructor(t,e,n,s){if(this.keysets={},this.mint=typeof t=="string"?new ns(t):t,this.unit=e,n&&s){const i=Array.isArray(s)?s:[s];this.buildKeychain(n,i),this.getCheapestKeyset()}}static fromCache(t,e){const n=new Ft(t,e.unit);return n.loadFromCache(e),n}static mintToCacheDTO(t,e,n,s){const i=new Map(s.map(o=>[o.id,o]));return{keysets:n.map(o=>{const a=i.get(o.id),c={...o};return a&&(c.keys=a.keys),c}),unit:t,mintUrl:e}}static cacheToMintDTO(t){const e=t.keysets.map(s=>({id:s.id,unit:s.unit,active:s.active,input_fee_ppk:s.input_fee_ppk,final_expiry:s.final_expiry})),n=t.keysets.filter(s=>!!s.keys).map(s=>({id:s.id,unit:s.unit,keys:s.keys,final_expiry:s.final_expiry}));return{keysets:e,keys:n}}async init(t){if(Object.keys(this.keysets).length>0&&!t)return;const[e,n]=await Promise.all([this.mint.getKeySets(),this.mint.getKeys()]);this.buildKeychain(e.keysets,n.keysets),this.getCheapestKeyset()}loadFromCache(t){if(t.unit!==this.unit)throw new Error(`KeyChain unit mismatch in cache, expected '${this.unit}', got '${t.unit}' from ${t.mintUrl}`);const{keysets:e,keys:n}=Ft.cacheToMintDTO(t);this.buildKeychain(e,n),this.getCheapestKeyset()}buildKeychain(t,e){this.keysets={};const n=t.filter(i=>i.unit===this.unit);if(!n.length)throw new Error(`No Keysets found for unit: ${this.unit}`);const s=new Map(e.filter(i=>i.unit===this.unit).map(i=>[i.id,i]));for(const i of n){let o;if(i.active&&Gt(i.id)){const a=s.get(i.id);o=ae.fromMintApi(i,a)}else o=ae.fromMintApi(i);if(o.hasKeys&&!o.verify())throw new Error(`Keyset verification failed for ID ${o.id}`);this.keysets[o.id]=o}}getKeyset(t){const e=t?this.keysets[t]:this.getCheapestKeyset();if(!e)throw new Error(`Keyset '${t}' not found`);return e}getCheapestKeyset(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");const t=Object.values(this.keysets).filter(e=>e.isActive&&e.hasHexId&&e.hasKeys);if(t.length===0)throw new Error("No active keyset found");return t.sort((e,n)=>e.fee-n.fee)[0]}getKeysets(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");return Object.values(this.keysets)}getAllKeys(){return this.getKeysets().map(t=>t.toMintKeys()).filter(t=>t!==null)}getAllKeysetIds(){return this.getKeysets().map(t=>t.id)}get cache(){const t=this.getKeysets(),e=t.map(s=>s.toMintKeyset()),n=t.map(s=>s.toMintKeys()).filter(s=>s!==null);return Ft.mintToCacheDTO(this.unit,this.mint.mintUrl,e,n)}getCache(){const t=this.cache,{keysets:e,keys:n}=Ft.cacheToMintDTO(t);return{keysets:e,keys:n,unit:t.unit,mintUrl:t.mintUrl}}}class vn{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const Xo=new Set(["locktime","pubkeys","n_sigs","refund","n_sigs_refund"]);function ta(r){if(!r||typeof r!="string")throw new Error("tag key must be a non empty string");if(Xo.has(r))throw new Error(`additionalTags must not use reserved key "${r}"`)}const rs=1024,kn=new WeakMap;function ea(r,t){t&&kn.set(r,t)}function na(r){const t=kn.get(r);if(t)return kn.delete(r),t}class dt{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:G(t.dleq.s),e:G(t.dleq.e),r:this.blindingFactor});const s={id:t.id,amount:t.amount,C_:Zt(t.C_)},i=Zt(e.keys[t.amount]),o=ao(s,this.blindingFactor,this.secret,i),a={...co(o),...n&&{dleq:{s:et(n.s),e:et(n.e),r:fn(n.r??BigInt(0))}}},c=na(this);return c&&(a.p2pk_e=c),a}static createP2PKData(t,e,n,s){return Tt(e,n.keys,s).map(i=>this.createSingleP2PKData(t,i,n.id))}static createSingleP2PKData(t,e,n){const s=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],i=t.refundKeys??[],o=Math.max(1,Math.min(t.requiredSignatures??1,s.length)),a=Math.max(1,Math.min(t.requiredRefundSignatures??1,i.length||1));if(s.length===0)throw new Error("P2PK requires at least one pubkey");const c=typeof t.hashlock=="string"&&t.hashlock.length>0;let l=c?t.hashlock:s[0],h=c?s:s.slice(1),d=i,g;if(t.blindKeys){const Y=[...s,...i],{blinded:N,Ehex:C}=yo(Y,n);c?h=N.slice(0,s.length):(l=N[0],h=N.slice(1,s.length)),d=N.slice(s.length),g=C}const p=[],y=t.locktime??NaN;if(Number.isSafeInteger(y)&&y>=0&&p.push(["locktime",String(y)]),h.length>0&&(p.push(["pubkeys",...h]),o>1&&p.push(["n_sigs",String(o)])),d.length>0&&(p.push(["refund",...d]),a>1&&p.push(["n_sigs_refund",String(a)])),t.sigFlag=="SIG_ALL"&&p.push(["sigflag","SIG_ALL"]),t.additionalTags?.length){const Y=t.additionalTags.map(([N,...C])=>(ta(N),[N,...C.map(String)]));p.push(...Y)}const I=[c?"HTLC":"P2PK",{nonce:et(Nt(32)),data:l,tags:p}],k=JSON.stringify(I),O=[...k].length;if(O>rs)throw new Error(`Secret too long (${O} characters), maximum is ${rs}`);const $=new TextEncoder().encode(k),{r:U,B_:R}=cn($),j=new dt(new vn(e,R,n).getSerializedBlindedMessage(),U,$);return t.blindKeys&&g&&ea(j,g),j}static createRandomData(t,e,n){return Tt(t,e.keys,n).map(s=>this.createSingleRandomData(s,e.id))}static createSingleRandomData(t,e){const n=et(Nt(32)),s=new TextEncoder().encode(n),{r:i,B_:o}=cn(s);return new dt(new vn(t,o,e).getSerializedBlindedMessage(),i,s)}static createDeterministicData(t,e,n,s,i){return Tt(t,s.keys,i).map((o,a)=>this.createSingleDeterministicData(o,e,n+a,s.id))}static createSingleDeterministicData(t,e,n,s){const i=qo(e,s,n),o=et(i),a=new TextEncoder().encode(o),c=z.toBigInt(No(e,s,n)),{r:l,B_:h}=cn(a,c);return new dt(new vn(t,h,s).getSerializedBlindedMessage(),l,a)}static sumOutputAmounts(t){return t.reduce((e,n)=>e+n.blindedMessage.amount,0)}}const ra=(r,t,e,n=!1,s=!1,i=ft)=>{const o=Ci();let a=null,c=1/0,l=0,h=0;const d=N=>{try{return e.getKeyset(N.id).fee}catch(C){Ie(`Could not get fee. No keyset found for keyset id: ${N.id}`,i,{error:C,keychain:e.getKeysets()})}},g=(N,C)=>N-(n?Math.ceil(C/1e3):0),p=N=>{const C=[...N];for(let M=C.length-1;M>0;M--){const K=Math.floor(Math.random()*(M+1));[C[M],C[K]]=[C[K],C[M]]}return C},y=(N,C,M)=>{let K=0,J=N.length-1,L=null;for(;K<=J;){const E=Math.floor((K+J)/2),_=N[E].exFee;(M?_<=C:_>=C)?(L=E,M?K=E+1:J=E-1):M?J=E-1:K=E+1}return M?L:K<N.length?K:null},I=(N,C)=>{const M=C.exFee;let K=0,J=N.length;for(;K<J;){const L=Math.floor((K+J)/2);N[L].exFee<M?K=L+1:J=L}N.splice(K,0,C)},k=(N,C)=>g(N,C)<t?1/0:N+C/1e3-t;let O=0,$=0;const U=r.map(N=>{const C=d(N),M=n?N.amount-C/1e3:N.amount,K={proof:N,exFee:M,ppkfee:C};return(!n||M>0)&&(O+=N.amount,$+=C),K});let R=n?U.filter(N=>N.exFee>0):U;if(R.sort((N,C)=>N.exFee-C.exFee),R.length>0){let N;if(s){const C=y(R,t,!0);N=C!==null?C+1:0}else{const C=y(R,t,!1);if(C!==null){const M=R[C].exFee,K=y(R,M,!0);Tr(K,"Unexpected null rightIndex in binary search",i),N=K+1}else N=R.length}for(let C=N;C<R.length;C++)O-=R[C].proof.amount,$-=R[C].ppkfee;R=R.slice(0,N)}const j=g(O,$);if(t<=0||t>j)return{keep:r,send:[]};const Y=Math.min(Math.ceil(t*(1+0/100)),t+0,j);for(let N=0;N<60;N++){const C=[];let M=0,K=0;for(const w of p(R)){const m=M+w.proof.amount,b=K+w.ppkfee,x=g(m,b);if(s&&x>t||(C.push(w),M=m,K=b,x>=t))break}const J=new Set(C),L=R.filter(w=>!J.has(w)),E=p(Array.from({length:C.length},(w,m)=>m)).slice(0,5e3);for(const w of E){const m=g(M,K);if(m===t||!s&&m>=t&&m<=Y)break;const b=C[w],x=M-b.proof.amount,A=K-b.ppkfee,f=g(x,A),u=t-f,v=y(L,u,s);if(v!==null){const S=L[v];(!s||S.exFee>b.exFee)&&(u>=0||S.exFee<=b.exFee)&&(C[w]=S,M=x+S.proof.amount,K=A+S.ppkfee,L.splice(v,1),I(L,b))}}const _=k(M,K);if(_<c){i.debug(`selectProofsToSend: best solution found in trial #${N} - amount: ${M}, delta: ${_}`),a=[...C].sort((m,b)=>b.exFee-m.exFee),c=_,l=M,h=K;const w=[...a];for(;w.length>1&&c>0;){const m=w.pop(),b=M-m.proof.amount,x=K-m.ppkfee,A=k(b,x);if(A==1/0)break;A<c&&(a=[...w],c=A,l=b,h=x,M=b,K=x)}}if(a&&c<1/0){const w=g(l,h);if(w===t||!s&&w>=t&&w<=Y)break}if(o.elapsed()>1e3){nn(s,"Proof selection took too long. Try again with a smaller proof set.",i),i.warn("Proof selection took too long. Returning best selection so far.");break}}if(a&&c<1/0){const N=a.map(K=>K.proof),C=new Set(N),M=r.filter(K=>!C.has(K));return i.info(`Proof selection took ${o.elapsed()}ms`),{keep:M,send:N}}return{keep:r,send:[]}};class sa{constructor(t){if(this.next=new Map,this.locks=new Map,t)for(const[e,n]of Object.entries(t))this.next.set(e,n)}async withLock(t,e){const n=this.locks.get(t)??Promise.resolve();let s;const i=new Promise(a=>s=a),o=n.then(()=>i);this.locks.set(t,o);try{return await n,await e()}finally{s(),this.locks.get(t)===o&&this.locks.delete(t)}}async reserve(t,e){if(e<0)throw new Error("reserve called with negative count");return this.withLock(t,()=>{const n=this.next.get(t)??0;return e===0?{start:n,count:0}:(this.next.set(t,n+e),{start:n,count:e})})}async advanceToAtLeast(t,e){await this.withLock(t,()=>{const n=this.next.get(t)??0;e>n&&this.next.set(t,e)})}async setNext(t,e){await this.withLock(t,()=>{if(e<0)throw new Error("setNext: negative next not allowed");this.next.set(t,e)})}snapshot(){return Promise.resolve(Object.fromEntries(this.next.entries()))}}class ia{constructor(t){this.wallet=t}send(t,e){return new oa(this.wallet,t,e)}receive(t){return new aa(this.wallet,t)}mintBolt11(t,e){return new ss(this.wallet,"bolt11",t,e)}mintBolt12(t,e){return new ss(this.wallet,"bolt12",t,e)}meltBolt11(t,e){return new is(this.wallet,"bolt11",t,e)}meltBolt12(t,e){return new is(this.wallet,"bolt12",t,e)}}class oa{constructor(t,e,n){this.wallet=t,this.amount=e,this.proofs=n,this.config={}}asRandom(t){return this.sendOT={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.sendOT={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.sendOT={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.sendOT={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.sendOT={type:"custom",data:t},this}keepAsRandom(t){return this.keepOT={type:"random",denominations:t},this}keepAsDeterministic(t=0,e){return this.keepOT={type:"deterministic",counter:t,denominations:e},this}keepAsP2PK(t,e){return this.keepOT={type:"p2pk",options:t,denominations:e},this}keepAsFactory(t,e){return this.keepOT={type:"factory",factory:t,denominations:e},this}keepAsCustom(t){return this.keepOT={type:"custom",data:t},this}includeFees(t=!0){return this.config.includeFees=t,this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}offlineExactOnly(t=!1){return this.offlineExact={requireDleq:t},this}offlineCloseMatch(t=!1){return this.offlineClose={requireDleq:t},this}async prepare(){const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.prepareSwapToSend(this.amount,this.proofs,this.config,t)}async run(){if((this.offlineExact||this.offlineClose)&&(this.sendOT||this.keepOT))throw new Error("Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.");if(this.offlineExact)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!0,requireDleq:this.offlineExact.requireDleq});if(this.offlineClose)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!1,requireDleq:this.offlineClose.requireDleq});const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.send(this.amount,this.proofs,this.config,t)}}class aa{constructor(t,e){this.wallet=t,this.token=e,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}requireDleq(t=!0){return this.config.requireDleq=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async prepare(){return this.wallet.prepareSwapToReceive(this.token,this.config,this.outputType)}async run(){return this.wallet.receive(this.token,this.config,this.outputType)}}class ss{constructor(t,e,n,s){this.wallet=t,this.method=e,this.amount=n,this.quote=s,this.config={},this._hasPrivkey}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){if(this.method==="bolt11"){const e=this.quote;if(typeof e!="string"&&e.pubkey&&!this.config.privkey)throw new Error("privkey is required for locked BOLT11 mint quotes");return this.wallet.mintProofsBolt11(this.amount,e,this.config,this.outputType)}const t=this.quote;if(!this.config.privkey)throw new Error("privkey is required for BOLT12 mint quotes");return this.wallet.mintProofsBolt12(this.amount,t,this.config.privkey,this.config,this.outputType)}}class is{constructor(t,e,n,s){this.wallet=t,this.method=e,this.quote=n,this.proofs=s,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}onChangeOutputsCreated(t){return this.config.onChangeOutputsCreated=t,this}async prepare(){return await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType)}async run(){const t=await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType);return this.wallet.completeMelt(t,this.config.privkey)}}function ca(r){const t=new WeakSet;try{return JSON.stringify(r,(e,n)=>{if(typeof n=="object"&&n!==null){if(t.has(n))return"[Circular]";t.add(n)}return n})}catch{return Object.prototype.toString.call(r)}}function os(r){if(r instanceof Error)return r;const t=typeof r=="string"?r:ca(r),e=new Error(t);return e.cause=r,e}function as(){const r=new Error("Aborted");return Object.defineProperty(r,"name",{value:"AbortError"}),r}function Kt(r){r&&Promise.resolve(r).then(t=>{try{t()}catch{}}).catch(()=>{})}class ua{constructor(t){this.wallet=t,this.countersReservedHandlers=new Set,this.meltBlanksHandlers=new Set}withAbort(t,e){if(!t)return e;if(t.aborted)return e(),()=>{};const n=()=>e();return t.addEventListener("abort",n,{once:!0}),()=>{t.removeEventListener("abort",n),e()}}waitUntilPaid(t,e,n,s="Timeout waiting for paid"){return new Promise((i,o)=>{let a=null,c=null,l=!1;const h=g=>{l||(l=!0,Kt(a),c&&(clearTimeout(c),c=null),n?.signal&&n.signal.removeEventListener("abort",d),g&&o(os(g)))},d=()=>h(as());if(n?.signal){if(n.signal.aborted)return d();n.signal.addEventListener("abort",d,{once:!0})}n?.timeoutMs&&n.timeoutMs>0&&(c=setTimeout(()=>h(new Error(s)),n.timeoutMs)),a=t(e,g=>{h(),i(g)},g=>h(g),{signal:n?.signal}),a.catch(g=>h(g))})}countersReserved(t,e){this.countersReservedHandlers.add(t);const n=()=>this.countersReservedHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitCountersReserved(t){for(const e of this.countersReservedHandlers)ie(e,t,this.wallet.logger,{event:"countersReserved"})}meltBlanksCreated(t,e){this.meltBlanksHandlers.add(t);const n=()=>this.meltBlanksHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitMeltBlanksCreated(t){for(const e of this.meltBlanksHandlers)ie(e,t,this.wallet.logger,{event:"meltBlanksCreated"})}async mintQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),a=i.createSubscription({kind:"bolt11_mint_quote",filters:o},e,n),c=()=>i.cancelSubscription(a,e);return this.withAbort(s?.signal,c)}async mintQuotePaid(t,e,n,s){return this.mintQuoteUpdates([t],i=>{i.state===gn.PAID&&e(i)},n,s)}async meltQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),a=i.createSubscription({kind:"bolt11_melt_quote",filters:o},e,n),c=()=>i.cancelSubscription(a,e);return this.withAbort(s?.signal,c)}async meltQuotePaid(t,e,n,s){return this.meltQuoteUpdates([t],i=>{i.state===oe.PAID&&e(i)},n,s)}async proofStateUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=new TextEncoder,a={};for(const g of t){const p=Se(o.encode(g.secret)).toHex(!0);a[p]=g}const c=Object.keys(a),l=g=>{e({...g,proof:a[g.Y]})},h=i.createSubscription({kind:"proof_state",filters:c},l,n),d=()=>i.cancelSubscription(h,l);return this.withAbort(s?.signal,d)}onceMintPaid(t,e){return this.waitUntilPaid(this.mintQuotePaid.bind(this),t,e,"Timeout waiting for mint paid")}onceAnyMintPaid(t,e){return new Promise((n,s)=>{const i=Array.from(new Set(t)),o=new Map;let a=null,c=null,l=!1,h=!1;const d=p=>{if(!h){h=!0;for(const y of o.values())Kt(y);o.clear(),a&&(clearTimeout(a),a=null),e?.signal&&e.signal.removeEventListener("abort",g),p&&s(os(p))}},g=()=>d(as());if(e?.signal){if(e.signal.aborted)return g();e.signal.addEventListener("abort",g,{once:!0})}if(e?.timeoutMs&&e.timeoutMs>0&&(a=setTimeout(()=>d(new Error("Timeout waiting for any mint paid")),e.timeoutMs)),i.length===0)return d(new Error("No quote ids provided"));for(const p of i){const y=this.mintQuotePaid(p,I=>{d(),n({id:p,quote:I})},I=>{if(e?.failOnError){d(I);return}c=I;const k=o.get(p);k&&(Kt(k),o.delete(p)),l&&o.size===0&&d(c??new Error("No subscriptions remaining"))});o.set(p,y),y.catch(I=>{if(e?.failOnError){d(I);return}c=I;const k=o.get(p);k&&(Kt(k),o.delete(p)),l&&o.size===0&&d(c??new Error("No subscriptions remaining"))})}l=!0})}onceMeltPaid(t,e){return this.waitUntilPaid(this.meltQuotePaid.bind(this),t,e,"Timeout waiting for melt paid")}proofStatesStream(t,e){return(async function*(){const n=[];let s=!1,i=null;const o=e?.maxBuffer&&e.maxBuffer>0?e.maxBuffer:1/0,a=e?.drop??"oldest",c=()=>{const g=i;i=null,g&&g()},l=g=>{if(n.length>=o)if(a==="oldest"){const p=n.shift();if(p!==void 0)try{e?.onDrop?.(p)}catch{}n.push(g)}else{try{e?.onDrop?.(g)}catch{}return}else n.push(g);c()},h=this.proofStateUpdates(t,g=>{l(g)},()=>{s=!0,c()},{signal:e?.signal}),d=()=>{s=!0,c()};try{for(e?.signal&&(e.signal.aborted?d():e.signal.addEventListener("abort",d,{once:!0}));!s||n.length;){for(;n.length;)yield n.shift();if(s)break;await new Promise(g=>i=g)}}finally{Kt(h),e?.signal&&e.signal.removeEventListener("abort",d)}}).call(this)}group(){const t=[];let e=!1;const n=(()=>{if(!e)for(e=!0;t.length;)Kt(t.pop())});return n.add=s=>e?(Kt(s),s):(t.push(s),s),Object.defineProperty(n,"cancelled",{get:()=>e,enumerable:!0}),n}}class la{constructor(t){this.src=t}async peekNext(t){return(await this.src.reserve(t,0)).start}async advanceToAtLeast(t,e){await this.src.advanceToAtLeast(t,e)}async setNext(t,e){if(typeof this.src.setNext=="function"){await this.src.setNext(t,e);return}throw new Error("CounterSource does not support setNext()")}async snapshot(){if(typeof this.src.snapshot=="function")return await this.src.snapshot();throw new Error("CounterSource does not support snapshot()")}}const En="__PENDING__";class _n{constructor(t,e){if(this._seed=void 0,this._unit="sat",this._mintInfo=void 0,this._denominationTarget=3,this._secretsPolicy="auto",this._boundKeysetId=En,this.swap=this.send.bind(this),this.ops=new ia(this),this.on=new ua(this),this._logger=e?.logger??ft,this._selectProofs=e?.selectProofs??ra,this.mint=typeof t=="string"?new ns(t,{authProvider:e?.authProvider,logger:this._logger}):t,this._unit=e?.unit??this._unit,this._boundKeysetId=e?.keysetId??this._boundKeysetId,e?.bip39seed&&(this.failIf(!(e.bip39seed instanceof Uint8Array),"bip39seed must be a valid Uint8Array",{bip39seed:e.bip39seed}),this._seed=e.bip39seed),this._secretsPolicy=e?.secretsPolicy??this._secretsPolicy,e?.counterSource?this._counterSource=e.counterSource:this._counterSource=new sa(e?.counterInit),this.counters=new la(this._counterSource),this._keyChain=new Ft(this.mint,this._unit),this._denominationTarget=e?.denominationTarget??this._denominationTarget,e?.keysets&&e?.keys&&e?.mintInfo){const n=Array.isArray(e.keys)?e.keys:[e.keys],s=Ft.mintToCacheDTO(this._unit,this.mint.mintUrl,e.keysets,n);this.loadMintFromCache(e.mintInfo,s)}}fail(t,e){return Ie(t,this._logger,e)}failIf(t,e,n){return nn(t,e,this._logger,n)}failIfNullish(t,e,n){return Tr(t,e,this._logger,n)}safeCallback(t,e,n){ie(t,e,this._logger,n)}assertAmount(t,e){try{dn(t,!1)}catch(n){this.fail(n.message,{op:e,amount:t})}}async loadMint(t){const e=[];(!this._mintInfo||t)&&e.push(this.mint.getInfo().then(n=>(this._mintInfo=new wn(n),null))),e.push(this._keyChain.init(t).then(()=>null)),await Promise.all(e),this.finishInit()}loadMintFromCache(t,e){this._mintInfo=new wn(t),this._keyChain.loadFromCache(e),this.finishInit()}finishInit(){const t=this._keyChain.getCheapestKeyset().id;if(this._logger.debug("KeyChain",{keychain:this._keyChain.cache}),this._boundKeysetId===En)this._boundKeysetId=t;else{const e=this._keyChain.getKeyset(this._boundKeysetId);this.failIf(!e.hasKeys,"Wallet keyset has no keys",{keyset:e.id})}this.getMintInfo()}get keyChain(){return this._keyChain}get unit(){return this._unit}getMintInfo(){return this.failIfNullish(this._mintInfo,"Mint info not initialized; call loadMint or loadMintFromCache first"),this._mintInfo}get keysetId(){return this.failIf(this._boundKeysetId===En,"Wallet not initialised, call loadMint or loadMintFromCache first"),this._boundKeysetId}getKeyset(t){const e=this._keyChain.getKeyset(t??this.keysetId);return this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),e}get logger(){return this._logger}async reserveFor(t,e){return e<=0?{start:0,count:0}:this._counterSource.reserve(t,e)}countersNeeded(t){return t.type!=="deterministic"||t.counter!==0?0:(t.denominations??[]).length}async addCountersToOutputTypes(t,...e){const n=e.filter(l=>l.type==="deterministic"&&l.counter>0&&(l.denominations?.length??0)>0);if(n.length>1){const l=n.map(h=>({start:h.counter,end:h.counter+h.denominations.length})).sort((h,d)=>h.start-d.start);for(let h=1;h<l.length;h++)this.failIf(l[h].start<l[h-1].end,"Manual counter ranges overlap",{keysetId:t,prev:l[h-1],cur:l[h]})}if(n.length>0){const l=Math.max(...n.map(h=>h.counter+h.denominations.length));await this._counterSource.advanceToAtLeast(t,l),this._logger.debug("Counter source advanced to respect manual deterministic counters",{keysetId:t,maxManualEnd:l})}const s=e.reduce((l,h)=>l+this.countersNeeded(h),0);if(s===0)return{outputTypes:e};const i=await this.reserveFor(t,s);let o=i.start;const a=e.map(l=>{if(l.type==="deterministic"&&l.counter===0){const h=l.denominations?.length??0;if(h>0){const d={...l,counter:o};return o+=h,d}}return l}),c={keysetId:t,start:i.start,count:i.count,next:i.start+i.count};return this.on._emitCountersReserved(c),{outputTypes:a,used:c}}bindKeyset(t){const e=this._keyChain.getKeyset(t);this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),this._boundKeysetId=e.id,this._logger.debug("Wallet bound to keyset",{keysetId:e.id,unit:e.unit,feePPK:e.fee})}withKeyset(t,e){const n=new _n(this.mint,{keysetId:t,bip39seed:this._seed,secretsPolicy:this._secretsPolicy,logger:this._logger,counterSource:e?.counterSource??this._counterSource});return n.loadMintFromCache(this.getMintInfo().cache,this._keyChain.cache),n}defaultOutputType(){return this._secretsPolicy==="random"?{type:"random"}:this._secretsPolicy==="deterministic"?(this.failIfNullish(this._seed,"Deterministic policy requires a seed"),{type:"deterministic",counter:0}):this._seed?{type:"deterministic",counter:0}:{type:"random"}}configureOutputs(t,e,n,s=!1,i=[]){let o=t;if(n.type==="custom"){this.failIf(s,"The custom OutputType does not support automatic fee inclusion");const c=dt.sumOutputAmounts(n.data);return this.failIf(c!==t,`Custom output data total (${c}) does not match amount (${t})`),n}let a=n.denominations??[];if(a.length===0&&i.length>0&&(a=Ro(i,o,e.keys,this._denominationTarget)),a=Tt(o,e.keys,a),s){let c=this.getFeesForKeyset(a.length,e.id),l=Tt(c,e.keys);for(;this.getFeesForKeyset(a.length+l.length,e.id)>c;)c++,l=Tt(c,e.keys);o+=c,a=[...a,...l]}return{...n,denominations:a}}preparedTotal(t){return t.type==="custom"?dt.sumOutputAmounts(t.data):(t.denominations??[]).reduce((e,n)=>e+n,0)}createOutputData(t,e,n){if(this.failIf(t<0,"Amount was negative",{amount:t}),n.type!="custom"&&n.denominations&&n.denominations.length>0){const i=n.denominations.reduce((o,a)=>o+a,0);this.failIf(i!==t,"Denominations do not sum to the expected amount",{splitSum:i,expected:t})}let s;switch(n.type){case"random":s=dt.createRandomData(t,e,n.denominations);break;case"deterministic":this.failIfNullish(this._seed,"Deterministic outputs require a seed configured in the wallet"),s=dt.createDeterministicData(t,this._seed,n.counter,e,n.denominations);break;case"p2pk":s=dt.createP2PKData(n.options,t,e,n.denominations);break;case"factory":{s=Tt(t,e.keys,n.denominations).map(i=>n.factory(i,e));break}case"custom":{s=n.data;const i=dt.sumOutputAmounts(s);this.failIf(i!==t,`Custom output data total (${i}) does not match amount (${t})`);break}default:this.fail("Invalid OutputType")}return s}createSwapTransaction(t,e,n=[]){t=this._prepareInputsForMint(t);const s=[...e,...n],i=s.map((h,d)=>d);jr(t)||i.sort((h,d)=>s[h].blindedMessage.amount-s[d].blindedMessage.amount);const o=[...Array.from({length:e.length},()=>!0),...Array.from({length:n.length},()=>!1)],a=i.map(h=>s[h]),c=i.map(h=>o[h]),l=a.map(h=>h.blindedMessage);return this._logger.debug("createSwapTransaction:",{indices:i,sortedKeepVector:c}),{payload:{inputs:t,outputs:l},outputData:a,keepVector:c,sortedIndices:i}}async receive(t,e,n){const s=await this.prepareSwapToReceive(t,e,n),{keep:i}=await this.completeSwap(s,e?.privkey);return i}async prepareSwapToReceive(t,e,n){const{keysetId:s,requireDleq:i,proofsWeHave:o,onCountersReserved:a}=e||{};n=n??this.defaultOutputType();const c=typeof t=="string"?this.decodeToken(t):t,l=Jr(c.mint);this.failIf(l!==this.mint.mintUrl,"Token belongs to a different mint",{token:l,wallet:this.mint.mintUrl}),this.failIf(c.unit!==this._unit,"Token is not in wallet unit",{token:c.unit,wallet:this._unit});let h=[];({proofs:h}=c);const d=Pt(h);this.failIf(d===0,"Token contains no proofs",{proofs:h}),this.assertAmount(d,"prepareSwapToReceive");const g=this.getKeyset(s);if(i)for(const $ of h){const U=this._keyChain.getKeyset($.id);Zo($,U)||this.fail("Token contains proofs with invalid or missing DLEQ")}const p=this.getFeesForProofs(h),y=d-p;let I=this.configureOutputs(y,g,n,!1,o);const k=await this.addCountersToOutputTypes(g.id,I);[I]=k.outputTypes,k.used&&this.safeCallback(a,k.used,{op:"receive"}),this._logger.debug("receive counter",{counter:k.used,receiveOT:I});const O=this.createOutputData(this.preparedTotal(I),g,I);return{amount:y,fees:p,keysetId:g.id,inputs:h,keepOutputs:O}}sendOffline(t,e,n){this.assertAmount(t,"sendOffline");const{requireDleq:s=!1,includeFees:i=!1,exactMatch:o=!0}=n||{};s&&(e=e.filter(h=>h.dleq!=null)),this.failIf(Pt(e)<t,"Not enough funds available to send");const{keep:a,send:c}=this.selectProofsToSend(e,t,i,o),l=this._prepareInputsForMint(c,s);return{keep:a,send:l}}async send(t,e,n,s){this.assertAmount(t,"send");const{keysetId:i,includeFees:o=!1}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};try{const c=this.defaultOutputType().type==="deterministic",l=p=>!p||p.type==="random"&&(!p.denominations||p.denominations.length===0);if(i||c||!l(s.send)||s.keep&&!l(s.keep)){const p=[];throw i&&p.push("keysetId override"),c&&p.push("wallet default is deterministic"),l(s.send)||p.push("non-default send output type"),s.keep&&!l(s.keep)&&p.push("non-default keep output type"),new Error(`Options require a swap: ${p.join(", ")}`)}const{keep:h,send:d}=this.sendOffline(t,e,{includeFees:o,exactMatch:!0,requireDleq:!1}),g=o?this.getFeesForProofs(d):0;if(Pt(d)===t+g)return this._logger.info("Successful exactMatch offline selection!"),{keep:h,send:d}}catch(c){const l=c instanceof Error?c.message:"Unknown error";this._logger.debug("ExactMatch offline selection failed.",{e:l})}const a=await this.prepareSwapToSend(t,e,n,s);return await this.completeSwap(a,n?.privkey)}async prepareSwapToSend(t,e,n,s){const{keysetId:i,includeFees:o=!1,onCountersReserved:a}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};const c=this.getKeyset(i);let l=this.configureOutputs(t,c,s.send??this.defaultOutputType(),o);const h=this.preparedTotal(l),{keep:d,send:g}=this.selectProofsToSend(e,h,!0);if(g.length===0)throw new Error("Not enough funds available to send");const p=Pt(g),y=this.getFeesForProofs(g),I=p-y-h;this.failIf(I<0,"Not enough funds available for swap",{selectedSum:p,swapFee:y,sendAmount:h,changeAmount:I});let k=this.configureOutputs(I,c,s.keep??this.defaultOutputType(),!1,n?.proofsWeHave);const O=this.preparedTotal(k),$=await this.addCountersToOutputTypes(c.id,l,k);[l,k]=$.outputTypes,$.used&&this.safeCallback(a,$.used,{op:"send"}),this._logger.debug("send counters",{counter:$.used,sendOT:l,keepOT:k});const U=this.createOutputData(h,c,l),R=this.createOutputData(O,c,k);return{amount:t,fees:y,keysetId:c.id,inputs:g,sendOutputs:U,keepOutputs:R,unselectedProofs:d}}async completeSwap(t,e){const n=t?.keepOutputs?t.keepOutputs:[],s=t.sendOutputs?t.sendOutputs:[],i=t.unselectedProofs?t.unselectedProofs:[];e&&(t.inputs=this.signP2PKProofs(t.inputs,e,[...n,...s]));const o=this.createSwapTransaction(t.inputs,n,s),{signatures:a}=await this.mint.swap(o.payload);this.failIf(a.length<o.outputData.length,`Mint returned ${a.length} signatures, expected ${o.outputData.length}`);const c=this.getKeyset(t.keysetId),l=o.outputData.map((y,I)=>y.toProof(a[I],c)),h=Array(l.length),d=Array(o.keepVector.length);o.sortedIndices.forEach((y,I)=>{d[y]=o.keepVector[I],h[y]=l[I]});const g=[],p=[];return h.forEach((y,I)=>{d[I]?g.push(y):p.push(y)}),this._logger.debug("SEND COMPLETED",{unselectedProofs:i.map(y=>y.amount),keepProofs:g.map(y=>y.amount),sendProofs:p.map(y=>y.amount)}),{keep:[...g,...i],send:p}}selectProofsToSend(t,e,n=!1,s=!1){this.assertAmount(e,"selectProofsToSend");const{keep:i,send:o}=this._selectProofs(t,e,this._keyChain,n,s);return{keep:i,send:o}}signP2PKProofs(t,e,n,s){if(!jr(t))return Hr(t,e,this._logger);this.failIfNullish(n,"OutputData is required for SIG_ALL proof signing."),Ao(t);const[i,...o]=t;let a=i;const c=[Mo(t,n,s),Bo(t,n,s),So(t,n,s)];for(const l of c)a=Hr([a],e,this._logger,l)[0];return[a,...o]}getFeesForProofs(t){const e=t.reduce((n,s)=>n+this.getProofFeePPK(s),0);return Math.ceil(e/1e3)}getProofFeePPK(t){try{return this._keyChain.getKeyset(t.id).fee}catch(e){this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`,{e,keychain:this._keyChain.getKeysets()})}}getFeesForKeyset(t,e){try{const n=this._keyChain.getKeyset(e).fee;return Math.floor(Math.max((t*n+999)/1e3,0))}catch(n){this.fail(`No keyset found with ID ${e}`,{e:n})}}_prepareInputsForMint(t,e=!1){return t.map(n=>{const s=n.witness&&typeof n.witness!="string"?JSON.stringify(n.witness):n.witness,{dleq:i,p2pk_e:o,...a}=n;return e&&i?{...a,dleq:i,witness:s}:{...a,witness:s}})}decodeToken(t){const e=this._keyChain.getAllKeysetIds();return Ho(t,e)}async batchRestore(t=300,e=100,n=0,s){const i=Math.ceil(t/e),o=[];let a,c=0;for(;c<i;){const l=await this.restore(n,e,{keysetId:s});l.proofs.length>0?(c=0,o.push(...l.proofs),a=l.lastCounterWithSignature):c++,n+=e}return{proofs:o,lastCounterWithSignature:a}}async restore(t,e,n){const{keysetId:s}=n||{},i=this.getKeyset(s);this.failIfNullish(this._seed,"Cashu Wallet must be initialized with a seed to use restore");const o=Array(e).fill(0),a=dt.createDeterministicData(0,this._seed,t,i,o),{outputs:c,signatures:l}=await this.mint.restore({outputs:a.map(p=>p.blindedMessage)}),h={};c.forEach((p,y)=>h[p.B_]=l[y]);const d=[];let g;for(let p=0;p<a.length;p++){const y=h[a[p].blindedMessage.B_];y&&(g=t+p,a[p].blindedMessage.amount=y.amount,d.push(a[p].toProof(y,i)))}return{proofs:d,lastCounterWithSignature:g}}async createMintQuote(t,e){return this.createMintQuoteBolt11(t,e)}async createMintQuoteBolt11(t,e){this.assertAmount(t,"createMintQuoteBolt11"),e&&(this.getMintInfo().supportsNut04Description("bolt11",this._unit)||this.fail("Mint does not support description for bolt11"));const n={unit:this._unit,amount:t,description:e},s=await this.mint.createMintQuoteBolt11(n);return{...s,amount:s.amount||t,unit:s.unit||this._unit}}async createLockedMintQuote(t,e,n){this.assertAmount(t,"createLockedMintQuote");const{supported:s}=this.getMintInfo().isSupported(20);this.failIf(!s,"Mint does not support NUT-20");const i={unit:this._unit,amount:t,description:n,pubkey:e},o=await this.mint.createMintQuoteBolt11(i);this.failIf(typeof o.pubkey!="string","Mint returned unlocked mint quote");const a=o.pubkey;return{...o,pubkey:a,amount:o.amount||t,unit:o.unit||this._unit}}async createMintQuoteBolt12(t,e){const n=this.getMintInfo();e?.description&&!n.supportsNut04Description("bolt12",this._unit)&&this.fail("Mint does not support description for bolt12");const s={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(s)}async checkMintQuote(t){return this.checkMintQuoteBolt11(t)}async checkMintQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuoteBolt11(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt11(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt12(t,e,n,s,i){return this._mintProofs("bolt12",t,e,{...s,privkey:n},i)}async _mintProofs(t,e,n,s,i){this.assertAmount(e,`_mintProofs: ${t}`),i=i??this.defaultOutputType();const{privkey:o,keysetId:a,proofsWeHave:c,onCountersReserved:l}=s??{},h=this.getKeyset(a);let d=this.configureOutputs(e,h,i,!1,c);const g=this.preparedTotal(d),p=await this.addCountersToOutputTypes(h.id,d);[d]=p.outputTypes,p.used&&this.safeCallback(l,p.used,{op:"mintProofs"}),this._logger.debug("mint counter",{counter:p.used,mintOT:d});const y=this.createOutputData(g,h,d),I=y.map($=>$.blindedMessage),k={outputs:I,quote:typeof n=="string"?n:n.quote};if(typeof n!="string"&&n.pubkey){this.failIf(!o,"Can not sign locked quote without private key");const $=Do(o,n.quote,I);k.signature=$}let O;return t==="bolt12"?{signatures:O}=await this.mint.mintBolt12(k):{signatures:O}=await this.mint.mintBolt11(k),this.failIf(O.length!==y.length,`Mint returned ${O.length} signatures, expected ${y.length}`),this._logger.debug("MINT COMPLETED",{amounts:y.map($=>$.blindedMessage.amount)}),y.map(($,U)=>$.toProof(O[U],h))}async createMeltQuote(t,e){return this.createMeltQuoteBolt11(t,e)}async createMeltQuoteBolt11(t,e){e!==void 0&&(this.failIf(Go(t),"amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices."),this.assertAmount(e,"createMeltQuoteBolt11"));const n=this._mintInfo?.supportsAmountless?.("bolt11",this._unit)??!1,s={unit:this._unit,request:t,...n&&e!==void 0?{options:{amountless:{amount_msat:e}}}:{}},i=await this.mint.createMeltQuoteBolt11(s);return{...i,unit:i.unit||this._unit,request:i.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){this.assertAmount(e,"createMultiPathMeltQuote");const{supported:n,params:s}=this.getMintInfo().isSupported(15);this.failIf(!n,"Mint does not support NUT-15"),this.failIf(!s?.some(o=>o.method==="bolt11"&&o.unit===this._unit),`Mint does not support MPP for bolt11 and ${this._unit}`);const i={unit:this._unit,request:t,options:{mpp:{amount:e}}};return{...await this.mint.createMeltQuoteBolt11(i),request:t,unit:this._unit}}async checkMeltQuote(t){return this.checkMeltQuoteBolt11(t)}async checkMeltQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuoteBolt11(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,n,s){return this.meltProofsBolt11(t,e,n,s)}async meltProofsBolt11(t,e,n,s){const i=await this.prepareMelt("bolt11",t,e,n,s),o=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(i,n?.privkey,o)}async meltProofsBolt12(t,e,n,s){const i=await this.prepareMelt("bolt12",t,e,n,s),o=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(i,n?.privkey,o)}async prepareMelt(t,e,n,s,i){i=i??this.defaultOutputType();const{keysetId:o,onChangeOutputsCreated:a,onCountersReserved:c}=s||{},l=this.getKeyset(o),h=Pt(n),d=h-e.amount;let g=[];if(this.failIf(d<0,"Not enough proofs to cover amount + fee reserve",{sendAmount:h,quoteAmount:e.amount}),d>0){let y=Math.ceil(Math.log2(d))||1;y<0&&(y=0);const I=y?new Array(y).fill(0):[];this._logger.debug("Creating NUT-08 blanks for fee reserve",{feeReserve:d,denominations:I}),i.type==="custom"&&this.fail("Custom OutputType not supported for melt change (must be 0-sat blanks)");let k={...i,denominations:I};const O=await this.addCountersToOutputTypes(l.id,k);[k]=O.outputTypes,O.used&&this.safeCallback(c,O.used,{op:"meltProofs"}),this._logger.debug("melt counter",{counter:O.used,meltOT:k}),g=this.createOutputData(0,l,k)}const p={method:t,inputs:n,outputData:g,keysetId:l.id,quote:e};if(g.length>0){const y={method:t,payload:{quote:e.quote,inputs:n,outputs:g.map(I=>I.blindedMessage)},outputData:g,keyset:l,quote:e};this.safeCallback(a,y,{op:"meltProofs"}),this.on._emitMeltBlanksCreated(y)}return p}async completeMelt(t,e,n){this._logger.debug("meltPreview",{meltPreview:t}),t=this.maybeConvertMeltBlanks(t),this._logger.debug("meltPreview post covert",{meltPreview:t});let s=t.inputs;this._logger.debug("inputs",{inputs:s});const i=t.outputData.map(d=>d.blindedMessage),o=t.quote.quote,a=this.getKeyset(t.keysetId);e&&(s=this.signP2PKProofs(s,e,t.outputData,o)),s=this._prepareInputsForMint(s),this._logger.debug("inputs post prepare",{inputs:s});const c={quote:o,inputs:s,outputs:i},l=t.method==="bolt11"?await this.mint.meltBolt11(c,{preferAsync:n}):await this.mint.melt(t.method,c,{preferAsync:n});this.failIf((l.change?.length??0)>t.outputData.length,`Mint returned ${l.change?.length??0} signatures, but only ${t.outputData.length} blanks were provided`);const h=l.change?.map((d,g)=>t.outputData[g].toProof(d,a))??[];return n?this._logger.debug("ASYNC MELT REQUESTED",l):this._logger.debug("MELT COMPLETED",{changeAmounts:h.map(d=>d.amount)}),{quote:{...t.quote,...l},change:h}}maybeConvertMeltBlanks(t){if(!("payload"in t))return t;this._logger.warn("MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.");const{method:e,payload:n,outputData:s,keyset:i,quote:o}=t;return{method:e,inputs:n.inputs,outputData:s,keysetId:i.id,quote:o}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(o=>Se(e.encode(o.secret)).toHex(!0)),s=100,i=[];for(let o=0;o<n.length;o+=s){const a=n.slice(o,o+s),{states:c}=await this.mint.check({Ys:a}),l={};c.forEach(h=>{l[h.Y]=h});for(let h=0;h<a.length;h++){const d=l[a[h]];this.failIfNullish(d,"Could not find state for proof with Y: "+a[h]),i.push(d)}}return i}async groupProofsByState(t){const e=await this.checkProofsStates(t),n={unspent:[],pending:[],spent:[]};for(let s=0;s<e.length;s++){const i=t[s];switch(e[s].state){case mn.UNSPENT:n.unspent.push(i);break;case mn.PENDING:n.pending.push(i);break;case mn.SPENT:n.spent.push(i);break}}return n}}var xn={};(function r(t,e,n,s){var i=!!(t.Worker&&t.Blob&&t.Promise&&t.OffscreenCanvas&&t.OffscreenCanvasRenderingContext2D&&t.HTMLCanvasElement&&t.HTMLCanvasElement.prototype.transferControlToOffscreen&&t.URL&&t.URL.createObjectURL),o=typeof Path2D=="function"&&typeof DOMMatrix=="function",a=(function(){if(!t.OffscreenCanvas)return!1;try{var f=new OffscreenCanvas(1,1),u=f.getContext("2d");u.fillRect(0,0,1,1);var v=f.transferToImageBitmap();u.createPattern(v,"no-repeat")}catch{return!1}return!0})();function c(){}function l(f){var u=e.exports.Promise,v=u!==void 0?u:t.Promise;return typeof v=="function"?new v(f):(f(c,c),null)}var h=(function(f,u){return{transform:function(v){if(f)return v;if(u.has(v))return u.get(v);var S=new OffscreenCanvas(v.width,v.height),P=S.getContext("2d");return P.drawImage(v,0,0),u.set(v,S),S},clear:function(){u.clear()}}})(a,new Map),d=(function(){var f=Math.floor(16.666666666666668),u,v,S={},P=0;return typeof requestAnimationFrame=="function"&&typeof cancelAnimationFrame=="function"?(u=function(B){var q=Math.random();return S[q]=requestAnimationFrame(function T(F){P===F||P+f-1<F?(P=F,delete S[q],B()):S[q]=requestAnimationFrame(T)}),q},v=function(B){S[B]&&cancelAnimationFrame(S[B])}):(u=function(B){return setTimeout(B,f)},v=function(B){return clearTimeout(B)}),{frame:u,cancel:v}})(),g=(function(){var f,u,v={};function S(P){function B(q,T){P.postMessage({options:q||{},callback:T})}P.init=function(T){var F=T.transferControlToOffscreen();P.postMessage({canvas:F},[F])},P.fire=function(T,F,D){if(u)return B(T,null),u;var H=Math.random().toString(36).slice(2);return u=l(function(W){function X(nt){nt.data.callback===H&&(delete v[H],P.removeEventListener("message",X),u=null,h.clear(),D(),W())}P.addEventListener("message",X),B(T,H),v[H]=X.bind(null,{data:{callback:H}})}),u},P.reset=function(){P.postMessage({reset:!0});for(var T in v)v[T](),delete v[T]}}return function(){if(f)return f;if(!n&&i){var P=["var CONFETTI, SIZE = {}, module = {};","("+r.toString()+")(this, module, true, SIZE);","onmessage = function(msg) {","  if (msg.data.options) {","    CONFETTI(msg.data.options).then(function () {","      if (msg.data.callback) {","        postMessage({ callback: msg.data.callback });","      }","    });","  } else if (msg.data.reset) {","    CONFETTI && CONFETTI.reset();","  } else if (msg.data.resize) {","    SIZE.width = msg.data.resize.width;","    SIZE.height = msg.data.resize.height;","  } else if (msg.data.canvas) {","    SIZE.width = msg.data.canvas.width;","    SIZE.height = msg.data.canvas.height;","    CONFETTI = module.exports.create(msg.data.canvas);","  }","}"].join(`
`);try{f=new Worker(URL.createObjectURL(new Blob([P])))}catch(B){return typeof console<"u"&&typeof console.warn=="function"&&console.warn("ðŸŽŠ Could not load worker",B),null}S(f)}return f}})(),p={particleCount:50,angle:90,spread:45,startVelocity:45,decay:.9,gravity:1,drift:0,ticks:200,x:.5,y:.5,shapes:["square","circle"],zIndex:100,colors:["#26ccff","#a25afd","#ff5e7e","#88ff5a","#fcff42","#ffa62d","#ff36ff"],disableForReducedMotion:!1,scalar:1};function y(f,u){return u?u(f):f}function I(f){return f!=null}function k(f,u,v){return y(f&&I(f[u])?f[u]:p[u],v)}function O(f){return f<0?0:Math.floor(f)}function $(f,u){return Math.floor(Math.random()*(u-f))+f}function U(f){return parseInt(f,16)}function R(f){return f.map(j)}function j(f){var u=String(f).replace(/[^0-9a-f]/gi,"");return u.length<6&&(u=u[0]+u[0]+u[1]+u[1]+u[2]+u[2]),{r:U(u.substring(0,2)),g:U(u.substring(2,4)),b:U(u.substring(4,6))}}function Y(f){var u=k(f,"origin",Object);return u.x=k(u,"x",Number),u.y=k(u,"y",Number),u}function N(f){f.width=document.documentElement.clientWidth,f.height=document.documentElement.clientHeight}function C(f){var u=f.getBoundingClientRect();f.width=u.width,f.height=u.height}function M(f){var u=document.createElement("canvas");return u.style.position="fixed",u.style.top="0px",u.style.left="0px",u.style.pointerEvents="none",u.style.zIndex=f,u}function K(f,u,v,S,P,B,q,T,F){f.save(),f.translate(u,v),f.rotate(B),f.scale(S,P),f.arc(0,0,1,q,T,F),f.restore()}function J(f){var u=f.angle*(Math.PI/180),v=f.spread*(Math.PI/180);return{x:f.x,y:f.y,wobble:Math.random()*10,wobbleSpeed:Math.min(.11,Math.random()*.1+.05),velocity:f.startVelocity*.5+Math.random()*f.startVelocity,angle2D:-u+(.5*v-Math.random()*v),tiltAngle:(Math.random()*(.75-.25)+.25)*Math.PI,color:f.color,shape:f.shape,tick:0,totalTicks:f.ticks,decay:f.decay,drift:f.drift,random:Math.random()+2,tiltSin:0,tiltCos:0,wobbleX:0,wobbleY:0,gravity:f.gravity*3,ovalScalar:.6,scalar:f.scalar,flat:f.flat}}function L(f,u){u.x+=Math.cos(u.angle2D)*u.velocity+u.drift,u.y+=Math.sin(u.angle2D)*u.velocity+u.gravity,u.velocity*=u.decay,u.flat?(u.wobble=0,u.wobbleX=u.x+10*u.scalar,u.wobbleY=u.y+10*u.scalar,u.tiltSin=0,u.tiltCos=0,u.random=1):(u.wobble+=u.wobbleSpeed,u.wobbleX=u.x+10*u.scalar*Math.cos(u.wobble),u.wobbleY=u.y+10*u.scalar*Math.sin(u.wobble),u.tiltAngle+=.1,u.tiltSin=Math.sin(u.tiltAngle),u.tiltCos=Math.cos(u.tiltAngle),u.random=Math.random()+2);var v=u.tick++/u.totalTicks,S=u.x+u.random*u.tiltCos,P=u.y+u.random*u.tiltSin,B=u.wobbleX+u.random*u.tiltCos,q=u.wobbleY+u.random*u.tiltSin;if(f.fillStyle="rgba("+u.color.r+", "+u.color.g+", "+u.color.b+", "+(1-v)+")",f.beginPath(),o&&u.shape.type==="path"&&typeof u.shape.path=="string"&&Array.isArray(u.shape.matrix))f.fill(b(u.shape.path,u.shape.matrix,u.x,u.y,Math.abs(B-S)*.1,Math.abs(q-P)*.1,Math.PI/10*u.wobble));else if(u.shape.type==="bitmap"){var T=Math.PI/10*u.wobble,F=Math.abs(B-S)*.1,D=Math.abs(q-P)*.1,H=u.shape.bitmap.width*u.scalar,W=u.shape.bitmap.height*u.scalar,X=new DOMMatrix([Math.cos(T)*F,Math.sin(T)*F,-Math.sin(T)*D,Math.cos(T)*D,u.x,u.y]);X.multiplySelf(new DOMMatrix(u.shape.matrix));var nt=f.createPattern(h.transform(u.shape.bitmap),"no-repeat");nt.setTransform(X),f.globalAlpha=1-v,f.fillStyle=nt,f.fillRect(u.x-H/2,u.y-W/2,H,W),f.globalAlpha=1}else if(u.shape==="circle")f.ellipse?f.ellipse(u.x,u.y,Math.abs(B-S)*u.ovalScalar,Math.abs(q-P)*u.ovalScalar,Math.PI/10*u.wobble,0,2*Math.PI):K(f,u.x,u.y,Math.abs(B-S)*u.ovalScalar,Math.abs(q-P)*u.ovalScalar,Math.PI/10*u.wobble,0,2*Math.PI);else if(u.shape==="star")for(var Q=Math.PI/2*3,ct=4*u.scalar,pt=8*u.scalar,gt=u.x,_t=u.y,$t=5,bt=Math.PI/$t;$t--;)gt=u.x+Math.cos(Q)*pt,_t=u.y+Math.sin(Q)*pt,f.lineTo(gt,_t),Q+=bt,gt=u.x+Math.cos(Q)*ct,_t=u.y+Math.sin(Q)*ct,f.lineTo(gt,_t),Q+=bt;else f.moveTo(Math.floor(u.x),Math.floor(u.y)),f.lineTo(Math.floor(u.wobbleX),Math.floor(P)),f.lineTo(Math.floor(B),Math.floor(q)),f.lineTo(Math.floor(S),Math.floor(u.wobbleY));return f.closePath(),f.fill(),u.tick<u.totalTicks}function E(f,u,v,S,P){var B=u.slice(),q=f.getContext("2d"),T,F,D=l(function(H){function W(){T=F=null,q.clearRect(0,0,S.width,S.height),h.clear(),P(),H()}function X(){n&&!(S.width===s.width&&S.height===s.height)&&(S.width=f.width=s.width,S.height=f.height=s.height),!S.width&&!S.height&&(v(f),S.width=f.width,S.height=f.height),q.clearRect(0,0,S.width,S.height),B=B.filter(function(nt){return L(q,nt)}),B.length?T=d.frame(X):W()}T=d.frame(X),F=W});return{addFettis:function(H){return B=B.concat(H),D},canvas:f,promise:D,reset:function(){T&&d.cancel(T),F&&F()}}}function _(f,u){var v=!f,S=!!k(u||{},"resize"),P=!1,B=k(u,"disableForReducedMotion",Boolean),q=i&&!!k(u||{},"useWorker"),T=q?g():null,F=v?N:C,D=f&&T?!!f.__confetti_initialized:!1,H=typeof matchMedia=="function"&&matchMedia("(prefers-reduced-motion)").matches,W;function X(Q,ct,pt){for(var gt=k(Q,"particleCount",O),_t=k(Q,"angle",Number),$t=k(Q,"spread",Number),bt=k(Q,"startVelocity",Number),ga=k(Q,"decay",Number),ma=k(Q,"gravity",Number),ya=k(Q,"drift",Number),fs=k(Q,"colors",R),wa=k(Q,"ticks",Number),ds=k(Q,"shapes"),ba=k(Q,"scalar"),va=!!k(Q,"flat"),ps=Y(Q),gs=gt,Mn=[],ka=f.width*ps.x,Ea=f.height*ps.y;gs--;)Mn.push(J({x:ka,y:Ea,angle:_t,spread:$t,startVelocity:bt,color:fs[gs%fs.length],shape:ds[$(0,ds.length)],ticks:wa,decay:ga,gravity:ma,drift:ya,scalar:ba,flat:va}));return W?W.addFettis(Mn):(W=E(f,Mn,F,ct,pt),W.promise)}function nt(Q){var ct=B||k(Q,"disableForReducedMotion",Boolean),pt=k(Q,"zIndex",Number);if(ct&&H)return l(function(bt){bt()});v&&W?f=W.canvas:v&&!f&&(f=M(pt),document.body.appendChild(f)),S&&!D&&F(f);var gt={width:f.width,height:f.height};T&&!D&&T.init(f),D=!0,T&&(f.__confetti_initialized=!0);function _t(){if(T){var bt={getBoundingClientRect:function(){if(!v)return f.getBoundingClientRect()}};F(bt),T.postMessage({resize:{width:bt.width,height:bt.height}});return}gt.width=gt.height=null}function $t(){W=null,S&&(P=!1,t.removeEventListener("resize",_t)),v&&f&&(document.body.contains(f)&&document.body.removeChild(f),f=null,D=!1)}return S&&!P&&(P=!0,t.addEventListener("resize",_t,!1)),T?T.fire(Q,gt,$t):X(Q,gt,$t)}return nt.reset=function(){T&&T.reset(),W&&W.reset()},nt}var w;function m(){return w||(w=_(null,{useWorker:!0,resize:!0})),w}function b(f,u,v,S,P,B,q){var T=new Path2D(f),F=new Path2D;F.addPath(T,new DOMMatrix(u));var D=new Path2D;return D.addPath(F,new DOMMatrix([Math.cos(q)*P,Math.sin(q)*P,-Math.sin(q)*B,Math.cos(q)*B,v,S])),D}function x(f){if(!o)throw new Error("path confetti are not supported in this browser");var u,v;typeof f=="string"?u=f:(u=f.path,v=f.matrix);var S=new Path2D(u),P=document.createElement("canvas"),B=P.getContext("2d");if(!v){for(var q=1e3,T=q,F=q,D=0,H=0,W,X,nt=0;nt<q;nt+=2)for(var Q=0;Q<q;Q+=2)B.isPointInPath(S,nt,Q,"nonzero")&&(T=Math.min(T,nt),F=Math.min(F,Q),D=Math.max(D,nt),H=Math.max(H,Q));W=D-T,X=H-F;var ct=10,pt=Math.min(ct/W,ct/X);v=[pt,0,0,pt,-Math.round(W/2+T)*pt,-Math.round(X/2+F)*pt]}return{type:"path",path:u,matrix:v}}function A(f){var u,v=1,S="#000000",P='"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';typeof f=="string"?u=f:(u=f.text,v="scalar"in f?f.scalar:v,P="fontFamily"in f?f.fontFamily:P,S="color"in f?f.color:S);var B=10*v,q=""+B+"px "+P,T=new OffscreenCanvas(B,B),F=T.getContext("2d");F.font=q;var D=F.measureText(u),H=Math.ceil(D.actualBoundingBoxRight+D.actualBoundingBoxLeft),W=Math.ceil(D.actualBoundingBoxAscent+D.actualBoundingBoxDescent),X=2,nt=D.actualBoundingBoxLeft+X,Q=D.actualBoundingBoxAscent+X;H+=X+X,W+=X+X,T=new OffscreenCanvas(H,W),F=T.getContext("2d"),F.font=q,F.fillStyle=S,F.fillText(u,nt,Q);var ct=1/v;return{type:"bitmap",bitmap:T.transferToImageBitmap(),matrix:[ct,0,0,ct,-H*ct/2,-W*ct/2]}}e.exports=function(){return m().apply(this,arguments)},e.exports.reset=function(){m().reset()},e.exports.create=_,e.exports.shapeFromPath=x,e.exports.shapeFromText=A})((function(){return typeof window<"u"?window:typeof self<"u"?self:this||{}})(),xn,!1);const In=xn.exports;xn.exports.create;async function ha(r){if(!r)return Promise.resolve(!1);if(navigator.clipboard&&navigator.clipboard.writeText)return navigator.clipboard.writeText(r).then(()=>!0).catch(()=>!1);try{const t=document.createElement("textarea");t.value=r,t.style.top="0",t.style.left="0",t.style.position="fixed",document.body.appendChild(t),t.focus(),t.select();const e=document.execCommand("copy");return document.body.removeChild(t),Promise.resolve(!!e)}catch{return Promise.resolve(!1)}}function fa(){var r=250,t=Date.now()+r;(function e(){In({particleCount:7,angle:60,spread:55,origin:{x:0}}),In({particleCount:7,angle:120,spread:55,origin:{x:1}}),Date.now()<t&&requestAnimationFrame(e)})(),In.reset()}const lt=r=>new Promise(t=>setTimeout(t,r));function An(r,t="Unknown error"){return r instanceof Error?r.message:typeof r=="string"?r:r&&typeof r=="object"&&"message"in r?String(r.message):t}const Ot=new AbortController;window.addEventListener("pagehide",()=>Ot.abort(),{once:!0}),window.addEventListener("beforeunload",()=>Ot.abort(),{once:!0});const Sn=new Map;function cs(r,t="sat"){const e=`${String(r).replace(/\/+$/,"")}|${t}`,n=Sn.get(e);if(n)return n;const s=(async()=>{const i=new _n(r,{unit:t,logger:new Mi("debug")});return await i.loadMint(),i})();return s.catch(()=>Sn.delete(e)),Sn.set(e,s),s}function da(r){const t=Number(r.data("order-id")),e=String(r.data("order-key")??""),n=String(r.data("return-url")??""),s=Number(r.data("pay-amount-sats")??0),i=String(r.data("melt-quote-id")??""),o=Number(r.data("spot-quote-expiry")??0)*1e3,a=String(r.data("trusted-mint")??"");if(!Number.isFinite(t)||t<=0||!e||!n||!a||!Number.isFinite(s)||s<=0||!i)throw new Error("Bad order data");return{orderId:t,orderKey:e,returnUrl:n,expectedPaySats:s,quoteId:i,quoteExpiryMs:o,trustedMint:a}}function Bn(r,t){try{const e=new URL(r),n=new URL(t),s=e.origin+e.pathname.replace(/\/+$/,""),i=n.origin+n.pathname.replace(/\/+$/,"");return s===i}catch{return r.replace(/\/+$/,"")===t.replace(/\/+$/,"")}}function tt(r,...t){const n=(window.cashu_wc?.i18n??{})[r]??r;if(!t.length)return n;try{return wp.i18n.sprintf(n,...t)}catch{return n}}function us(r){try{const t=localStorage.getItem(r);return t?JSON.parse(t):null}catch{return null}}function ls(r,t){try{localStorage.setItem(r,JSON.stringify(t))}catch{}}function hs(r){try{localStorage.removeItem(r)}catch{}}function pa(r){try{const t=us(r);return!t||!Array.isArray(t.items)||Date.now()-t.created>3600*1e3?{v:1,created:Date.now(),items:[]}:t}catch{return{v:1,created:Date.now(),items:[]}}}jQuery(function(r){const t=r("#cashu-pay-root");if(!t.length)return;const e=t.next("section.cashu-checkout");if(!e.length)return;const n=e.find("form.cashu-token"),s=e.find("[data-cashu-token-input]"),i=n.find('button[type="submit"]'),o=e.find(".cashu-status"),a=e.find("[data-cashu-qr]"),c=(m,b=!1)=>{const x=b?"var(--cashu-warning)":"var(--cashu-status)";o.text(m).css("background-color",x)},l=m=>{i.prop("disabled",m),s.prop("disabled",m)};l(!1),n.off("submit").on("submit",m=>{m.preventDefault();const b=k();if(!b){c(tt("paste_token_first"),!0);return}R(()=>N(b),{user:!0})});let h;try{h=da(t)}catch{o.text(tt("data_incomplete"));return}let d=null,g=Promise.resolve(),p=null,y=0;const I=cs(h.trustedMint,"sat"),k=()=>String(s.val()??"").trim(),O={mq:"cashu_wc_mq",change:"cashu_wc_change",recovery:"cashu_wc_recovery"};try{hs(O.change)}catch{}$().catch(()=>{c(tt("invoice_failed"),!0)});async function $(){U(),_(),K();const m=localStorage.getItem(O.recovery);m&&N(m).catch(b=>{console.error(b),c(tt("recovery_failed"),!0),s.val(m),localStorage.removeItem(O.recovery)})}async function U(){const m=await C(),b=a.get(0);if(!b||typeof QRCode>"u")return;b.innerHTML="",new QRCode(b,{text:"lightning:"+m.request,width:360,height:360,colorDark:"#000000",colorLight:"#ffffff",correctLevel:QRCode.CorrectLevel.Q}),a.parent().off("click").on("click",async()=>{ha(m.request),c(tt("copied")),await lt(500),c(tt("waiting_for_payment"))})}async function R(m,b={}){const x=!!b.user;if(x&&y>0)return c(tt("payment_in_progress"),!0),Promise.resolve(void 0);x&&(y++,y===1&&l(!0));const A=g.then(m).catch(f=>{const u=An(f);c(u,!0)});g=A.then(()=>{});try{return await A}finally{x&&(y--,y===0&&l(!1))}}async function j(m,b){if(m.length<1)return;const x=Pt(m),A=b.getFeesForProofs(m),f=Gr({mint:b.mint.mintUrl,proofs:m,unit:"sat"}),u=Bn(b.mint.mintUrl,h.trustedMint)?tt("change_from_network"):tt("change_from_token");Y({mint:b.mint.mintUrl,token:f,amount:x,kind:u,dust:x<=A})}function Y(m){const b=pa(O.change);b.items.some(A=>A.token===m.token)||b.items.push(m),b.items=b.items.slice(-5),ls(O.change,b)}async function N(m){c(tt("checking_token")),await lt(500);let b;try{b=jo(m)}catch(W){console.error(An(W)),c(tt("invalid_token"),!0);return}const x=String(b.mint??"").trim(),A=String(b.unit??"sat");if(!x||b.amount===0){c(tt("no_spendable_proofs"),!0);return}if(A!=="sat"){c(tt("not_sat_denom"),!0);return}c(tt("connecting_to_mint")),await lt(500);const f=await cs(x,"sat");let v=f.decodeToken(m).proofs;if(!Array.isArray(v)||v.length===0){c(tt("no_usable_proofs"),!0);return}if(Bn(x,h.trustedMint)){const W=await I;await L(v,W);return}const S=await C(),P=Pt(v),B=f.getFeesForProofs(v);c(tt("calculating_fees")),await lt(500);const q=await f.createMeltQuoteBolt11(S.request),T=q.amount+q.fee_reserve+B,F=q.fee_reserve+B;if(P<T){const W=window.cashu_wc?.symbol??"â‚¿";c(tt("token_too_small",W,P,T,F),!0);return}c(tt("sending_payment")),await lt(500);const D=await f.meltProofsBolt11(q,v),H=Array.isArray(D?.change)?D.change:[];j(H,f),c(tt("waiting_confirmation"))}async function C(){return d||(d=(async()=>{const m=us(O.mq);if(M(m))return m;const x=await(await I).createMintQuoteBolt11(h.expectedPaySats),A={mint:h.trustedMint,amount:h.expectedPaySats,quote:x.quote,request:x.request,expiry:x.expiry??null};return ls(O.mq,A),A})(),d.catch(()=>{d=null}),d)}function M(m){if(!m||!m.quote||!m.request||!m.mint||m.amount!==h.expectedPaySats||!Bn(m.mint,h.trustedMint))return!1;const b=typeof m.expiry=="number"?m.expiry:0,x=Math.floor(Date.now()/1e3);return!(b>0&&b<=x)}async function K(){const m=await C(),b=await I,x=async()=>{const u=h.quoteExpiryMs-Date.now();if(u<=0||Ot.signal.aborted)return!1;const v=Math.max(1e4,u);try{return await Promise.race([b.on.onceMintPaid(m.quote,{signal:Ot.signal,timeoutMs:v}),lt(u).then(()=>{throw new Error("Quote expired")})]),!0}catch{return!1}},A=async()=>{try{for(;!Ot.signal.aborted&&Date.now()<h.quoteExpiryMs;){if((await b.checkMintQuoteBolt11(m.quote)).state==="PAID")return!0;await lt(3e3)}return!1}catch{return!1}};(await x()||!Ot.signal.aborted&&await A())&&R(()=>J(m))}async function J(m){if(p)return p;p=(async()=>{c(tt("payment_received")),await lt(500);const b=await I,x=await b.mintProofsBolt11(h.expectedPaySats,m.quote);hs(O.mq),d=null,await L(x,b)})();try{await p}catch(b){throw p=null,b}}async function L(m,b){const x=Gr({mint:h.trustedMint,proofs:m,unit:"sat"});let A;c(tt("paying_invoice"));try{localStorage.setItem(O.recovery,x);const u=await b.checkMeltQuoteBolt11(h.quoteId);A=await b.meltProofsBolt11(u,m)}catch(u){s.val(x),c(An(u),!0);return}finally{localStorage.removeItem(O.recovery)}const f=Array.isArray(A?.change)?A.change:[];j(f,b),c(tt("confirming_payment"))}async function E(){const m=String(window.cashu_wc?.rest_root??""),b=String(window.cashu_wc?.confirm_route??"");if(!m||!b)return null;const x=m.replace(/\/?$/,"/")+b.replace(/^\//,""),A={order_id:h.orderId,order_key:h.orderKey,quote_id:h.quoteId};try{const u=await(await fetch(x,{method:"POST",headers:{"Content-Type":"application/json"},credentials:"same-origin",body:JSON.stringify(A)})).json();if(u?.state==="PAID")return fa(),await lt(2e3),window.location.assign(String(u.redirect??h.returnUrl)),u;if(u?.state==="EXPIRED")return c(tt("invoice_expired"),!0),await lt(2e3),window.location.assign(String(h.returnUrl)),u;if(u?.expiry){const v=tt("invoice_expires_in",w(u.expiry)),S=u.expiry-Date.now()/1e3;S<300&&c(v,S<60)}return u??null}catch{return null}}async function _(){if(Ot.signal.aborted||Date.now()>h.quoteExpiryMs){window.location.assign(String(h.returnUrl));return}for(;!Ot.signal.aborted&&Date.now()<=h.quoteExpiryMs;){await lt(3e3);const m=await R(()=>E());if(m?.state==="PAID"||m?.state==="EXPIRED")return}await lt(500),await R(()=>E())}function w(m,b=Date.now()){const x=m*1e3-b,A=Math.max(0,Math.floor(x/1e3)),f=Math.floor(A/60),u=A%60,v=String(f).padStart(2,"0"),S=String(u).padStart(2,"0");return`${v}:${S}`}})})();
